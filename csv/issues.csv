"id","issue_number","created_at","closed_at","updated_at","title","body","state","author_login","author_id","labels","html_url","comments_count","classification","pull_request_url","issue_resolution_time","body_processed","evidence"
263,44188,"2022-08-09 10:07:00","2022-12-10 17:06:41","2022-12-10 17:06:41","http.ServerResponse is not an instance of stream.Writable?","### Version

18.7.0

### Platform

Microsoft Windows NT 10.0.19044.0 x64

### Subsystem

stream

### What steps will reproduce the bug?

```js
import { createServer } from 'node:http';
import { Writable } from 'node:stream';
import { once } from 'node:events';

const server = createServer(async (req, nodeStreamResponse) => {
  const webStreamResponse = Writable.toWeb(nodeStreamResponse);
});
server.listen({ port: 8080 });
await once(server, 'listening');
await fetch('http://localhost:8080');
```


### How often does it reproduce? Is there a required condition?

Always.

### What is the expected behavior?

According to the [documentation](https://nodejs.org/docs/latest-v18.x/api/http.html):
> Class: http.ServerResponse extends http.OutgoingMessage
> Class: http.OutgoingMessage extends Stream

This means that `ServerResponse` fulfilling the contract `Writable.toWeb`.


### What do you see instead?

```sh
TypeError [ERR_INVALID_ARG_TYPE]: The ""streamWritable"" argument must be an stream.Writable. Received an instance of ServerResponse
    at new NodeError (node:internal/errors:387:5)
    at Object.newWritableStreamFromStreamWritable (node:internal/webstreams/adapters:99:11)
    at Writable.toWeb (node:internal/streams/writable:926:27)  
```

### Additional information

Maybe this [condition](https://github.com/nodejs/node/blob/main/lib/internal/webstreams/adapters.js#L98):
```js
if (typeof streamWritable?._writableState !== 'object') {
```
 is too heavy?","closed","sosoba",2843525,"{confirmed-bug,http,stream,""good first issue"",""web streams""}","https://github.com/nodejs/node/issues/44188",9,"Ambos",NULL,123,NULL,"A issue relata um erro onde `http.ServerResponse` não é uma instância de `stream.Writable`, apesar da documentação sugerir que `http.OutgoingMessage` (do qual `http.ServerResponse` herda) estenda `Stream`.  Os comentários discutem a necessidade de refatoração em `stream.Writable.toWeb` para aceitar `http.OutgoingMessage` (Refatoração) e também a necessidade de correção em uma declaração de tipo em `@types/node` (Testes de Regressão, pois aponta para um problema em testes de tipo).  A solução envolve ambos os aspectos:  mudar a função `toWeb` para aceitar `http.OutgoingMessage` e potencialmente ajustar o comportamento de `OutgoingMessage.writable` após `OutgoingMessage.destroyed` ser `true`. Portanto, a classificação é 'Ambos', pois envolve tanto refatoração quanto testes de regressão para resolver completamente o problema."
84,56375,"2024-12-27 11:59:43","2025-01-12 20:53:05","2025-01-12 20:53:06","tls.createSecureContext results in an abort","### Version

v22.11.0

### Platform

```text
Linux u24vm 6.8.0-50-generic #51-Ubuntu SMP PREEMPT_DYNAMIC Sat Nov  9 17:58:29 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux
```

### Subsystem

tls

### What steps will reproduce the bug?

Setup a node instance,
```
» node
```
and run the following javascript code.
```
tls = require('tls');
tls.createSecureContext({clientCertEngine:'x'});
```
Then the node instance occurs an abort.

### How often does it reproduce? Is there a required condition?

This abort can always be triggered following the steps above.

### What is the expected behavior? Why is that the expected behavior?

If any error occurs, an exception or similar error-reporting stuff should be thrown, caught, and handled correctly. There is no reason to abort the whole node process.



### What do you see instead?

```
» node                                                 
Welcome to Node.js v22.11.0.
Type "".help"" for more information.
> tls = require('tls');
{
  CLIENT_RENEG_LIMIT: 3,
  CLIENT_RENEG_WINDOW: 600,
  DEFAULT_CIPHERS: 'TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA',
  DEFAULT_ECDH_CURVE: 'auto',
  DEFAULT_MIN_VERSION: 'TLSv1.2',
  DEFAULT_MAX_VERSION: 'TLSv1.3',
  getCiphers: [Function (anonymous)],
  rootCertificates: [Getter],
  convertALPNProtocols: [Function: convertALPNProtocols],
  checkServerIdentity: [Function: checkServerIdentity],
  createSecureContext: [Function: createSecureContext],
  SecureContext: [Function: SecureContext],
  TLSSocket: [Function: TLSSocket],
  Server: [Function: Server],
  createServer: [Function: createServer],
  connect: [Function: connect],
  createSecurePair: [Function: deprecated]
}
> tls.createSecureContext({clientCertEngine:'x'});
[1]    305195 segmentation fault (core dumped)  node
```

### Additional information

_No response_","closed","zyscoder",23655282,"{confirmed-bug,tls}","https://github.com/nodejs/node/issues/56375",2,"Ambos",NULL,16,"node abort tls createSecureContext clientCertEngine exception error report handle process
","O título da issue (""tls.createSecureContext results in an abort"") sugere um problema de funcionamento (bug) que pode necessitar de refatoração para corrigir a raiz do problema.  Os comentários mencionam ""regression"" (regressão), indicando um teste de regressão falhou, e também discutem a manipulação de vetores e exceções, o que pode levar a mudanças de código (refatoração) para corrigir o erro.  A combinação de um possível bug e a menção explícita de regressão justificam a classificação 'Ambos'."
85,56366,"2024-12-26 03:58:05","2025-01-06 13:48:38","2025-01-06 13:48:39","vm.compileFunction results in an abort","### Version

v22.11.0

### Platform

```text
Linux u24vm 6.8.0-50-generic #51-Ubuntu SMP PREEMPT_DYNAMIC Sat Nov  9 17:58:29 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux
```

### Subsystem

vm

### What steps will reproduce the bug?

Setup a node instance,
```
» node
```
and run the following javascript code.
```
vm = require('vm');
_454 = (new vm.Script('')).createCachedData();
_723 = {cachedData:_454,produceCachedData:true};
vm.compileFunction('',undefined,_723);
```
Then the node instance occurs an abort.

### How often does it reproduce? Is there a required condition?

This abort can always be triggered following the steps above.

### What is the expected behavior? Why is that the expected behavior?

If any error occurs, an exception or similar error-reporting stuff should be thrown, caught, and handled correctly. There is no reason to abort the whole node process.

### What do you see instead?

```
 » node                                                                     
Welcome to Node.js v22.11.0.
Type "".help"" for more information.
> vm = require('vm');
{
  Script: [class Script extends ContextifyScript],
  createContext: [Function: createContext],
  createScript: [Function: createScript],
  runInContext: [Function: runInContext],
  runInNewContext: [Function: runInNewContext],
  runInThisContext: [Function: runInThisContext],
  isContext: [Function: isContext],
  compileFunction: [Function: compileFunction],
  measureMemory: [Function: measureMemory],
  constants: [Object: null prototype] {
    USE_MAIN_CONTEXT_DEFAULT_LOADER: Symbol(vm_dynamic_import_main_context_default),
    DONT_CONTEXTIFY: Symbol(vm_context_no_contextify)
  }
}
> _454 = (new vm.Script('')).createCachedData();
<Buffer 28 06 de c0 74 fe da 79 00 00 00 00 f5 24 1e 1c ad 85 35 f2 30 01 00 00 00 00 00 00 00 00 00 00 01 20 54 03 24 07 b4 60 00 00 00 00 02 00 00 00 01 0c ... 286 more bytes>
> _723 = {cachedData:_454,produceCachedData:true};
{
  cachedData: <Buffer 28 06 de c0 74 fe da 79 00 00 00 00 f5 24 1e 1c ad 85 35 f2 30 01 00 00 00 00 00 00 00 00 00 00 01 20 54 03 24 07 b4 60 00 00 00 00 02 00 00 00 01 0c ... 286 more bytes>,
  produceCachedData: true
}
> vm.compileFunction('',undefined,_723);
FATAL ERROR: v8::ScriptCompiler::CreateCodeCacheForFunction Expected SharedFunctionInfo with wrapped source code
----- Native stack trace -----

 1: 0xe19ca5 node::OnFatalError(char const*, char const*) [node]
 2: 0x123f996 v8::Utils::ReportApiFailure(char const*, char const*) [node]
 3: 0x1248df7 v8::ScriptCompiler::CreateCodeCacheForFunction(v8::Local<v8::Function>) [node]
 4: 0xf610b8 node::contextify::ContextifyContext::CompileFunctionAndCacheResult(node::Environment*, v8::Local<v8::Context>, v8::ScriptCompiler::Source*, std::vector<v8::Local<v8::String>, std::allocator<v8::Local<v8::String> > >, std::vector<v8::Local<v8::Object>, std::allocator<v8::Local<v8::Object> > >, v8::ScriptCompiler::CompileOptions, bool, v8::Local<v8::Symbol>, node::errors::TryCatchScope const&) [node]
 5: 0xf62d2b node::contextify::ContextifyContext::CompileFunction(v8::FunctionCallbackInfo<v8::Value> const&) [node]
 6: 0x7fca6940f5e2

----- JavaScript stack trace -----

1: internalCompileFunction (node:internal/vm:128:18)
2: compileFunction (node:vm:364:10)
3: REPL4:1:4
4: runInThisContext (node:vm:137:12)
5: defaultEval (node:repl:598:22)
6: bound (node:domain:433:15)
7: runBound (node:domain:444:12)
8: onLine (node:repl:927:10)
9: emit (node:events:530:35)
10: emit (node:domain:489:12)


[1]    1489272 IOT instruction (core dumped)  node
```

### Additional information

_No response_","closed","zyscoder",23655282,"{confirmed-bug,vm}","https://github.com/nodejs/node/issues/56366",6,"Refatoração",NULL,11,"node instance abort error exception handling node process javascript vm compilefunction cacheddata  fatal error v8 scriptcompiler createcodecacheforfunction sharedfunctioninfo wrapped source code internalcompilefunction compilefunction repl runinthiscontext defaulteval bound runbound online emit
","O título da issue ""vm.compileFunction results in an abort"" sugere um problema com a função `vm.compileFunction`.  O corpo da issue descreve um erro de abort no Node.js relacionado a manipulação de exceções,  `vm.compileFunction`, cache de dados e o compilador V8. Os comentários discutem a solução do problema e a correção.  Não há menção direta a testes de regressão, a ênfase está em corrigir um comportamento interno da função, o que caracteriza uma refatoração para melhorar a estabilidade e possivelmente o desempenho."
87,56230,"2024-12-11 17:45:22","2024-12-28 08:52:28","2024-12-28 08:52:28","assert.partialDeepStrictEqual not working when comparing [0] and [-0]","### Version

v22.12.0

### Platform

```text
Darwin something.local 24.1.0 Darwin Kernel Version 24.1.0: Thu Oct 10 21:05:23 PDT 2024; root:xnu-11215.41.3~2/RELEASE_ARM64_T6031 arm64
```


### Subsystem

_No response_

### What steps will reproduce the bug?

const assert = require('assert');


assert.throws(() => assert.deepStrictEqual([0], [-0]), Error);
assert.throws(() => assert.partialDeepStrictEqual([0], [-0]), Error); // This will fail

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

`assert.partialDeepStrictEqual` should behave as `assert.deepStrictEqual`

### What do you see instead?

The method call does not throw

### Additional information
","closed","puskin94",8344987,"{confirmed-bug,assert}","https://github.com/nodejs/node/issues/56230",0,"Nenhum",NULL,17,"assert partialdeepstrict equal deepstrict equal comportar método chamar lançar
","O título da issue ""assert.partialDeepStrictEqual not working when comparing [0] and [-0]"" e o corpo ""assert partialdeepstrict equal deepstrict equal comportar método chamar lançar"" indicam um problema com um teste específico (assert.partialDeepStrictEqual) e sua falha ao comparar dois valores. Não há menção a refatoração de código ou testes de regressão em geral, apenas a um problema em um teste unitário específico."
89,56204,"2024-12-10 10:57:44","2024-12-10 22:17:39","2024-12-10 22:17:39","--dns-result-order=ipv4first behaviour change in v22.12.0","### Version

v22.12.0

### Platform

```text
Microsoft Windows NT 10.0.20348.0 x64
```


### Subsystem

dns

### What steps will reproduce the bug?

We are tracking v22.x with a view to migrating in the Spring. Have just upgraded test system from v22.11.0 and restarted applications.

Applications are express configured to listen on https with server hostname. Under Node 18.x we are using --dns-result-order=ipv4first to get the binding to the IPV4 address rather than IPV6. This worked the same with v22.11.0

Now that v22.12.0 is installed in place of v22.11.0 - despite the argument still being in place, the application binds to the IPV6 address.

With the argument removed, the IPV6 address binds also.

### How often does it reproduce? Is there a required condition?

As above

### What is the expected behavior? Why is that the expected behavior?

Node binds to IPV4 address.

### What do you see instead?

Node binds to IPV6 address

### Additional information

In https://nodejs.org/en/blog/release/v22.12.0 I can see https://github.com/nodejs/node/pull/55392 

Using the same test as the original reporter, under Node 18.x I get 

null [ { address: '::1', family: 6 }, { address: '127.0.0.1', family: 4 } ]

Under 22.11.0 it is the same

null [ { address: '::1', family: 6 }, { address: '127.0.0.1', family: 4 } ]

But with 22.12.0 installed it outputs

null [ { address: '::1', family: 6 } ]

Thanks","closed","DevRCRun",61196639,"{confirmed-bug,dns,windows}","https://github.com/nodejs/node/issues/56204",4,"Nenhum",NULL,0,"node ipv4 ipv6 address bind upgrade version application system argument restart
","O título e o corpo da issue mencionam mudanças de comportamento relacionadas à ordem de resultados DNS (ipv4first) em uma versão específica do software (v22.12.0), bem como problemas com o binding de endereço ipv4 e ipv6.  Os comentários fornecem informações adicionais sobre tentativas de reprodução,  referências a mudanças no DNS do Node.js e a um possível duplicata. Não há menção explícita a refatoração ou testes de regressão. A issue descreve um problema e suas possíveis causas, não um processo de refatoração ou execução de testes."
268,43868,"2022-07-16 21:41:52","2022-11-23 08:06:26","2022-11-23 08:06:26","Uncaught exception on fetch (related to zlib, Z_BUF_ERROR)","### Version

18.6.0

### Platform

Linux pop-os 5.17.15-76051715-generic #202206141358~1655919116~22.04~1db9e34 SMP PREEMPT Wed Jun 22 19 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

undici

### What steps will reproduce the bug?

```js
async function test() {
    const x = await fetch(""http://www.sinlenoble.fr/solidarite/le-ccas"");
    const y = await x.text();
}

test().then(() => process.exit(0), () => process.exit(1))

process.on(""unhandledRejection"", (r) => console.log(""undhanled rejection"", r))
process.on(""uncaughtException"", (r) => console.log(""uncaught exception"", r))
```

Output:

```
(node:18923) ExperimentalWarning: The Fetch API is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
uncaught exception Error: unexpected end of file
    at Zlib.zlibOnError [as onerror] (node:zlib:189:17) {
  errno: -5,
  code: 'Z_BUF_ERROR'
}
```

### How often does it reproduce? Is there a required condition?

Always, but it may go away if the remote site used for testing changes its code/configuration.

### What is the expected behavior?

If there is an error with `fetch`, it should bubble inside the promise to be caught from the caller, instead of triggering an uncaught exception.

### What do you see instead?

```
uncaught exception Error: unexpected end of file
    at Zlib.zlibOnError [as onerror] (node:zlib:189:17) {
  errno: -5,
  code: 'Z_BUF_ERROR'
}
```

### Additional information

This is not the only site that triggered this","closed","coyotte508",342922,"{confirmed-bug,errors,fetch}","https://github.com/nodejs/node/issues/43868",10,"Ambos",NULL,129,NULL,"A issue relata um erro 'unexpected end of file' em Node.js v18 ao usar o `fetch` com um site que retorna um cabeçalho `content-encoding: gzip` incorretamente em um redirecionamento com corpo vazio.  Os comentários indicam que o problema está relacionado a uma alteração no Zlib do Node.js v18 e a um refatoramento no `pipeline` do undici.  Há discussão sobre a necessidade de um manipulador de erros no `pipeline` (refatoração) e a correção do problema tanto no lado do undici (adicionando um tratador de erros - refatoração) quanto na investigação da causa raiz no Node.js (testes de regressão, pois afeta a compatibilidade com versões anteriores).  A solução envolve correções tanto de código (refatoração no undici) quanto testes para garantir que não ocorra em outras situações (testes de regressão)."
372,36669,"2020-12-28 21:23:55","2021-01-09 16:54:45","2021-01-09 16:54:45","The Node.js will stuck when exec `Object.defineProperty(Array.prototype, '-1', {get: function(){return this[this.length - 1]}})` in REPL","* **Version**: v15.3.0
* **Platform**: Linux *** 5.9.11-3-MANJARO #1 SMP PREEMPT Sat Nov 28 09:08:57 UTC 2020 x86_64 GNU/Linux
* **Subsystem**:

### What steps will reproduce the bug?
```js
Object.defineProperty(Array.prototype, '-1', {get: function(){return this[this.length - 1]}})
```

When exec these code in REPL, the Node.js will let cpu occupancy rate become 100% and stuck itself.
<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->

### How often does it reproduce? Is there a required condition?
100% reproduce.

### What is the expected behavior?

<!--
If possible please provide textual output instead of screenshots.
-->

### What do you see instead?

<!--
If possible please provide textual output instead of screenshots.
-->
```bash
> Object.defineProperty(Array.prototype, '-1', {get: function(){return this[this.length - 1]}})
Object(0) []
> 
```
### Additional information
It can be reproduce in Node.js v14.8.0 on my Android's termux.
 <!--
Tell us anything else you think we should know.
-->
","closed","Me7426",25323388,"{confirmed-bug,repl,stream}","https://github.com/nodejs/node/issues/36669",2,"Nenhum",NULL,12,"reproduce bug nodejs cpu occupancy rate percent stuck defineproperty array prototype get return length exec code repl
","A issue descreve um bug no Node.js relacionado ao uso de `Object.defineProperty` no Array.prototype.  Não há menção a refatoração de código ou testes de regressão. O foco é a resolução de um problema de execução e desempenho. Os comentários detalham a investigação da causa raiz do bug, mas não se referem a atividades de refatoração ou testes."
91,56115,"2024-12-02 23:05:38","2024-12-05 16:12:52","2024-12-05 16:12:52","Unable to catch error thrown during require in node.js v22 (works in v20)","### Version

v22.11.0

### Platform

```text
Darwin Davids-MacBook-Pro.local 23.6.0 Darwin Kernel Version 23.6.0: Mon Jul 29 21:14:30 PDT 2024; root:xnu-10063.141.2~1/RELEASE_ARM64_T6000 arm64
```


### Subsystem

_No response_

### What steps will reproduce the bug?

Create a new directory and add two files: bar.js and foo.js.

bar.js
```
try {
  require('./foo');
} catch (err) {
  console.log('got an error', err);
}
```
foo.js
```
Object.defineProperty(exports, ""__esModule"", { value: true });
const module_1 = require(""module"");
const require = (0, module_1.createRequire)(import.meta.url);
```
Run `node bar.js`.

Observe that with node v22 it exits with code 1 while with node v20 it exits with code 0. 

### How often does it reproduce? Is there a required condition?

It reproduces constantly.

### What is the expected behavior? Why is that the expected behavior?

I expect node to exit with code 0 because I wrapped the `require` with try/catch.

### What do you see instead?

node exits with code 1.

### Additional information

In practice, `bar.js` is my CLI tool, and `foo.js` is a user-created plugin over which I have no control.","closed","davidfirst",1963573,"{confirmed-bug,module}","https://github.com/nodejs/node/issues/56115",2,"Ambos",NULL,3,"node exit codigo erro plugin usuario criar controlar ferramenta cli pacote modulo importar falha captura excecao
","O título da issue sugere um problema de compatibilidade entre versões do Node.js, indicando a necessidade de refatoração para garantir a compatibilidade com a versão 22. Os comentários descrevem um bug relacionado à detecção de sintaxe ESM no `require`,  necessitando de correções (refatoração) e subsequentes testes de regressão para garantir que a correção não introduza novos problemas em outras áreas do código.  A menção a 'urgent fix' reforça a necessidade de ambos os tipos de ações."
93,55983,"2024-11-24 10:24:49","2024-11-28 16:26:18","2024-11-28 16:26:18","```fs.fstat``` results in an abort with some arguments","### Version

v22.11.0

### Platform

```text
Linux u24vm 6.8.0-48-generic #48-Ubuntu SMP PREEMPT_DYNAMIC Fri Sep 27 14:04:52 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux
```


### Subsystem

fs.fstat, v8

### What steps will reproduce the bug?

0. Sorry that the abort occurs from a third-party library, and I'm not sure if it's proper to report the crash to nodejs community.
1. npm version: 10.9.0
2. Try to install the package: lzma-native.
```
a. npm init -y
{
  ""name"": ""package-cf2b3d61d5de70b987170d0fe1c84397"",
  ""version"": ""1.0.0"",
  ""main"": ""index.js"",
  ""scripts"": {
    ""test"": ""echo \""Error: no test specified\"" && exit 1""
  },
  ""keywords"": [],
  ""author"": """",
  ""license"": ""ISC"",
  ""description"": """"
}

b. npm shrinkwrap

c. npm install --save lzma-native
added 8 packages, and audited 9 packages in 4s

1 package is looking for funding
  run `npm fund` for details

found 0 vulnerabilities

d. npm audit fix
added 8 packages, and audited 9 packages in 4s

1 package is looking for funding
  run `npm fund` for details

found 0 vulnerabilities

```
the final package.json is as follows:
```
{
  ""name"": ""package-cf2b3d61d5de70b987170d0fe1c84397"",
  ""version"": ""1.0.0"",
  ""main"": ""index.js"",
  ""scripts"": {
    ""test"": ""echo \""Error: no test specified\"" && exit 1""
  },
  ""keywords"": [],
  ""author"": """",
  ""license"": ""ISC"",
  ""description"": """",
  ""dependencies"": {
    ""lzma-native"": ""^8.0.6""
  }
}
```
2. Setup a node instance,
```
node
```
3. and run the following javascript code.
```
(async function() {
    var lib = await import('lzma-native');
    var result = lib.parseFileIndexFD(Symbol(""adjlyxzmfd""));;
})();
```
Then the node instance occurs an abort.

### How often does it reproduce? Is there a required condition?

This abort can always be triggered following the steps above.

### What is the expected behavior? Why is that the expected behavior?

If any error occurs, an exception or other similar error-reporting stuff should be thrown. There is no reason to abort the whole node process.

### What do you see instead?

 » node                                                                                                                                                
Welcome to Node.js v22.11.0.
Type "".help"" for more information.
> (async function() {
...     var lib = await import('lzma-native');
...     var result = lib.parseFileIndexFD(Symbol(""adjlyxzmfd""));;
... })();
Promise {
  <pending>,
  [Symbol(async_id_symbol)]: 28,
  [Symbol(trigger_async_id_symbol)]: 6
}
> FATAL ERROR: v8::ToLocalChecked Empty MaybeLocal
----- Native stack trace -----

 1: 0xe19ca5 node::OnFatalError(char const*, char const*) [node]
 2: 0x123f996 v8::Utils::ReportApiFailure(char const*, char const*) [node]
 3: 0x10e8085 node::DetermineSpecificErrorType[abi:cxx11](node::Environment*, v8::Local<v8::Value>) [node]
 4: 0xe38f71  [node]
 5: 0xf8d068  [node]
 6: 0x7d22ff20f5e2 

----- JavaScript stack trace -----

1: fstat (node:fs:1531:11)
2: exports.parseFileIndexFD (/home/u24vm/Projects/nodejsfuzz/packages/package-cf2b3d61d5de70b987170d0fe1c84397/node_modules/lzma-native/index.js:526:13)
3: REPL4:3:22


[1]    742850 IOT instruction (core dumped)  node

### Additional information

_No response_","closed","zyscoder",23655282,"{confirmed-bug,fs}","https://github.com/nodejs/node/issues/55983",1,"Nenhum",NULL,4,"abort v8 lzma native package install nodejs exception error report crash  fstat parsefileindexfd  node process  javascript  import  symbol  pending  error reporting  abort whole process
","O título e a descrição da issue mencionam um erro de abort ('abort') ao usar a função `fs.fstat`, com detalhes sobre o ambiente (v8, lzma, Node.js) e a natureza do problema (exceção, falha).  Os comentários pedem um exemplo mínimo reprodutível, o que indica a necessidade de investigação e solução do erro, mas não há menção direta a refatoração ou testes de regressão. O foco é na correção de um bug, não em melhorias de código ou testes."
94,55849,"2024-11-14 09:54:41","2024-11-17 10:25:13","2024-11-17 10:25:13","Timers mock panic with sub-test","### Version

v22.10.0

### Platform

_No response_

### Subsystem

_No response_

### What steps will reproduce the bug?

### 1. Create a test file `a.test.mjs`

```js
import test from 'node:test'

test.beforeEach((t) => {
    t.mock.timers.enable({ apis: ['Date'] })
    t.mock.timers.tick(1731488301220) // 2024-11-13 16:58:21.220
})

test('test 1', async (t) => {
    await t.test('sub test 1', async (t) => {
        //
    })
})
```

### 2. Run the following command to test

```bash
node --test --experimental-default-type=module ./a.test.mjs
```

### How often does it reproduce? Is there a required condition?

Every time

### What is the expected behavior? Why is that the expected behavior?

There should be not panic

### What do you see instead?

```
▶ test 1
  ✖ sub test 1 (1.0925ms)
    TypeError [Error]: Cannot redefine property: Symbol(MockTimers)
        at defineProperties (<anonymous>)
        at #createDate (node:internal/test_runner/mock/mock_timers:381:5)
        at Object.Date (node:internal/test_runner/mock/mock_timers:614:45)
        at node:internal/test_runner/mock/mock_timers:635:74
        at Array.forEach (<anonymous>)
        at #toggleEnableTimers (node:internal/test_runner/mock/mock_timers:635:5)
        at MockTimers.enable (node:internal/test_runner/mock/mock_timers:720:29)
        at TestContext.<anonymous> (file:///path/to/a.test.mjs:4:19)
        at TestHook.runInAsyncScope (node:async_hooks:211:14)
        at TestHook.run (node:internal/test_runner/test:934:25)
```

### Additional information

_No response_","closed","axetroy",9758711,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/55849",5,"Testes de Regressão",NULL,3,"test file a test mjs run command test node test experimental default type module a test mjs expect behavior panic see instead type error cannot redefine property symbol mocktimer create date object date array foreach mocktimer enable test context file a test mjs testhook runinasyncscope testhook run
","O título ""Timers mock panic with sub-test"" e o corpo do texto mencionam testes (""test file"", ""test mjs"", ""expect behavior"", ""testhook"", etc.) e problemas com mocks (""Timers mock panic"", ""mocktimer""). Os comentários também discutem testes e abordagens para reproduzir e corrigir falhas nos testes.  Não há menção explícita a refatoração de código, apenas a resolução de problemas em testes existentes."
272,43655,"2022-07-02 16:55:21","2024-05-06 20:16:23","2024-05-06 20:16:23","Problem with GC (million promise rejections)","### Version

16.15.1

### Platform

Microsoft Windows NT 10.0.19042.0 x64

### Subsystem

_No response_

### What steps will reproduce the bug?

Just run it in the Node.JS <= 18:

(I have tested it on node v14.19.3, v16.15.1, v18.2.0)

**test.js**
```js
function delay(time) {
  return new Promise((resolve) => {
    setTimeout(resolve, time)
  })
}

async function test() {
  for (let i = 0; i < 1000000; i++) {
    await new Promise((resolve, reject) => {
      reject('value')
    })
      .then(() => {}, () => {})

    // if (i % 10000 === 0) {
    //  await delay(100)
    // }
  }

  console.log('OK')

  const time0 = Date.now()
  await delay(0)
  console.log('Real delay time: ' + (Date.now() - time0))
}

test()
```

The test function will generate 1 million of Promise rejections. And after finish it will hang. It seems like the garbage collection called on idle, and it takes very long time.
If you replace the `reject` with the `resolve`, then everything will work quickly.
You can also uncomment the periodically delay, and it will work quickly.

### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior?

_No response_

### What do you see instead?

Work without hungs

### Additional information

I can reproduce it in the Chromium 49 but it work correctly in the Chrome latest. It looks like this bug has been fixed in the Chrome.

This bug is easy to[ work around](https://stackoverflow.com/a/72767406/5221762), but now I have the same bug with 30000 call of worker functions. I can't describe it yet, because I need to research it before. I think maybe the promise rejection bug will expose a wider problem and I won't have to create a new issue.","closed","NikolayMakhonin",12973901,"{confirmed-bug,""v8 engine""}","https://github.com/nodejs/node/issues/43655",10,"Refatoração",NULL,674,NULL,"A issue relata um problema de desempenho relacionado ao garbage collector do Node.js ao lidar com um grande número de rejeições de promises.  Os comentários discutem otimizações de desempenho e a possibilidade de uma refatoração no mecanismo de tratamento de rejeições de promises para melhorar a performance, especialmente ao utilizar a flag `--unhandled-rejections=none`.  Embora testes de regressão sejam implicitamente necessários para validar qualquer alteração, a ênfase principal da issue é na melhoria do desempenho e otimização do código existente, caracterizando-a como um problema de refatoração."
377,36550,"2020-12-17 12:03:40","2020-12-17 23:40:53","2020-12-22 11:56:25","Object.assign / spread of http request object difference between v14.15.1 and v14.15.2","* **Version**: 14.15.2
* **Platform**: any
* **Subsystem**: any

### What steps will reproduce the bug?

While trying to create a cloned version of an http request object, prototype properties/methods such as `headers` and `get` get lost.

```js
const assert = require('assert');
const http = require('http');

const server = http
  .createServer((req, res) => {
    const dummyReq = { ...req };
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('ok');
    assert.deepStrictEqual(req.headers, dummyReq.headers);
  })
  .listen();

server.on('listening', () => {
  http.get(`http://localhost:${server.address().port}`);
});
```

### What is the expected behavior?

I honestly don't know if the behavior from 14.15.1 or from 14.15.2 is expected.

Behavior until 14.15.1:  `dummyReq.headers` is not `undefined`.

### What do you see instead?

Output in 14.15.2: `dummyReq.headers` is `undefined`.

### Additional info

The same happens while using `Object.assign`","closed","rubenstolk",692644,"{confirmed-bug,http}","https://github.com/nodejs/node/issues/36550",21,"Ambos",NULL,0,"clone http request object prototype property method lose header get  create clone version http request object prototype property method such header get lose  expect behavior honestly know behavior expect behavior  dummyreq header undefined output dummyreq header undefined  happen use object assign
","A issue descreve uma diferença de comportamento entre versões do Node.js (v14.15.1 e v14.15.2) relacionada à clonagem de objetos de requisição HTTP usando `Object.assign` e o operador spread.  Os comentários discutem a necessidade de uma refatoração (mudança no método de clonagem para evitar perda de headers) e a realização de testes de regressão para verificar o impacto da mudança em diferentes versões e cenários.  A discussão sobre reverter a mudança e o impacto em releases indica a necessidade de ambos, refatoração e testes de regressão, para garantir a estabilidade e compatibilidade do código."
379,36531,"2020-12-15 16:52:19","2021-03-01 19:43:51","2021-03-01 19:43:51","Worker thread throws error when started from `--require` script","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: 15.4.0
* **Platform**: Linux
* **Subsystem**: worker_threads

### What steps will reproduce the bug?

Run the following at a bash shell:

```
touch empty.js
echo ""new (require('worker_threads').Worker)('./empty.js')"" > create-worker.js
node -r ./create-worker.js ./empty.js
```

### How often does it reproduce? Is there a required condition?

It reproduces every time.  It happens when the worker is created by a `--require` script.

### What is the expected behavior?

No errors from the worker_thread.

### What do you see instead?

Logs the following:
```
node:events:353
      throw er; // Unhandled 'error' event
      ^
TypeError [Error]: undefined is not an integer typed array.
    at Atomics.load (<anonymous>)
    at process.cwd (node:internal/main/worker_thread:140:38)
    at MessagePort.<anonymous> (node:internal/main/worker_thread:153:48)
    at MessagePort.[nodejs.internal.kHybridDispatch] (node:internal/event_target:422:41)
    at MessagePort.exports.emitMessage (node:internal/per_context/messageport:18:26)
Emitted 'error' event on process instance at:
    at emitUnhandledRejectionOrErr (node:internal/event_target:602:11)
    at MessagePort.[nodejs.internal.kHybridDispatch] (node:internal/event_target:426:9)
    at MessagePort.exports.emitMessage (node:internal/per_context/messageport:18:26)
```

### Additional information

The line number referenced in the error is here: https://github.com/nodejs/node/blob/master/lib/internal/main/worker_thread.js#L140

Based on a brief look at the code, I guess node is assuming that the worker receives a bootstrapping message with a bunch of values, one of them being `cwdCounter`.  But when created via `--require`, that message is not sent or has not arrived yet.","closed","cspotcode",376504,"{confirmed-bug,worker}","https://github.com/nodejs/node/issues/36531",12,"Ambos",NULL,76,"version 15.4 platform linux subsystem worker_thread step reproduce bug run bash shell touch empty echo new require worker_threads worker empty js create_worker js node r create_worker js empty js reproduce frequency reproduce every time happen worker create require script expected behavior error worker_thread see instead log typeerror undefined integer type array atomics load process cwd messageport emitmessage emit unhandled rejection messageport emitmessage additional information line number reference error guess node assume worker receive bootstrapping message bunch value one cwdcounter create require message send arrive yet
","O título da issue sugere um problema de erro em threads worker, indicando a necessidade de refatoração.  Os comentários discutem soluções envolvendo a manipulação de erros, a ordem de inicialização e a prevenção de terminação prematura do worker, o que indica a necessidade de testes de regressão para garantir que a correção não introduza novos problemas.  A discussão abrange ambos os aspectos: correção do código (refatoração) e verificação da solução (testes de regressão)."
98,55576,"2024-10-28 17:48:57","2024-11-12 15:58:01","2024-11-12 15:58:01","GetReport takes very long times after http requests","### Version

22.10.0

### Platform

```text
Linux Tofandel 5.15.146.1-microsoft-standard-WSL2 #1 SMP Thu Jan 11 04:09:03 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux
```


### What steps will reproduce the bug?

```js
console.time(""report"");
process.report.getReport();
console.timeEnd(""report"");
await fetch('https://example.com/');
console.time(""report"");
process.report.getReport();
console.timeEnd(""report"");
await fetch('https://example.com/');
await fetch('https://example.com/');
console.time(""report"");
process.report.getReport();
console.timeEnd(""report"");
console.time(""report"");
process.report.getReport();
console.timeEnd(""report"");
```

### How often does it reproduce? Is there a required condition?

Always, I can reproduce on windows and on linux

### What is the expected behavior? Why is that the expected behavior?

The report to not take more than a few milliseconds

### What do you see instead?

The report takes 20 additional seconds to generate per fetch request that occured before it (up to 2 fetch, after that it keeps taking 40s)

```txt
report: 1.926ms
report: 20.129s
report: 41.714s
report: 40.311s
```

### Additional information

This still happens even with `node --report-exclude-network`","closed","Tofandel",6115458,"{confirmed-bug,libuv,report}","https://github.com/nodejs/node/issues/55576",23,"Ambos",NULL,15,"report tomar mais alguns milissegundo report tomar adicional segundo gerar requisicao buscar ocorrer antes manter tomar segundo  acontecer ainda node report exclude network
","O título e o corpo da issue mencionam tempos de resposta longos na função `GetReport` após requisições HTTP, indicando um problema de performance que pode necessitar de refatoração.  Por outro lado, os comentários demonstram tentativas de reprodução em diferentes ambientes (Windows, WSL, Linux), com foco em identificar a causa raiz do problema através de depuração e testes de regressão, buscando reproduzir o comportamento em diferentes escalas e configurações. A combinação de busca por otimizações de código (refatoração) e testes extensivos para identificar o problema (testes de regressão) justifica a classificação 'Ambos'."
100,55518,"2024-10-24 11:46:41","2024-11-11 16:29:17","2024-11-11 16:29:17","Uncaught error with `--experimental-import-meta-resolve`","### Version

22.10

### Platform

```text
Linux be964f1f5acb 6.10.4-linuxkit #1 SMP PREEMPT_DYNAMIC Wed Oct  2 16:39:54 UTC 2024 x86_64 Linux

https://hub.docker.com/layers/library/node/22-alpine/images/sha256-c5088ba04c8fcce84e45c9ab8767af401424943a8bfd90ede5a68aefc4f42808
```


### Subsystem

_No response_

### What steps will reproduce the bug?

Run with `--experimental-import-meta-resolve`:

```js
function resolve(specifier, parentURL) {
    console.log(`\n§ ${parentURL} --> ${specifier}`)
    try {
        console.log(`Resolved: ${import.meta.resolve(specifier, parentURL)}`)
    } catch (e) {
        console.log(`Error: ${e.code}`)
    }
}

resolve('foo', 'file:///bar.js')
resolve('./foo.js', 'http://example.com/bar.js')
resolve('file:///foo.js', 'http://example.com/bar.js')
resolve('foo', 'http://example.com/bar.js')
```

### How often does it reproduce? Is there a required condition?

Always reproduces

### What is the expected behavior? Why is that the expected behavior?

A catchable error that the specifier can't be resolved. This allows to provide a helpful error message that the user should add a custom resolver/loader.

### What do you see instead?

```
§ file:///bar.js --> foo
Error: ERR_MODULE_NOT_FOUND

§ http://example.com/bar.js --> ./foo.js
Resolved: http://example.com/foo.js

§ http://example.com/bar.js --> file:///foo.js
Error: ERR_INVALID_URL_SCHEME

§ http://example.com/bar.js --> foo

  #  node[1799]: static void node::modules::BindingData::GetPackageScopeConfig(const v8::FunctionCallbackInfo<v8::Value>&) at ../src/node_modules.cc:403
  #  Assertion failed: file_url

----- Native stack trace -----


----- JavaScript stack trace -----

1: getPackageScopeConfig (node:internal/modules/package_json_reader:132:33)
2: packageResolve (node:internal/modules/esm/resolve:792:43)
3: moduleResolve (node:internal/modules/esm/resolve:907:18)
4: defaultResolve (node:internal/modules/esm/resolve:1037:11)
5: defaultResolve (node:internal/modules/esm/loader:650:12)
6: #cachedDefaultResolve (node:internal/modules/esm/loader:599:25)
7: #resolveAndMaybeBlockOnLoaderThread (node:internal/modules/esm/loader:615:38)
8: resolveSync (node:internal/modules/esm/loader:632:52)
9: resolve (node:internal/modules/esm/initialize_import_meta:33:25)
10: resolve (file:///workspaces/nodejs-import-meta-resolve/[eval1]:6:46)


Aborted
```

### Additional information

_No response_","closed","ph-fritsche",39068198,"{confirmed-bug,experimental}","https://github.com/nodejs/node/issues/55518",8,"Ambos",NULL,18,"erro resolver especificador modulo importar meta resolve erro modulo nao encontrado erro url esquema invalido assercao falhou arquivo url
","O título da issue menciona um erro não capturado ('Uncaught error'), indicando um problema que precisa ser corrigido.  O corpo e os comentários descrevem problemas com a resolução de módulos, testes de asserção que falharam ('assertion fail'), e menções a funções internas ('moduleResolve'). A combinação de erros e testes falhados sugere que tanto refatoração (para corrigir o erro na resolução de módulos) quanto testes de regressão (para garantir que a correção não introduza novos problemas) são necessários."
101,55500,"2024-10-23 15:46:05","2024-10-28 12:21:23","2024-10-28 12:21:23","ERR_INTERNAL_ASSERTION with require(esm)","### Version

23.0.0

### Platform

```text
Darwin Nics-MacBook-Air.local 23.6.0 Darwin Kernel Version 23.6.0: Mon Jul 29 21:16:46 PDT 2024; root:xnu-10063.141.2~1/RELEASE_ARM64_T8112 arm64
```


### Subsystem

_No response_

### What steps will reproduce the bug?

**EDIT**: See in https://github.com/nodejs/node/issues/55500#issuecomment-2432711568 for a minimal reproduction

- Clone https://github.com/nicolo-ribaudo/babel/tree/node-bug
- Run `yarn install`
- Run `make use-esm`
- Run `(cd ./packages/babel-core/test/fixtures/async/plugin-mjs-tla-native; node ../../babel-compile-async.mjs ./input.js)`

### How often does it reproduce? Is there a required condition?

I don't have a minimal reproduction

### What is the expected behavior? Why is that the expected behavior?

To not tell me to open a bug report :P

### What do you see instead?

```
(node:69972) ExperimentalWarning: Support for loading ES Module in require() is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
node:internal/assert:11
    throw new ERR_INTERNAL_ASSERTION(message);
          ^

Error [ERR_INTERNAL_ASSERTION]: [BABEL]: A require()-d module that is imported again must be evaluated. Status = 2
This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues
 (While processing: /Users/nic/Documents/dev/github.com/babel/babel/packages/babel-core/test/fixtures/async/plugin-mjs-tla-native/plugin.js)
    at assert (node:internal/assert:11:11)
    at ModuleJobSync.run (node:internal/modules/esm/module_job:358:5)
    at onImport.tracePromise.__proto__ (node:internal/modules/esm/loader:543:42)
    at async loadMjsFromPath (file:///Users/nic/Documents/dev/github.com/babel/babel/packages/babel-core/lib/config/files/module-types.js:45:12) {
  code: 'ERR_INTERNAL_ASSERTION'
}
```

### Additional information

I don't think I'm using Node.js internals.

cc @joyeecheung ","closed","nicolo-ribaudo",7000710,"{confirmed-bug,esm,loaders}","https://github.com/nodejs/node/issues/55500",5,"Ambos",NULL,5,"experimentalwarning suporte carregar es module require experimental feature might change time error err internal assertion babel require module import again must evaluate cause bug nodejs incorrect usage nodejs internals please open issue stack trace github nodejs node issue process user document dev github com babel babel package babel core test fixture async plugin mjs tla native plugin js assert node internal assert modulejobsync run node internal modules esm module job onimport tracepromise proto node internal modules esm loader loadmjsfrompath file user document dev github com babel babel package babel core lib config files module type js code err internal assertion
","O título da issue (""ERR_INTERNAL_ASSERTION with require(esm)"") indica um problema técnico que pode exigir refatoração de código para corrigir a incompatibilidade entre `require` e módulos ESM.  Os comentários sugerem tentativas de reprodução e depuração do problema, o que é compatível com testes de regressão para garantir que a correção não introduza novos erros. A menção a `babel` e a presença de um *stack trace* apontam para a necessidade de revisão e ajuste no código (refatoração), enquanto a busca por uma reprodução mínima e a menção de 'test fixture' sugerem esforços para testes de regressão."
104,55391,"2024-10-15 07:39:32","2024-10-17 13:18:29","2024-10-17 13:18:29","`order: ipv4first` doesn't seem to have effect in dns.lookup?","### Version

22.7.0

### Platform

```text
Darwin 23.6.0 Darwin Kernel Version 23.6.0: Mon Jul 29 21:14:21 PDT 2024; root:xnu-10063.141.2~1/RELEASE_ARM64_T8103 arm64
```


### Subsystem

dns

### What steps will reproduce the bug?

Run:
```js
import dns from ""node:dns"";
dns.lookup(""localhost"", { all: true, order: ""ipv4first"" }, console.log);
```

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

The script prints:
```
null [ { address: '127.0.0.1', family: 4 }, { address: '::1', family: 6 } ]
```

### What do you see instead?

The script prints:
```
null [ { address: '::1', family: 6 }, { address: '127.0.0.1', family: 4 } ]
```

### Additional information

The issue doesn't happen with `dns.promises.lookup`. The below script prints ipv4 address first:

```js
import dns from ""node:dns"";
console.log(await dns.promises.lookup(""localhost"", { all:true, order: ""ipv4first"" }));
```","closed","kt3k",613956,"{confirmed-bug,dns}","https://github.com/nodejs/node/issues/55391",1,"Nenhum",NULL,2,"ipv4 ipv6 ordem retorno diferente expect script imprimir endereço ipv4 primeiro script imprimir endereço ipv6 primeiro problema acontecer dns promises lookup script imprimir endereço ipv4 primeiro
","A issue descreve um problema com a ordem de retorno de endereços IPv4 e IPv6 em `dns.lookup`,  mostrando um comportamento inesperado.  Não há menção explícita à refatoração de código ou à execução de testes de regressão. O comentário 'obvious bug' indica um bug, mas não relaciona-o diretamente com refatoração ou testes."
105,55351,"2024-10-10 14:43:52","2024-10-16 16:47:38","2024-10-16 16:47:38","AbortSignal.any() leaks when any of the provided signal is long-lived","### Version

v22.9.0

### Platform

```text
Microsoft Windows NT 10.0.22631.0 x64
```


### Subsystem

_No response_

### What steps will reproduce the bug?

```js
const ac = new AbortController();

let i = 0;
function run() {
    AbortSignal.any([ac.signal]);
    if (++i % 100_000 === 0) {
        const mem = process.memoryUsage().rss / 1024 / 1024;
        const kDependantSignals = Object.getOwnPropertySymbols(ac.signal).filter(
            (s) => s.toString() === 'Symbol(kDependantSignals)'
        )[0];
        const signals = ac.signal[kDependantSignals];
        console.log(`${i} - ${mem.toFixed(2)} MiB - ${signals?.size} signals`);
    }
    setImmediate(run);
}
run();
```

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

AbortSignal.any should not case memory leaks

### What do you see instead?

```
❯ node ..\test.js
node .\test.js
100000 - 82.29 MiB - 100000 signals
200000 - 97.98 MiB - 200000 signals
300000 - 126.98 MiB - 300000 signals
400000 - 131.91 MiB - 400000 signals
500000 - 152.07 MiB - 500000 signals
600000 - 162.52 MiB - 600000 signals
700000 - 208.69 MiB - 700000 signals
800000 - 219.15 MiB - 800000 signals
900000 - 221.80 MiB - 900000 signals
1000000 - 244.98 MiB - 1000000 signals
1100000 - 285.09 MiB - 1100000 signals
1200000 - 265.71 MiB - 1200000 signals
1300000 - 265.71 MiB - 1300000 signals
1400000 - 311.45 MiB - 1400000 signals
1500000 - 378.47 MiB - 1500000 signals
1600000 - 377.95 MiB - 1600000 signals
1700000 - 378.01 MiB - 1700000 signals
1800000 - 378.65 MiB - 1800000 signals
1900000 - 406.42 MiB - 1900000 signals
2000000 - 423.68 MiB - 2000000 signals
2100000 - 503.71 MiB - 2100000 signals
2200000 - 503.72 MiB - 2200000 signals
2300000 - 464.14 MiB - 2300000 signals
2400000 - 464.20 MiB - 2400000 signals
2500000 - 464.20 MiB - 2500000 signals
2600000 - 464.20 MiB - 2600000 signals
2700000 - 481.40 MiB - 2700000 signals
2800000 - 548.31 MiB - 2800000 signals
2900000 - 611.93 MiB - 2900000 signals
3000000 - 678.66 MiB - 3000000 signals
3100000 - 685.27 MiB - 3100000 signals
3200000 - 685.36 MiB - 3200000 signals
3300000 - 685.36 MiB - 3300000 signals
3400000 - 685.36 MiB - 3400000 signals
3500000 - 685.36 MiB - 3500000 signals
3600000 - 686.01 MiB - 3600000 signals
3700000 - 686.08 MiB - 3700000 signals
3800000 - 748.08 MiB - 3800000 signals
3900000 - 775.59 MiB - 3900000 signals
...
```

### Additional information

It's pretty clear that `AbortSignal.any` attaches the combined signal to all its parent signals. But it only gets removed if the parent signals are actually aborted. If there is a long living signal among the parents, for instance something like a SIGINT handler, then it keeps accumulating WeakRefs to no longer existing `AbortSignal`s.

Related issues:
- Related deno issue: https://github.com/denoland/deno/issues/24842
- Partly related issue: https://github.com/nodejs/node/issues/48419
  - Particularly case 3 of https://github.com/nodejs/node/issues/48419#issuecomment-2215484061
- Different issue: https://github.com/nodejs/node/issues/55328
  - Another leak when not properly removing listeners from `AbortSignal` returned by `AbortSignal.any`
- Probably not an issue at all: https://github.com/nodejs/node/issues/54614","closed","mika-fischer",426158,"{confirmed-bug,abortcontroller}","https://github.com/nodejs/node/issues/55351",8,"Ambos",NULL,6,"abortsignal any case memory leak memory usage increase abortsignal any attach combined signal parent signal remove parent signal abort long living signal sigint handler accumulate weakref exist abortsignal
","O título da issue sugere um problema de vazamento de memória ('AbortSignal.any() leaks'), indicando a necessidade de refatoração para corrigir o código causador do vazamento.  Os comentários, por sua vez, discutem testes de reprodução ('repro change node test mib signal...'),  indicando a realização ou necessidade de testes de regressão para verificar a correção do problema após a refatoração. A combinação de ambos os aspectos justifica a classificação 'Ambos'."
106,55310,"2024-10-08 01:29:55","2024-11-05 23:45:06","2024-11-05 23:45:07","Odd assertion error message when deep equality failed due to `Error.cause`","### Version

v20.18.0

### Platform

```text
Linux myhostname 6.10.10-arch1-1 #1 SMP PREEMPT_DYNAMIC Thu, 12 Sep 2024 17:21:02 +0000 x86_64 GNU/Linux
```


### Subsystem

_No response_

### What steps will reproduce the bug?

```ts
assert.deepStrictEqual(new Error(""a"", { cause: new Error(""x"") }), new Error(""a"", { cause: new Error(""y"") }))

Uncaught:
AssertionError [ERR_ASSERTION]: Values have same structure but are not reference-equal:

[Error: a]

    at REPL3:1:8
    at ContextifyScript.runInThisContext (node:vm:137:12)
    at REPLServer.defaultEval (node:repl:598:22)
    at bound (node:domain:432:15)
    at REPLServer.runBound [as eval] (node:domain:443:12)
    at REPLServer.onLine (node:repl:927:10)
    at REPLServer.emit (node:events:531:35)
    at REPLServer.emit (node:domain:488:12)
    at [_onLine] [as _onLine] (node:internal/readline/interface:417:12)
    at [_line] [as _line] (node:internal/readline/interface:888:18) {
  generatedMessage: true,
  code: 'ERR_ASSERTION',
  actual: [Error: a],
  expected: [Error: a],
  operator: 'deepStrictEqual'
}
```

### How often does it reproduce? Is there a required condition?

always

### What is the expected behavior? Why is that the expected behavior?

I'm not sure what exactly ""reference-equal"" means, but it sounds like it's about object identity and that might be misleading/bug.
Also ideally it would be nice if assertion diff  can show the diff coming from `Error.cause`.

### What do you see instead?

Assertion error doesn't indicate the error is due to non-matching `Error.cause`:

```
Uncaught:
AssertionError [ERR_ASSERTION]: Values have same structure but are not reference-equal:

[Error: a]
```

### Additional information

I saw Node has expanded on `Error` instance deep equality check https://github.com/nodejs/node/pull/51805 and was testing it around. Vitest is trying to catch up in https://github.com/vitest-dev/vitest/pull/5876 and I thought it would be a good reference to know how Node would handle this.","closed","hi-ogawa",4232207,"{confirmed-bug,assert,errors}","https://github.com/nodejs/node/issues/55310",3,"Ambos",NULL,29,"assert deepStrictEqual new error cause new error assertion error value structure reference equal error  repl contextifyscript runinthiscontext replserver defaulteval bound replserver runbound replserver online replserver emit replserver emit online line generatedmessage code err assertion actual error expected error operator deepStrictEqual node expand error instance deep equality check vitest try catch node handle
","O título da issue indica um problema com uma mensagem de erro em testes de igualdade profunda (`deepStrictEqual`). O corpo e os comentários discutem a falha da asserção,  sugerindo a necessidade de refatoração no código de comparação de erros para corrigir a mensagem de erro e melhorar a precisão dos testes de igualdade.  A menção a `vitest` e `assert` indica o uso de um framework de testes, reforçando a presença de ambos os aspectos."
107,55139,"2024-09-27 08:14:54","2024-09-29 09:51:11","2024-09-29 09:51:11","Assertion failed: `args[1]->IsUint32()` when slicing Blob with non-integer parameters","### Version

20.17.0

### Platform

```text
Darwin x.home 24.0.0 Darwin Kernel Version 24.0.0: Mon Aug 12 20:52:18 PDT 2024; root:xnu-11215.1.10~2/RELEASE_ARM64_T8122 arm64
```


### Subsystem

Buffer/Blob

### What steps will reproduce the bug?

```js
new Blob(['aaaaaaaa']).slice(0, 1.5)
```

### How often does it reproduce? Is there a required condition?

Always, no special requirements needed.

### What is the expected behavior? Why is that the expected behavior?

I would not expect Node to crash with a native error, as this is not possible/easy to catch.

### What do you see instead?

```
$ node -e ""new Blob(['aaaaaaaa']).slice(0, 1.5)""

  #  node[76610]: static void node::Blob::ToSlice(const FunctionCallbackInfo<v8::Value> &) at ../src/node_blob.cc:248
  #  Assertion failed: args[1]->IsUint32()

----- Native stack trace -----

 1: 0x1043430d4 node::Assert(node::AssertionInfo const&) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
 2: 0x10584e098 node::Blob::ToSlice(v8::FunctionCallbackInfo<v8::Value> const&) (.cold.1) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
 3: 0x104314e08 node::Blob::HasInstance(node::Environment*, v8::Local<v8::Value>) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
 4: 0x104539bc8 v8::internal::MaybeHandle<v8::internal::Object> v8::internal::(anonymous namespace)::HandleApiCallHelper<false>(v8::internal::Isolate*, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::FunctionTemplateInfo>, v8::internal::Handle<v8::internal::Object>, unsigned long*, int) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
 5: 0x1045392c0 v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
 6: 0x104dc0b24 Builtins_CEntry_Return1_ArgvOnStack_BuiltinExit [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
 7: 0x104d383e4 Builtins_InterpreterEntryTrampoline [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
 8: 0x104d383e4 Builtins_InterpreterEntryTrampoline [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
 9: 0x104d3650c Builtins_JSEntryTrampoline [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
10: 0x104d361f4 Builtins_JSEntry [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
11: 0x10460dbc8 v8::internal::(anonymous namespace)::Invoke(v8::internal::Isolate*, v8::internal::(anonymous namespace)::InvokeParams const&) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
12: 0x10460dda0 v8::internal::Execution::CallScript(v8::internal::Isolate*, v8::internal::Handle<v8::internal::JSFunction>, v8::internal::Handle<v8::internal::Object>, v8::internal::Handle<v8::internal::Object>) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
13: 0x1044d3bb0 v8::Script::Run(v8::Local<v8::Context>, v8::Local<v8::Data>) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
14: 0x1043364f4 node::contextify::ContextifyScript::EvalMachine(v8::Local<v8::Context>, node::Environment*, long long, bool, bool, bool, v8::MicrotaskQueue*, v8::FunctionCallbackInfo<v8::Value> const&) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
15: 0x104335e08 node::contextify::ContextifyScript::RunInContext(v8::FunctionCallbackInfo<v8::Value> const&) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
16: 0x104539bc8 v8::internal::MaybeHandle<v8::internal::Object> v8::internal::(anonymous namespace)::HandleApiCallHelper<false>(v8::internal::Isolate*, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::FunctionTemplateInfo>, v8::internal::Handle<v8::internal::Object>, unsigned long*, int) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
17: 0x1045392c0 v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
18: 0x104dc0b24 Builtins_CEntry_Return1_ArgvOnStack_BuiltinExit [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
19: 0x104d383e4 Builtins_InterpreterEntryTrampoline [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
20: 0x104d383e4 Builtins_InterpreterEntryTrampoline [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
21: 0x104d383e4 Builtins_InterpreterEntryTrampoline [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
22: 0x104d383e4 Builtins_InterpreterEntryTrampoline [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
23: 0x104d383e4 Builtins_InterpreterEntryTrampoline [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
24: 0x104d383e4 Builtins_InterpreterEntryTrampoline [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
25: 0x104d3650c Builtins_JSEntryTrampoline [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
26: 0x104d361f4 Builtins_JSEntry [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
27: 0x10460dbc8 v8::internal::(anonymous namespace)::Invoke(v8::internal::Isolate*, v8::internal::(anonymous namespace)::InvokeParams const&) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
28: 0x10460d014 v8::internal::Execution::Call(v8::internal::Isolate*, v8::internal::Handle<v8::internal::Object>, v8::internal::Handle<v8::internal::Object>, int, v8::internal::Handle<v8::internal::Object>*) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
29: 0x1044e7904 v8::Function::Call(v8::Local<v8::Context>, v8::Local<v8::Value>, int, v8::Local<v8::Value>*) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
30: 0x1043243e4 node::builtins::BuiltinLoader::CompileAndCall(v8::Local<v8::Context>, char const*, node::Realm*) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
31: 0x1043b414c node::Realm::ExecuteBootstrapper(char const*) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
32: 0x104307bb4 node::StartExecution(node::Environment*, std::__1::function<v8::MaybeLocal<v8::Value> (node::StartExecutionCallbackInfo const&)>) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
33: 0x1042713a4 node::LoadEnvironment(node::Environment*, std::__1::function<v8::MaybeLocal<v8::Value> (node::StartExecutionCallbackInfo const&)>, std::__1::function<void (node::Environment*, v8::Local<v8::Value>, v8::Local<v8::Value>)>) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
34: 0x104383394 node::NodeMainInstance::Run(node::ExitCode*, node::Environment*) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
35: 0x104383104 node::NodeMainInstance::Run() [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
36: 0x10430afa0 node::Start(int, char**) [/Users/neo/.nvm/versions/node/v20.17.0/bin/node]
37: 0x183130274 start [/usr/lib/dyld]

----- JavaScript stack trace -----

1: slice (node:internal/blob:265:21)
2: [eval]:1:24
3: runScriptInThisContext (node:internal/vm:209:10)
4: node:internal/process/execution:118:14
5: [eval]-wrapper:6:24
6: runScript (node:internal/process/execution:101:62)
7: evalScript (node:internal/process/execution:133:3)
8: node:internal/main/eval_string:51:3


Abort trap: 6
```

### Additional information

The functionality of Node v20 seems to have changed as of v20.15.0. v20.14.0 does not crash with this repro.

I have tested with v22.9.0 and it experiences the same crash.

v18.20.4 does not crash.","closed","daniellockyer",964245,"{confirmed-bug,buffer}","https://github.com/nodejs/node/issues/55139",0,"Ambos",NULL,2,"node crash assertion failed argument isuint argument isuint32 blob slice functionality node version change version version crash repro test version crash version crash
","O título da issue indica um problema de asserção falha (`Assertion failed`), sugerindo um defeito no código que precisa de refatoração.  A presença de termos como ""test"", ""repro"", ""version"" e a menção a um ""crash"" no corpo da issue indicam a necessidade de testes de regressão para garantir que a correção não introduza novos problemas ou que o problema não ocorra em outras versões ou cenários. A combinação de refatoração (para corrigir a asserção) e testes de regressão (para validar a correção) justifica a classificação 'Ambos'."
108,55328,"2024-09-26 14:26:28","2024-12-08 12:24:11","2024-12-08 12:24:11","AbortController/AbortSignal memory leak","## Bug Description

The memory of the Node process grows infinitely, ultimately resulting in an OOM error. Memory profiling revealed a memory leak related to AbortController.
Similar to nodejs/node#54614,but the difference is that if AbortSignal.any does not have an event listener added, AbortSignal.any will eventually be released and there will be no memory leak.

~~I am using fetch API with AbortController/AbortSignal in Node.js(not undici directly).~~
Sorry, I misremembered, I was using node:http+signal.


<!-- A clear and concise description of what the bug is. -->

## Reproducible By


<!-- A step by step list on how the bug can be reproduced for examination. -->
```js
const formatMemoryUsage = (data) =>
  `${Math.round((data / 1024 / 1024) * 100) / 100} MB`;
// let i = 0;
// const registry = new FinalizationRegistry((heldValue) => {
//   i += 1;
//   // console.debug(""[registry]"", heldValue);
// });
let memoryData = process.memoryUsage();
console.log(""Mem before loop"", formatMemoryUsage(memoryData.rss));

const run = () => {
  for (let i = 0; i < 100_000; i++) {
    const abortController = new AbortController();

    const signal = abortController.signal;

    const composedSignal = AbortSignal.any([signal]);
    composedSignal.addEventListener(""abort"", () => {
      // It looks like the closure reference in the callback function causes the signal to not be released?
      // console.log(signal); // Uncommenting this will aggravate the memory leak
    });

    // registry.register(signal, ""signal"");
  }
};
setImmediate(run);
setInterval(() => {
  if (typeof global.gc == ""function"") {
    global.gc(true);
  } else {
    console.warn(""global.gc unavailable, need '--expose-gc' flag"");
  }
  const memoryData = process.memoryUsage();
  console.log(""Mem after 100K iteration"", formatMemoryUsage(memoryData.rss));
  // console.log(i, ""signals released"");
}, 1000);

```

```sh
/app # node --trace-gc --expose-gc  test3.js
Mem before loop 43.78 MB
[380:0x7f3bd3df6000]       44 ms: Scavenge 3.9 (5.2) -> 3.5 (6.2) MB, pooled: 0 MB, 0.74 / 0.00 ms  (average mu = 1.000, current mu = 1.000) allocation failure;
[380:0x7f3bd3df6000]       45 ms: Scavenge 3.9 (6.2) -> 3.8 (6.7) MB, pooled: 0 MB, 0.62 / 0.00 ms  (average mu = 1.000, current mu = 1.000) allocation failure;
[380:0x7f3bd3df6000]       47 ms: Scavenge 4.5 (6.7) -> 4.3 (9.2) MB, pooled: 0 MB, 0.74 / 0.00 ms  (average mu = 1.000, current mu = 1.000) allocation failure;
[380:0x7f3bd3df6000]       50 ms: Scavenge 5.9 (9.2) -> 5.4 (9.7) MB, pooled: 0 MB, 0.99 / 0.00 ms  (average mu = 1.000, current mu = 1.000) allocation failure;
[380:0x7f3bd3df6000]       53 ms: Scavenge 6.3 (9.7) -> 6.0 (14.7) MB, pooled: 0 MB, 1.20 / 0.00 ms  (average mu = 1.000, current mu = 1.000) allocation failure;
[380:0x7f3bd3df6000]       57 ms: Scavenge 9.5 (14.8) -> 8.4 (15.6) MB, pooled: 0 MB, 1.41 / 0.00 ms  (average mu = 1.000, current mu = 1.000) allocation failure; 
[380:0x7f3bd3df6000]       65 ms: Scavenge 10.6 (16.1) -> 10.0 (26.1) MB, pooled: 0 MB, 3.05 / 0.00 ms  (average mu = 1.000, current mu = 1.000) allocation failure;
[380:0x7f3bd3df6000]       80 ms: Scavenge 16.8 (26.1) -> 15.2 (27.6) MB, pooled: 0 MB, 2.62 / 0.00 ms  (average mu = 1.000, current mu = 1.000) allocation failure; 
[380:0x7f3bd3df6000]       88 ms: Scavenge 18.9 (28.5) -> 18.3 (49.8) MB, pooled: 0 MB, 3.92 / 0.00 ms  (average mu = 1.000, current mu = 1.000) allocation failure; 
[380:0x7f3bd3df6000]      104 ms: Scavenge 33.7 (51.7) -> 31.0 (53.7) MB, pooled: 0 MB, 4.48 / 0.00 ms  (average mu = 1.000, current mu = 1.000) allocation failure; 
[380:0x7f3bd3df6000]      115 ms: Scavenge 35.8 (53.7) -> 34.8 (64.9) MB, pooled: 0 MB, 7.48 / 0.00 ms  (average mu = 1.000, current mu = 1.000) allocation failure; 
[380:0x7f3bd3df6000]      127 ms: Mark-Compact 41.7 (64.9) -> 38.2 (73.8) MB, pooled: 0 MB, 2.82 / 0.00 ms  (+ 0.4 ms in 0 steps since start of marking, biggest step 0.0 ms, walltime since start of marking 12 ms) (average mu = 0.977, current mu = 0.977) finalize incremental marking via stack guard; GC in old space requested
[380:0x7f3bd3df6000]      148 ms: Scavenge 57.7 (77.6) -> 54.6 (77.6) MB, pooled: 0 MB, 4.69 / 0.00 ms  (average mu = 0.977, current mu = 0.977) allocation failure; 
[380:0x7f3bd3df6000]      159 ms: Scavenge 57.7 (77.6) -> 57.1 (89.6) MB, pooled: 0 MB, 7.86 / 0.00 ms  (average mu = 0.977, current mu = 0.977) allocation failure;
[380:0x7f3bd3df6000]      172 ms: Scavenge 70.3 (89.6) -> 67.6 (91.6) MB, pooled: 0 MB, 3.94 / 0.00 ms  (average mu = 0.977, current mu = 0.977) allocation failure; 
[380:0x7f3bd3df6000]      182 ms: Scavenge 72.7 (91.6) -> 71.6 (102.1) MB, pooled: 0 MB, 5.92 / 0.00 ms  (average mu = 0.977, current mu = 0.977) allocation failure; 
[380:0x7f3bd3df6000]      194 ms: Scavenge 83.2 (102.1) -> 80.9 (106.3) MB, pooled: 0 MB, 4.03 / 0.00 ms  (average mu = 0.977, current mu = 0.977) allocation failure; 
[380:0x7f3bd3df6000]      204 ms: Scavenge 87.3 (106.3) -> 86.0 (115.6) MB, pooled: 0 MB, 4.54 / 0.00 ms  (average mu = 0.977, current mu = 0.977) allocation failure;
[380:0x7f3bd3df6000]      216 ms: Scavenge 96.5 (115.6) -> 94.4 (120.8) MB, pooled: 0 MB, 4.04 / 0.00 ms  (average mu = 0.977, current mu = 0.977) allocation failure; 
[380:0x7f3bd3df6000]      235 ms: Scavenge 109.2 (128.3) -> 107.7 (137.1) MB, pooled: 0 MB, 5.21 / 0.00 ms  (average mu = 0.977, current mu = 0.977) allocation failure; 
[380:0x7f3bd3df6000]      255 ms: Scavenge (interleaved) 117.6 (137.1) -> 115.6 (143.3) MB, pooled: 0 MB, 6.53 / 0.00 ms  (average mu = 0.977, current mu = 0.977) allocation failure; 
[380:0x7f3bd3df6000]      273 ms: Scavenge (interleaved) 123.4 (143.3) -> 121.8 (151.6) MB, pooled: 0 MB, 7.72 / 0.00 ms  (average mu = 0.977, current mu = 0.977) allocation failure; 
[380:0x7f3bd3df6000]      279 ms: Mark-Compact 123.1 (151.6) -> 117.2 (152.7) MB, pooled: 0 MB, 3.91 / 0.00 ms  (+ 0.7 ms in 0 steps since start of marking, biggest step 0.0 ms, walltime since start of marking 44 ms) (average mu = 0.975, current mu = 0.973) finalize incremental marking via stack guard; GC in old space requested
[380:0x7f3bd3df6000]      296 ms: Scavenge 132.9 (152.7) -> 129.8 (152.7) MB, pooled: 0 MB, 4.28 / 0.00 ms  (average mu = 0.975, current mu = 0.973) allocation failure; 
[380:0x7f3bd3df6000]      308 ms: Scavenge 132.9 (152.7) -> 132.2 (165.4) MB, pooled: 0 MB, 7.98 / 0.00 ms  (average mu = 0.975, current mu = 0.973) allocation failure; 
[380:0x7f3bd3df6000]      322 ms: Scavenge 145.4 (165.4) -> 142.8 (167.9) MB, pooled: 0 MB, 4.07 / 0.00 ms  (average mu = 0.975, current mu = 0.973) allocation failure; 
[380:0x7f3bd3df6000]      333 ms: Scavenge 147.9 (167.9) -> 146.9 (178.7) MB, pooled: 0 MB, 6.16 / 0.00 ms  (average mu = 0.975, current mu = 0.973) allocation failure; 
[380:0x7f3bd3df6000]     1047 ms: Scavenge 149.1 (178.7) -> 148.6 (182.7) MB, pooled: 0 MB, 6.11 / 0.00 ms  (average mu = 0.975, current mu = 0.973) testing; 
Mem after 100K iteration 232.23 MB
[380:0x7f3bd3df6000]     2046 ms: Scavenge 148.7 (182.7) -> 148.6 (184.7) MB, pooled: 0 MB, 3.56 / 0.00 ms  (average mu = 0.975, current mu = 0.973) testing; 
Mem after 100K iteration 234.25 MB
[380:0x7f3bd3df6000]     3043 ms: Scavenge 148.6 (184.7) -> 148.6 (184.7) MB, pooled: 0 MB, 0.95 / 0.00 ms  (average mu = 0.975, current mu = 0.973) testing; 
Mem after 100K iteration 234.24 MB
[380:0x7f3bd3df6000]     4045 ms: Scavenge 148.6 (184.7) -> 148.6 (184.7) MB, pooled: 0 MB, 0.76 / 0.00 ms  (average mu = 0.975, current mu = 0.973) testing; 
Mem after 100K iteration 234.25 MB
[380:0x7f3bd3df6000]     5047 ms: Scavenge 148.6 (184.7) -> 148.6 (184.7) MB, pooled: 0 MB, 1.83 / 0.00 ms  (average mu = 0.975, current mu = 0.973) testing; 
Mem after 100K iteration 234.31 MB
[380:0x7f3bd3df6000]     6047 ms: Scavenge 148.6 (184.7) -> 148.7 (184.7) MB, pooled: 0 MB, 1.13 / 0.00 ms  (average mu = 0.975, current mu = 0.973) testing; 
Mem after 100K iteration 234.3 MB
[380:0x7f3bd3df6000]     7047 ms: Scavenge 148.7 (184.7) -> 148.6 (184.7) MB, pooled: 0 MB, 0.78 / 0.00 ms  (average mu = 0.975, current mu = 0.973) testing; 
Mem after 100K iteration 234.29 MB
[380:0x7f3bd3df6000]     8050 ms: Scavenge 148.7 (184.7) -> 148.7 (153.7) MB, pooled: 31 MB, 1.55 / 0.00 ms  (average mu = 0.975, current mu = 0.973) testing; 
Mem after 100K iteration 234.29 MB
[380:0x7f3bd3df6000]     8463 ms: Mark-Compact (reduce) 148.9 (153.7) -> 82.7 (143.4) MB, pooled: 0 MB, 10.03 / 0.00 ms  (+ 14.2 ms in 0 steps since start of marking, biggest step 0.0 ms, walltime since start of marking 27 ms) (average mu = 0.997, current mu = 0.997) finalize incremental marking via task; GC in old space requested
[380:0x7f3bd3df6000]     9051 ms: Scavenge 82.7 (143.4) -> 82.7 (144.4) MB, pooled: 0 MB, 1.57 / 0.00 ms  (average mu = 0.997, current mu = 0.997) testing; 
Mem after 100K iteration 148.13 MB
[380:0x7f3bd3df6000]     9094 ms: Mark-Compact (reduce) 82.7 (144.4) -> 82.7 (101.4) MB, pooled: 0 MB, 9.94 / 0.00 ms  (+ 16.9 ms in 0 steps since start of marking, biggest step 0.0 ms, walltime since start of marking 30 ms) (average mu = 0.992, current mu = 0.958) finalize incremental marking via task; GC in old space requested
[380:0x7f3bd3df6000]    10051 ms: Scavenge 82.7 (101.4) -> 82.7 (101.4) MB, pooled: 1 MB, 1.02 / 0.00 ms  (average mu = 0.992, current mu = 0.958) testing; 
Mem after 100K iteration 141.08 MB
[380:0x7f3bd3df6000]    11051 ms: Scavenge 82.7 (101.4) -> 82.7 (101.4) MB, pooled: 1 MB, 0.37 / 0.00 ms  (average mu = 0.992, current mu = 0.958) testing; 
Mem after 100K iteration 141.08 MB
[380:0x7f3bd3df6000]    12052 ms: Scavenge 82.7 (101.4) -> 82.7 (101.4) MB, pooled: 1 MB, 0.42 / 0.00 ms  (average mu = 0.992, current mu = 0.958) testing; 
Mem after 100K iteration 141.09 MB
[380:0x7f3bd3df6000]    13053 ms: Scavenge 82.7 (101.4) -> 82.7 (101.4) MB, pooled: 1 MB, 0.84 / 0.00 ms  (average mu = 0.992, current mu = 0.958) testing; 
Mem after 100K iteration 141.09 MB
[380:0x7f3bd3df6000]    14054 ms: Scavenge 82.7 (101.4) -> 82.7 (101.4) MB, pooled: 1 MB, 0.42 / 0.00 ms  (average mu = 0.992, current mu = 0.958) testing; 
Mem after 100K iteration 141.09 MB
[380:0x7f3bd3df6000]    15056 ms: Scavenge 82.7 (101.4) -> 82.7 (101.4) MB, pooled: 1 MB, 0.74 / 0.00 ms  (average mu = 0.992, current mu = 0.958) testing; 
Mem after 100K iteration 141.09 MB
[380:0x7f3bd3df6000]    16057 ms: Scavenge 82.7 (101.4) -> 82.7 (101.4) MB, pooled: 1 MB, 0.76 / 0.00 ms  (average mu = 0.992, current mu = 0.958) testing; 
Mem after 100K iteration 141.09 MB
[380:0x7f3bd3df6000]    17059 ms: Scavenge 82.7 (101.4) -> 82.7 (101.4) MB, pooled: 1 MB, 0.63 / 0.00 ms  (average mu = 0.992, current mu = 0.958) testing; 
Mem after 100K iteration 141.09 MB
[380:0x7f3bd3df6000]    18060 ms: Scavenge 82.7 (101.4) -> 82.7 (101.4) MB, pooled: 1 MB, 0.59 / 0.00 ms  (average mu = 0.992, current mu = 0.958) testing; 
Mem after 100K iteration 141.09 MB
[380:0x7f3bd3df6000]    19061 ms: Scavenge 82.7 (101.4) -> 82.7 (101.4) MB, pooled: 1 MB, 0.41 / 0.00 ms  (average mu = 0.992, current mu = 0.958) testing; 
Mem after 100K iteration 141.09 MB
[380:0x7f3bd3df6000]    20062 ms: Scavenge 82.7 (101.4) -> 82.7 (101.4) MB, pooled: 1 MB, 0.64 / 0.00 ms  (average mu = 0.992, current mu = 0.958) testing; 
Mem after 100K iteration 141.09 MB
[380:0x7f3bd3df6000]    21063 ms: Scavenge 82.7 (101.4) -> 82.7 (101.4) MB, pooled: 1 MB, 0.81 / 0.00 ms  (average mu = 0.992, current mu = 0.958) testing; 
Mem after 100K iteration 141.09 MB
[380:0x7f3bd3df6000]    22063 ms: Scavenge 82.7 (101.4) -> 82.7 (101.4) MB, pooled: 1 MB, 0.43 / 0.00 ms  (average mu = 0.992, current mu = 0.958) testing; 
Mem after 100K iteration 141.09 MB
/app #
```

## Expected Behavior

All AbortController/AbortSignal should be destroyed.
<!-- A clear and concise description of what you expected to happen. -->

## Logs & Screenshots

![image](https://github.com/user-attachments/assets/c40775b7-f87b-44af-873b-c54e14fb3dc5)
![image](https://github.com/user-attachments/assets/0c95a888-249f-4309-b9e8-f932a9d5de79)

<!-- If applicable, add screenshots to help explain your problem, or 
alternatively add your console logs here. -->

## Environment

Node: v22.3.0
Docker Image: node:apline

### Additional context

<!-- Add any other context about the problem here. -->
","closed","System233",20336040,"{confirmed-bug}","https://github.com/nodejs/node/issues/55328",18,"Ambos",NULL,73,"memory node process grow infinitely ultimately result oom error memory profiling reveal memory leak relate abortcontroller similar nodejs node difference abortsignal any event listener add abortsignal any eventually release memory leak use fetch api abortcontroller abortsignal nodejs undici directly misremember use node http signal clear concise description bug step step list bug reproduce examination formatmemoryusage data round data 1024 1024 100 100 mb let i 0 registry new finalizationregistry heldvalue i 1 console debug registry heldvalue registry register signal signal memorydata process memoryusage console log mem loop formatmemoryusage memorydata rss run 100 000 abortcontroller new abortcontroller signal abortcontroller signal composedsignal abortsignal any signal composedsignal addeventlistener abort console log signal uncomment aggravate memory leak registry register signal signal set immediaterun setinterval typeof global gc function global gc true console warn global gc unavailable need expose gc flag memorydata process memoryusage console log mem 100k iteration formatmemoryusage memorydata rss 1000 node trace gc expose gc test3 mem loop 43.78 mb 380 0x7f3bd3df6000 44 ms scavenge 3.9 5.2 3.5 6.2 mb pooled 0 mb 0.74 0.00 ms average mu 1.000 current mu 1.000 allocation failure 380 0x7f3bd3df6000 45 ms scavenge 3.9 6.2 3.8 6.7 mb pooled 0 mb 0.62 0.00 ms average mu 1.000 current mu 1.000 allocation failure 380 0x7f3bd3df6000 47 ms scavenge 4.5 6.7 4.3 9.2 mb pooled 0 mb 0.74 0.00 ms average mu 1.000 current mu 1.000 allocation failure 380 0x7f3bd3df6000 50 ms scavenge 5.9 9.2 5.4 9.7 mb pooled 0 mb 0.99 0.00 ms average mu 1.000 current mu 1.000 allocation failure 380 0x7f3bd3df6000 53 ms scavenge 6.3 9.7 6.0 14.7 mb pooled 0 mb 1.20 0.00 ms average mu 1.000 current mu 1.000 allocation failure 380 0x7f3bd3df6000 57 ms scavenge 9.5 14.8 8.4 15.6 mb pooled 0 mb 1.41 0.00 ms average mu 1.000 current mu 1.000 allocation failure 380 0x7f3bd3df6000 65 ms scavenge 10.6 16.1 10.0 26.1 mb pooled 0 mb 3.05 0.00 ms average mu 1.000 current mu 1.000 allocation failure 380 0x7f3bd3df6000 80 ms scavenge 16.8 26.1 15.2 27.6 mb pooled 0 mb 2.62 0.00 ms average mu 1.000 current mu 1.000 allocation failure 380 0x7f3bd3df6000 88 ms scavenge 18.9 28.5 18.3 49.8 mb pooled 0 mb 3.92 0.00 ms average mu 1.000 current mu 1.000 allocation failure 380 0x7f3bd3df6000 104 ms scavenge 33.7 51.7 31.0 53.7 mb pooled 0 mb 4.48 0.00 ms average mu 1.000 current mu 1.000 allocation failure 380 0x7f3bd3df6000 115 ms scavenge 35.8 53.7 34.8 64.9 mb pooled 0 mb 7.48 0.00 ms average mu 1.000 current mu 1.000 allocation failure 380 0x7f3bd3df6000 127 ms mark compact 41.7 64.9 38.2 73.8 mb pooled 0 mb 2.82 0.00 ms 0.4 ms 0 step since start marking biggest step 0.0 ms walltime since start marking 12 ms average mu 0.977 current mu 0.977 finalize incremental marking via stack guard gc old space requested 380 0x7f3bd3df6000 148 ms scavenge 57.7 77.6 54.6 77.6 mb pooled 0 mb 4.69 0.00 ms average mu 0.977 current mu 0.977 allocation failure 380 0x7f3bd3df6000 159 ms scavenge 57.7 77.6 57.1 89.6 mb pooled 0 mb 7.86 0.00 ms average mu 0.977 current mu 0.977 allocation failure 380 0x7f3bd3df6000 172 ms scavenge 70.3 89.6 67.6 91.6 mb pooled 0 mb 3.94 0.00 ms average mu 0.977 current mu 0.977 allocation failure 380 0x7f3bd3df6000 182 ms scavenge 72.7 91.6 71.6 102.1 mb pooled 0 mb 5.92 0.00 ms average mu 0.977 current mu 0.977 allocation failure 380 0x7f3bd3df6000 194 ms scavenge 83.2 102.1 80.9 106.3 mb pooled 0 mb 4.03 0.00 ms average mu 0.977 current mu 0.977 allocation failure 380 0x7f3bd3df6000 204 ms scavenge 87.3 106.3 86.0 115.6 mb pooled 0 mb 4.54 0.00 ms average mu 0.977 current mu 0.977 allocation failure 380 0x7f3bd3df6000 216 ms scavenge 96.5 115.6 94.4 120.8 mb pooled 0 mb 4.04 0.00 ms average mu 0.977 current mu 0.977 allocation failure 380 0x7f3bd3df6000 235 ms scavenge 109.2 128.3 107.7 137.1 mb pooled 0 mb 5.21 0.00 ms average mu 0.977 current mu 0.977 allocation failure 380 0x7f3bd3df6000 255 ms scavenge interleaved 117.6 137.1 115.6 143.3 mb pooled 0 mb 6.53 0.00 ms average mu 0.977 current mu 0.977 allocation failure 380 0x7f3bd3df6000 273 ms scavenge interleaved 123.4 143.3 121.8 151.6 mb pooled 0 mb 7.72 0.00 ms average mu 0.977 current mu 0.977 allocation failure 380 0x7f3bd3df6000 279 ms mark compact 123.1 151.6 117.2 152.7 mb pooled 0 mb 3.91 0.00 ms 0.7 ms 0 step since start marking biggest step 0.0 ms walltime since start marking 44 ms average mu 0.975 current mu 0.973 finalize incremental marking via stack guard gc old space requested 380 0x7f3bd3df6000 296 ms scavenge 132.9 152.7 129.8 152.7 mb pooled 0 mb 4.28 0.00 ms average mu 0.975 current mu 0.973 allocation failure 380 0x7f3bd3df6000 308 ms scavenge 132.9 152.7 132.2 165.4 mb pooled 0 mb 7.98 0.00 ms average mu 0.975 current mu 0.973 allocation failure 380 0x7f3bd3df6000 322 ms scavenge 145.4 165.4 142.8 167.9 mb pooled 0 mb 4.07 0.00 ms average mu 0.975 current mu 0.973 allocation failure 380 0x7f3bd3df6000 333 ms scavenge 147.9 167.9 146.9 178.7 mb pooled 0 mb 6.16 0.00 ms average mu 0.975 current mu 0.973 allocation failure 380 0x7f3bd3df6000 1047 ms scavenge 149.1 178.7 148.6 182.7 mb pooled 0 mb 6.11 0.00 ms average mu 0.975 current mu 0.973 testing mem 100k iteration 232.23 mb 380 0x7f3bd3df6000 2046 ms scavenge 148.7 182.7 148.6 184.7 mb pooled 0 mb 3.56 0.00 ms average mu 0.975 current mu 0.973 testing mem 100k iteration 234.25 mb 380 0x7f3bd3df6000 3043 ms scavenge 148.6 184.7 148.6 184.7 mb pooled 0 mb 0.95 0.00 ms average mu 0.975 current mu 0.973 testing mem 100k iteration 234.24 mb 380 0x7f3bd3df6000 4045 ms scavenge 148.6 184.7 148.6 184.7 mb pooled 0 mb 0.76 0.00 ms average mu 0.975 current mu 0.973 testing mem 100k iteration 234.25 mb 380 0x7f3bd3df6000 5047 ms scavenge 148.6 184.7 148.6 184.7 mb pooled 0 mb 1.83 0.00 ms average mu 0.975 current mu 0.973 testing mem 100k iteration 234.31 mb 380 0x7f3bd3df6000 6047 ms scavenge 148.6 184.7 148.7 184.7 mb pooled 0 mb 1.13 0.00 ms average mu 0.975 current mu 0.973 testing mem 100k iteration 234.3 mb 380 0x7f3bd3df6000 7047 ms scavenge 148.7 184.7 148.6 184.7 mb pooled 0 mb 0.78 0.00 ms average mu 0.975 current mu 0.973 testing mem 100k iteration 234.29 mb 380 0x7f3bd3df6000 8050 ms scavenge 148.7 184.7 148.7 153.7 mb pooled 31 mb 1.55 0.00 ms average mu 0.975 current mu 0.973 testing mem 100k iteration 234.29 mb 380 0x7f3bd3df6000 8463 ms mark compact reduce 148.9 153.7 82.7 143.4 mb pooled 0 mb 10.03 0.00 ms 14.2 ms 0 step since start marking biggest step 0.0 ms walltime since start marking 27 ms average mu 0.997 current mu 0.997 finalize incremental marking via task gc old space requested 380 0x7f3bd3df6000 9051 ms scavenge 82.7 143.4 82.7 144.4 mb pooled 0 mb 1.57 0.00 ms average mu 0.997 current mu 0.997 testing mem 100k iteration 148.13 mb 380 0x7f3bd3df6000 9094 ms mark compact reduce 82.7 144.4 82.7 101.4 mb pooled 0 mb 9.94 0.00 ms 16.9 ms 0 step since start marking biggest step 0.0 ms walltime since start marking 30 ms average mu 0.992 current mu 0.958 finalize incremental marking via task gc old space requested 380 0x7f3bd3df6000 10051 ms scavenge 82.7 101.4 82.7 101.4 mb pooled 1 mb 1.02 0.00 ms average mu 0.992 current mu 0.958 testing mem 100k iteration 141.08 mb 380 0x7f3bd3df6000 11051 ms scavenge 82.7 101.4 82.7 101.4 mb pooled 1 mb 0.37 0.00 ms average mu 0.992 current mu 0.958 testing mem 100k iteration 141.08 mb 380 0x7f3bd3df6000 12052 ms scavenge 82.7 101.4 82.7 101.4 mb pooled 1 mb 0.42 0.00 ms average mu 0.992 current mu 0.958 testing mem 100k iteration 141.09 mb 380 0x7f3bd3df6000 13053 ms scavenge 82.7 101.4 82.7 101.4 mb pooled 1 mb 0.84 0.00 ms average mu 0.992 current mu 0.958 testing mem 100k iteration 141.09 mb 380 0x7f3bd3df6000 14054 ms scavenge 82.7 101.4 82.7 101.4 mb pooled 1 mb 0.42 0.00 ms average mu 0.992 current mu 0.958 testing mem 100k iteration 141.09 mb 380 0x7f3bd3df6000 15056 ms scavenge 82.7 101.4 82.7 101.4 mb pooled 1 mb 0.74 0.00 ms average mu 0.992 current mu 0.958 testing mem 100k iteration 141.09 mb 380 0x7f3bd3df6000 16057 ms scavenge 82.7 101.4 82.7 101.4 mb pooled 1 mb 0.76 0.00 ms average mu 0.992 current mu 0.958 testing mem 100k iteration 141.09 mb 380 0x7f3bd3df6000 17059 ms scavenge 82.7 101.4 82.7 101.4 mb pooled 1 mb 0.63 0.00 ms average mu 0.992 current mu 0.958 testing mem 100k iteration 141.09 mb 380 0x7f3bd3df6000 18060 ms scavenge 82.7 101.4 82.7 101.4 mb pooled 1 mb 0.59 0.00 ms average mu 0.992 current mu 0.958 testing mem 100k iteration 141.09 mb 380 0x7f3bd3df6000 19061 ms scavenge 82.7 101.4 82.7 101.4 mb pooled 1 mb 0.41 0.00 ms average mu 0.992 current mu 0.958 testing mem 100k iteration 141.09 mb 380 0x7f3bd3df6000 20062 ms scavenge 82.7 101.4 82.7 101.4 mb pooled 1 mb 0.64 0.00 ms average mu 0.992 current mu 0.958 testing mem 100k iteration 141.09 mb 380 0x7f3bd3df6000 21063 ms scavenge 82.7 101.4 82.7 101.4 mb pooled 1 mb 0.81 0.00 ms average mu 0.992 current mu 0.958 testing mem 100k iteration 141.09 mb 380 0x7f3bd3df6000 22063 ms scavenge 82.7 101.4 82.7 101.4 mb pooled 1 mb 0.43 0.00 ms average mu 0.992 current mu 0.958 testing mem 100k iteration 141.09 mb abortcontroller abortsignal destroy clear concise description expect happen applicable add screenshot help explain problem alternatively add console log node v22.3.0 docker image node apline add context problem
","A issue relata um vazamento de memória (memory leak) relacionado ao AbortController/AbortSignal no Node.js.  Isso indica um problema que precisa de refatoração no código para corrigir o vazamento.  A presença de testes de memória e análise de dados de GC (Garbage Collection) no corpo da issue, assim como menções a testes e a necessidade de reproduzir o problema, sugerem fortemente que testes de regressão são necessários para verificar a correção do problema após a refatoração."
121,54573,"2024-08-26 20:37:39","2024-10-07 11:11:30","2024-10-07 11:11:30","Parcel 2.12.0 malloc(): corrupted top size in Node 22.7.0","### Version

22.7.0

### Platform

```text
Linux 6.8.0-40-generic #40~22.04.3-Ubuntu SMP PREEMPT_DYNAMIC Tue Jul 30 17:30:19 UTC 2 x86_64 x86_64 x86_64 GNU/Linux
```


### Subsystem

_No response_

### What steps will reproduce the bug?

Mirror of https://github.com/parcel-bundler/parcel/issues/9926
More information available in https://github.com/parcel-bundler/parcel/issues/9926

# 🐛 bug report

In Node 22.7.0 (not older versions), parcel now fails with this error

```
pnpm exec parcel build --target html ./src/browser/index.html
malloc(): corrupted top size
```

I get more info here:
https://github.com/aminya/assemblyscript-template/actions/runs/10531888327/job/29184908856#step:7:51
```
(node:2304) [DEP0040] DeprecationWarning: The `punycode` module is deprecated. Please use a userland alternative instead.
(Use `node --trace-deprecation ...` to show where the warning was created)
Building...
Bundling...
node: malloc.c:4302: _int_malloc: Assertion `(unsigned long) (size) >= (unsigned long) (nb)' failed.
Aborted (core dumped)
```

gdb stacktrace
```
#0  __pthread_kill_implementation (no_tid=0, signo=6, threadid=140736297170496) at ./nptl/pthread_kill.c:44
#1  __pthread_kill_internal (signo=6, threadid=140736297170496) at ./nptl/pthread_kill.c:78
#2  __GI___pthread_kill (threadid=140736297170496, signo=signo@entry=6) at ./nptl/pthread_kill.c:89
#3  0x00007ffff7a78476 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26
#4  0x00007ffff7a5e7f3 in __GI_abort () at ./stdlib/abort.c:79
#5  0x00007ffff7abf676 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff7c11b77 ""%s\n"")
    at ../sysdeps/posix/libc_fatal.c:155
#6  0x00007ffff7ad6cfc in malloc_printerr (str=str@entry=0x7ffff7c14bc0 ""malloc(): invalid size (unsorted)"") at ./malloc/malloc.c:5664
#7  0x00007ffff7ada0dc in _int_malloc (av=av@entry=0x7fffb4000030, bytes=bytes@entry=32) at ./malloc/malloc.c:4002
#8  0x00007ffff7adb139 in __GI___libc_malloc (bytes=32) at ./malloc/malloc.c:3329
#9  0x00007ffff7e1998c in operator new(unsigned long) () from /lib/x86_64-linux-gnu/libstdc++.so.6
#10 0x000000000153c25a in void std::vector<v8::internal::Handle<v8::internal::Map>, std::allocator<v8::internal::Handle<v8::internal::Map> > >::_M_realloc_insert<v8::internal::Handle<v8::internal::Map> >(__gnu_cxx::__normal_iterator<v8::internal::Handle<v8::internal::Map>*, std::vector<v8::internal::Handle<v8::internal::Map>, std::allocator<v8::internal::Handle<v8::internal::Map> > > >, v8::internal::Handle<v8::internal::Map>&&) ()
#11 0x0000000001657468 in v8::internal::FeedbackNexus::ExtractMaps(std::vector<v8::internal::Handle<v8::internal::Map>, std::allocator<v8::internal::Handle<v8::internal::Map> > >*) const ()
#12 0x00000000015338ab in v8::internal::IC::ShouldRecomputeHandler(v8::internal::Handle<v8::internal::String>) ()
#13 0x0000000001533a6d in v8::internal::IC::UpdateState(v8::internal::Handle<v8::internal::Object>, v8::internal::Handle<v8::internal::Object>) ()
#14 0x0000000001542f82 in v8::internal::Runtime_LoadIC_Miss(int, unsigned long*, v8::internal::Isolate*) ()
#15 0x00007fffb3eac576 in ?? ()
#16 0x00000ce90ed0dce9 in ?? ()
#17 0x00007fffb8ff9870 in ?? ()
#18 0x0000000000000006 in ?? ()
#19 0x00007fffb8ff9910 in ?? ()
#20 0x00007fff94078390 in ?? ()
#21 0x0000033539ecf0f9 in ?? ()
#22 0x0000000000000016 in ?? ()
#23 0x0000199a69633c89 in ?? ()
#24 0x00002c28e4701669 in ?? ()
#25 0x000000649af40069 in ?? ()
#26 0x000039fef53b8f69 in ?? ()
#27 0x00000ff4c39d1739 in ?? ()
#28 0x000001f59ce09539 in ?? ()
#29 0x00002c28e4701669 in ?? ()
#30 0x0000033539ecf0f9 in ?? ()
#31 0x0000198fae9bec01 in ?? ()
#32 0x0000296284423d31 in ?? ()
#33 0x0000000000000002 in ?? ()
#34 0x000019efcfd8a149 in ?? ()
#35 0x00000ff4c39d1451 in ?? ()
#36 0x00007fffb8ff9978 in ?? ()
#37 0x00007fff9407810a in ?? ()
#38 0x000000649af40069 in ?? ()
#39 0x000039fef53b8e89 in ?? ()
#40 0x000019efcfd8a2a9 in ?? ()
#41 0x000019efcfd8a149 in ?? ()
#42 0x000000649af40069 in ?? ()
#43 0x0000033539ecefc9 in ?? ()
#44 0x0000198fae9bedd9 in ?? ()
#45 0x0000296284423c29 in ?? ()
#46 0x0000000000000002 in ?? ()
#47 0x000019efcfd8a361 in ?? ()
#48 0x000019efcfd8a1b1 in ?? ()
#49 0x00007fffb8ff9a00 in ?? ()
#50 0x00007fff940e2065 in ?? ()
#51 0x000000649af40069 in ?? ()
#52 0x000039fef53b8e89 in ?? ()
#53 0x000000649af40069 in ?? ()
#54 0x000000649af40069 in ?? ()
#55 0x000019efcfd8a361 in ?? ()
#56 0x000019efcfd8a181 in ?? ()
#57 0x00000ff4c39d1451 in ?? ()
#58 0x000000649af40069 in ?? ()
#59 0x000039fef53b8e89 in ?? ()
#60 0x00002292dbc81659 in ?? ()
#61 0x00003372a19e0339 in ?? ()
#62 0x0000296284423ad9 in ?? ()
#63 0x0000000000000003 in ?? ()
#64 0x00000ff4c39d1839 in ?? ()
#65 0x000019efcfd8a1b1 in ?? ()
#66 0x00007fffb8ff9a78 in ?? ()
#67 0x00007fff94113fdd in ?? ()
#68 0x000000649af40069 in ?? ()
#69 0x000039fef53b8e89 in ?? ()
#70 0x000019efcfd8a149 in ?? ()
#71 0x000000649af40069 in ?? ()
#72 0x000019efcfd8a149 in ?? ()
#73 0x000000649af40069 in ?? ()
#74 0x00000ff4c39d1839 in ?? ()
#75 0x00000cb215a4a059 in ?? ()
#76 0x00003372a19e0369 in ?? ()
#77 0x0000296284423a31 in ?? ()
#78 0x0000000000000002 in ?? ()
#79 0x00000ff4c39d18b9 in ?? ()
#80 0x00000ff4c39d1451 in ?? ()
#81 0x00007fffb8ff9ae0 in ?? ()
#82 0x00007fffb3e0d8de in ?? ()
#83 0x000000649af40069 in ?? ()
#84 0x000039fef53b8e89 in ?? ()
#85 0x00000ff4c39d1701 in ?? ()
#86 0x00000ff4c39d18b9 in ?? ()
#87 0x000039fef53b8e89 in ?? ()
#88 0x000000649af40069 in ?? ()
#89 0x0000004f00000000 in ?? ()
#90 0x00002a8d5a8248d9 in ?? ()
#91 0x0000000000000002 in ?? ()
#92 0x00000ff4c39d1959 in ?? ()
#93 0x00000ff4c39d1451 in ?? ()
#94 0x00007fffb8ff9c30 in ?? ()
#95 0x00007fffb3e0d8de in ?? ()
#96 0x000000649af40069 in ?? ()
#97 0x000039fef53b8d81 in ?? ()
#98 0x000000649af40069 in ?? ()
#99 0x000000649af40069 in ?? ()
#100 0x000000649af40069 in ?? ()
#101 0x000039fef53b8711 in ?? ()
#102 0x000039fef53b8169 in ?? ()
#103 0x000000649af40c69 in ?? ()
#104 0xffffffff00000000 in ?? ()
#105 0xffffffff00000000 in ?? ()
#106 0x000000649af400d9 in ?? ()
#107 0x000023964e0c19c9 in ?? ()
#108 0x000039fef53b8d81 in ?? ()
#109 0x00000ff4c39d1959 in ?? ()
#110 0x000039fef53b8711 in ?? ()
#111 0x00000cb215a67cf1 in ?? ()
#112 0x000000649af40069 in ?? ()
#113 0x000000649af40069 in ?? ()
#114 0x000000649af40069 in ?? ()
#115 0x000000649af40069 in ?? ()
#116 0x000000649af40069 in ?? ()
#117 0x000000649af40069 in ?? ()
#118 0x000039fef53b8169 in ?? ()
#119 0x0000000200000000 in ?? ()
#120 0x000000649af40069 in ?? ()
#121 0x000000649af40069 in ?? ()
#122 0x000000649af40069 in ?? ()
#123 0x000000649af40069 in ?? ()
#124 0x000039fef53b8919 in ?? ()
#125 0x000039fef53b88e1 in ?? ()
#126 0x000000649af40069 in ?? ()
#127 0x000039fef53b8149 in ?? ()
#128 0x000039fef53b8101 in ?? ()
#129 0x000039fef53b8889 in ?? ()
#130 0x000000649af40069 in ?? ()
#131 0x000004a700000000 in ?? ()
#132 0x0000296284424a51 in ?? ()
#133 0x0000000000000002 in ?? ()
#134 0x00000f524b10a5c1 in ?? ()
#135 0x000039fef53b8711 in ?? ()
#136 0x00007fffb8ff9c88 in ?? ()
#137 0x00007fffb3e0d8de in ?? ()
#138 0x00002292dbc9b329 in ?? ()
#139 0x000039fef53b7ff1 in ?? ()
#140 0x00000f524b10a5c1 in ?? ()
#141 0x000000649af40069 in ?? ()
#142 0x0000006700000000 in ?? ()
#143 0x00002962844246a1 in ?? ()
#144 0x0000000000000002 in ?? ()
#145 0x00000f524b10a519 in ?? ()
#146 0x00000cb215a67cf1 in ?? ()
#147 0x00007fffb8ff9ce8 in ?? ()
#148 0x00007fffb3e0d8de in ?? ()
#149 0x00002292dbc9b329 in ?? ()
#150 0x000039fef53b7ff1 in ?? ()
#151 0x00002292dbc9b329 in ?? ()
#152 0x00000f524b10a519 in ?? ()
#153 0x000000649af40069 in ?? ()
#154 0x0000004700000000 in ?? ()
#155 0x00002962844245f9 in ?? ()
#156 0x0000000000000002 in ?? ()
#157 0x00003d11bf0eab99 in ?? ()
#158 0x00003d11bf0eb0e9 in ?? ()
#159 0x00007fffb8ff9d58 in ?? ()
#160 0x00007fffb3e0d8de in ?? ()
#161 0x00003d11bf0e9d51 in ?? ()
#162 0x000039fef53b7ff1 in ?? ()
#163 0x00001d7decf7e341 in ?? ()
#164 0x000039fef53b7ff1 in ?? ()
#165 0x000000649af40069 in ?? ()
#166 0x00003d11bf0eab99 in ?? ()
#167 0x000000649af40069 in ?? ()
#168 0x0000005500000000 in ?? ()
#169 0x0000296284423859 in ?? ()
#170 0x0000000000000002 in ?? ()
#171 0x000015cdba928f41 in ?? ()
#172 0x00000cb215a6a5d1 in ?? ()
#173 0x00007fffb8ff9db8 in ?? ()
#174 0x00007fffb3e0d8de in ?? ()
#175 0x00003d11bf0e9d51 in ?? ()
#176 0x000039fef53b7ff1 in ?? ()
#177 0x00003d11bf0e9d51 in ?? ()
#178 0x000015cdba928f41 in ?? ()
#179 0x000000649af40069 in ?? ()
#180 0x0000004700000000 in ?? ()
#181 0x00002962844237c9 in ?? ()
#182 0x0000000000000002 in ?? ()
#183 0x00003d11bf0eb0b1 in ?? ()
#184 0x00003d11bf0ecc19 in ?? ()
#185 0x00007fffb8ff9e80 in ?? ()
#186 0x00007fff9408662e in ?? ()
#187 0x00000cb215a6b139 in ?? ()
#188 0x000039fef53b7ff1 in ?? ()
#189 0x000000649af40069 in ?? ()
#190 0x000039fef53b7ff1 in ?? ()
#191 0x00000cb215a6b139 in ?? ()
#192 0x00003d11bf0eb0b1 in ?? ()
#193 0x000001f59ce1b8f9 in ?? ()
#194 0x000039fef53b8219 in ?? ()
#195 0x00000cb215a6b291 in ?? ()
#196 0x000000649af40069 in ?? ()
#197 0x000000649af40069 in ?? ()
#198 0x000000649af40069 in ?? ()
#199 0x00003d11bf0eb0b1 in ?? ()
#200 0x000039fef53b7ff1 in ?? ()
#201 0x000039fef53b82a1 in ?? ()
#202 0x000000649af40069 in ?? ()
#203 0x000039fef53b8269 in ?? ()
#204 0x000022c20de14ce1 in ?? ()
#205 0x00002bfc6ece6d29 in ?? ()
#206 0x000008c202f8e109 in ?? ()
#207 0x0000000000000004 in ?? ()
#208 0x00000cb215a6b329 in ?? ()
#209 0x000039fef53b8219 in ?? ()
#210 0x00007fffb8ff9f28 in ?? ()
#211 0x00007fffb3e0d8de in ?? ()
#212 0x00000cb215a6b139 in ?? ()
#213 0x000039fef53b7ff1 in ?? ()
#214 0x000000649af47c21 in ?? ()
#215 0x000000649af40069 in ?? ()
#216 0x000000649af40069 in ?? ()
#217 0x000000649af47c21 in ?? ()
#218 0x000039fef53b7ff1 in ?? ()
#219 0x00000cb215a6b139 in ?? ()
#220 0x00000cb215a6b329 in ?? ()
#221 0x000001f59ce2a8c9 in ?? ()
#222 0x000028972d731ec9 in ?? ()
#223 0x000000649af40069 in ?? ()
#224 0x000000649af40069 in ?? ()
#225 0x000000649af40069 in ?? ()
#226 0x0000006900000000 in ?? ()
#227 0x000017362fc04a19 in ?? ()
#228 0x0000000000000004 in ?? ()
#229 0x000001f59ce2a889 in ?? ()
#230 0x000001f59ce2a8c9 in ?? ()
#231 0x00007fffb8ff9f68 in ?? ()
#232 0x00007fffb3e0b4dc in ?? ()
#233 0x00000cb215a6b139 in ?? ()
#234 0x000039fef53b7ff1 in ?? ()
#235 0x000000649af40069 in ?? ()
#236 0x000000649af47c21 in ?? ()
#237 0x000001f59ce2a889 in ?? ()
#238 0x000000000000002c in ?? ()
#239 0x00007fffb8ff9fd0 in ?? ()
#240 0x00007fffb3e0b203 in ?? ()
#241 0x0000000000000000 in ?? ()
```

<!--- Provide a general summary of the issue here -->

## 🎛 Configuration (.babelrc, package.json, cli command)

<!--- If describing a bug, tell us what your babel configuration looks like -->

https://github.com/aminya/assemblyscript-template/tree/453edd38314835246c692319b6ae53c430a8010f

```js
  ""html"": ""./dist/index.html"",
  ""targets"": {
    ""html"": {
      ""context"": ""browser"",
      ""engines"": {
        ""browsers"": ""Chrome 76""
      }
    }
  }
```

## 💻 Code Sample

https://github.com/aminya/assemblyscript-template/tree/453edd38314835246c692319b6ae53c430a8010f

## 🌍 Your Environment

<!--- Include as many relevant details about the environment you experienced the bug in -->

| Software         | Version(s) |
| ---------------- | ---------- |
| Parcel           | 2.12.0
| Node             | 22.7.0
| npm/Yarn         | pnpm 9.7
| Operating System | KDE Ubuntu 22.04


### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

There should not be a difference between Node 22.6.0 and 22.7.0

### What do you see instead?

Segfault in 22.7.0

### Additional information

_No response_","closed","aminya",16418197,"{confirmed-bug,""v8 engine"",regression,v22.x}","https://github.com/nodejs/node/issues/54573",33,"Ambos",NULL,42,"node version parcel fail error malloc corrupt top size get info deprecationwarning punycode module deprecated use userland alternative instead building bundling node malloc assertion fail abort core dump gdb stacktrace should difference node there segfault
","A issue relata um erro de corrupção de memória (`malloc(): corrupted top size`) em uma aplicação Node.js usando Parcel. Os comentários indicam tentativas de reprodução do erro, depuração com GDB e Valgrind,  busca pelo commit causador com `git bisect`, e análise da pilha de chamadas (stack trace) apontando para problemas em manipulação de buffers e o V8.  A combinação de busca por problemas de memória,  com testes para reprodução e isolamento do problema (testes de regressão implícitos na busca por um caso mínimo de reprodução) justifica a classificação 'Ambos'. "
274,43528,"2022-06-22 02:20:40","2022-06-28 10:10:51","2022-06-28 10:10:51","REPL in editor mode crashes during tab completion ","### Version

v18.4.0

### Platform

_No response_

### Subsystem

_No response_

### What steps will reproduce the bug?

```console
$ node
Welcome to Node.js v18.4.0.
Type "".help"" for more information.
> .editor
// Entering editor mode (Ctrl+D to finish, Ctrl+C to cancel)
a
```

And then press TAB

### How often does it reproduce? Is there a required condition?

always

### What is the expected behavior?

Works without problems.

### What do you see instead?

```console
> .editor
// Entering editor mode (Ctrl+D to finish, Ctrl+C to cancel)
anode:internal/readline/emitKeypressEvents:74
            throw err;
            ^

TypeError: Cannot read properties of undefined (reading 'length')
    at commonPrefix (node:internal/readline/utils:375:27)
    at [_tabCompleter] (node:internal/readline/interface:670:20)
    at node:readline:448:24
    at node:repl:1606:3
    at completionGroupsLoaded (node:repl:1592:5)
    at REPLServer.complete (node:repl:1489:7)
    at REPLServer.completer (node:repl:762:5)
    at Interface._tabComplete (node:readline:440:8)
    at [_ttyWrite] [as _ttyWrite] (node:internal/readline/interface:1319:31)
    at REPLServer.self._ttyWrite (node:repl:1029:11)

Node.js v18.4.0
```

### Additional information

Now I'm working on this. I'll send a PR in later.","closed","cola119",22386678,"{confirmed-bug,repl}","https://github.com/nodejs/node/issues/43528",0,"Ambos",NULL,6,NULL,"O título da issue indica um problema de crash ('crashes') durante o uso do REPL, sugerindo a necessidade de refatoração para corrigir a causa raiz do erro.  O corpo da issue menciona que o autor está trabalhando em uma solução ('Now I'm working on this. I'll send a PR in later.'), o que implica em um futuro teste de regressão para garantir que a correção não introduza novos problemas. A presença do stack trace reforça a necessidade de análise e ajustes no código (refatoração)."
111,55009,"2024-09-19 12:23:02","2024-09-21 13:42:16","2024-09-21 13:42:16","`dot` reporter causes the terminal to clear since Node v22.8.0","### Version

22.8.0

### Platform

```text
arwin MBP-AJ-2023.local 23.6.0 Darwin Kernel Version 23.6.0: Mon Jul 29 21:13:04 PDT 2024; root:xnu-10063.141.2~1/RELEASE_ARM64_T6020 arm64
```


### Subsystem

_No response_

### What steps will reproduce the bug?

Create an empty `repro.test.js` file.

Run:

```
node --test-reporter=dot --test repro.test.js
```

=> the terminal clears

Whereas it doesn't, when `--test-reporter=dot` is not provided.

Both cases were working fine with Node v22.5.1.

### How often does it reproduce? Is there a required condition?

Systematically.

### What is the expected behavior? Why is that the expected behavior?

The terminal should not clear, so the test results and stdout from previous commands remain on screen.

### What do you see instead?

Blank terminal window.

### Additional information

_No response_","closed","adrienjoly",531781,"{confirmed-bug,regression,test_runner,v22.x}","https://github.com/nodejs/node/issues/55009",5,"Ambos",NULL,2,"versão 22.8 plataforma darwin kernel versão root arm64 passo reproduzir erro criar arquivo vazio executar terminal limpar fornecer ambos caso funcionar corretamente nó versão comportamento esperado terminal limpar resultado teste stdout comando anterior permanecer tela ver janela terminal branco informação adicional
","O título da issue indica um problema com o reporter `dot` (Refatoração, pois sugere uma necessidade de modificar o reporter para corrigir um comportamento indesejado).  Os comentários, por outro lado, demonstram tentativas de reprodução do erro e busca pela causa raiz ('reproduce', 'tried root cause clear'),  o que indica a necessidade de testes de regressão para garantir que a correção não introduza novos problemas. A combinação dessas duas perspectivas (correção de comportamento e testes subsequentes) justifica a classificação como 'Ambos'."
112,54945,"2024-09-14 16:29:11","2024-12-19 11:49:36","2024-12-19 11:49:36","[stream] uncatchable error thrown during piping if source and dest don't have same objectMode setting","### Version

22.8.0

### Platform

```text
Darwin [hostname] 23.6.0 Darwin Kernel Version 23.6.0: Mon Jul 29 21:14:46 PDT 2024; root:xnu-10063.141.2~1/RELEASE_ARM64_T6031 arm64
```


### Subsystem

stream

### What steps will reproduce the bug?

Run the following code:

```javascript
import { Readable, Transform } from ""node:stream"";

async function main() {
  const objectReadable = Readable.from([
    { hello: ""world"" },
    { goodbye: ""world"" }
  ]);

  objectReadable.on(""error"", err => {
    console.log(""objectReadable error"", err);
  });

  const passThrough = new Transform({
    transform(chunk, _encoding, cb) {
      this.push(chunk);
      cb(null);
    },
    objectMode: false // code works if set to true
  });

  passThrough.on(""error"", err => {
    console.log(""passThrough error"", err);
  });

  try {
    console.assert(objectReadable.readableObjectMode, ""objectReadable is not in object mode"");
    console.assert(!passThrough.writableObjectMode, ""passThrough is not in byte mode write side"");

    console.log(""beginning pipe"");
    objectReadable.pipe(passThrough);
  } catch (e) {
    console.error(""caught error when calling pipe"", e);
    return;
  }

  try {
    console.log(""beginning consume of passThrough"");
    const output = [];
    for await (const v of passThrough) {
      output.push(v);
    }
    console.log(""output"", output);
  } catch (e) {
    console.error(""caught error while consuming output"", e);
    return;
  }

  console.log(""done"");
}

process.setUncaughtExceptionCaptureCallback(err => {
  console.error(""uncaught exception"", err);
});

main();
```

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

Probably `Readable.pipe()` should compare the `objectMode` state of the source and the write side of the destination, and if they don't match, it should synchronously throw.

So, in the code above, I would expect to catch an error on the line that reads `console.error(""caught error when calling pipe"", e);`

Alternatively, the writable (or transform) stream could emit an error. In that case, in the code above, I would expect to see an error logged by the `passThrough.on(""error"")` callback.

### What do you see instead?

There is an uncaught exception. It is caught by the callback to `process.setUncaughtExceptionCaptureCallback`. That exception is:

```
TypeError [ERR_INVALID_ARG_TYPE]: The ""chunk"" argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received an instance of Object
    at _write (node:internal/streams/writable:480:13)
    at Writable.write (node:internal/streams/writable:508:10)
    at Readable.ondata (node:internal/streams/readable:1007:22)
    at Readable.emit (node:events:520:28)
    at Readable.read (node:internal/streams/readable:780:10)
    at flow (node:internal/streams/readable:1281:53)
    at emitReadable_ (node:internal/streams/readable:845:3)
    at process.processTicksAndRejections (node:internal/process/task_queues:89:21) {
  code: 'ERR_INVALID_ARG_TYPE'
}
```

I don't believe there is any way to catch this exception in the code that has the streams in context. (But if there is, then that'd be swell! And there's no issue here! And in that case, apologies for not understanding the right part of the streams API to handle these errors correctly.)

### Additional information

Broadly, the stream module is great ❤️ ! I love building stuff with it. Thanks for your hard work.","closed","joelrbrandt",908679,"{confirmed-bug,stream}","https://github.com/nodejs/node/issues/54945",12,"Ambos",NULL,96,"stream pipe objectmode error exception readable writable transform error handling  uncaught exception  invalid argument type string buffer typedarray dataview object
","O título e o corpo da issue mencionam erros ('uncatchable error', 'exception'),  tratamento de erros ('error handling'), e a necessidade de ajustes no código ('fix').  Os comentários discutem adicionar testes ('add test'), verificar o modo de objeto ('check source destination stream object mode setting'), e a adição de tratamento de exceções (`try catch`).  A combinação de correção de bugs e adição de testes indica que a issue envolve tanto refatoração quanto testes de regressão."
114,54830,"2024-09-07 14:34:25","2024-09-15 13:25:20","2024-09-15 13:25:20","REPL doesn't handle `npm` correctly","### Version

`main`

### Platform

```text
Linux XYZ-KALI 6.8.11-amd64 #1 SMP PREEMPT_DYNAMIC Kali 6.8.11-1kali2 (2024-05-30) x86_64 GNU/Linux
```


### Subsystem

repl

### What steps will reproduce the bug?

In the Node.js REPL, there is an error case specific to when the user types `npm ...` (where `...` can be anything). However, this breaks the REPL's recoverable error system.

I propose that, as a patch for this, the `npm` recovery error be removed, as the user should know to use npm outside the repl


### How often does it reproduce? Is there a required condition?

Everytime

### What is the expected behavior? Why is that the expected behavior?

```
> let npm = 1
> npm +
...
```
Note that the `...` indicates the REPL encountered a recoverable error and entered multiline mode.

### What do you see instead?

```
> let npm = 1
> npm +
npm should be run outside of the Node.js REPL, in your normal shell.
(Press Ctrl+D to exit.)
```

### Additional information

_No response_","closed","avivkeller",38299977,"{confirmed-bug,repl,npm}","https://github.com/nodejs/node/issues/54830",0,"Nenhum",NULL,8,"node js repl npm erro recuperavel sistema usuario shell multiline modo
","O título e o corpo da issue não indicam explicitamente refatoração ou testes de regressão.  A descrição menciona problemas com o REPL e o npm, sugerindo um bug ou problema de funcionalidade, mas não um trabalho de refatoração ou testes de regressão em si."
371,36731,"2021-01-02 08:55:53","2021-01-09 22:17:58","2021-01-09 22:17:58","net: blockList.addSubnet throw Assertion `args[2]->IsInt32()' failed when prefix is NaN ","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: 15.4.0
* **Platform**: macOS 10.15.7
* **Subsystem**: net

### What steps will reproduce the bug?

<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->

```js
const net = require('net');
const blockList = new net.BlockList();
blockList.addSubnet('', NaN);
```

### How often does it reproduce? Is there a required condition?
Everytime.

### What is the expected behavior?
throw `ERR_OUT_OF_RANGE ` error.

<!--
If possible please provide textual output instead of screenshots.
-->

### What do you see instead?

```
> blockList.addSubnet('', NaN)
node[2155]: ../src/node_sockaddr.cc:614:static void node::SocketAddressBlockListWrap::AddSubnet(const FunctionCallbackInfo<v8::Value> &): Assertion `args[2]->IsInt32()' failed.
 1: 0x101379d05 node::Abort() (.cold.1) [/usr/local/bin/node]
 2: 0x1000bde89 node::Abort() [/usr/local/bin/node]
 3: 0x1000bdcf1 node::Assert(node::AssertionInfo const&) [/usr/local/bin/node]
 4: 0x1001420e4 node::SocketAddressBlockListWrap::AddSubnet(v8::FunctionCallbackInfo<v8::Value> const&) [/usr/local/bin/node]
 5: 0x1002a3728 v8::internal::FunctionCallbackArguments::Call(v8::internal::CallHandlerInfo) [/usr/local/bin/node]
 6: 0x1002a2cbc v8::internal::MaybeHandle<v8::internal::Object> v8::internal::(anonymous namespace)::HandleApiCallHelper<false>(v8::internal::Isolate*, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::FunctionTemplateInfo>, v8::internal::Handle<v8::internal::Object>, v8::internal::BuiltinArguments) [/usr/local/bin/node]
 7: 0x1002a23e7 v8::internal::Builtin_Impl_HandleApiCall(v8::internal::BuiltinArguments, v8::internal::Isolate*) [/usr/local/bin/node]
 8: 0x100ac42d9 Builtins_CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit [/usr/local/bin/node]
 9: 0x100a5d402 Builtins_InterpreterEntryTrampoline [/usr/local/bin/node]
[1]    2155 abort      node
```

<!--
If possible please provide textual output instead of screenshots.
-->

### Additional information

<!--
Tell us anything else you think we should know.
-->
","closed","Lxxyx",13161470,"{confirmed-bug,net}","https://github.com/nodejs/node/issues/36731",0,"Nenhum",NULL,8,"version 15.4.0 platform macos 10.15.7 subsystem net step reproduce bug code snippet node install third party dependency net require net blocklist new net blocklist addsubnet nan expected behavior throw err out range see instead blocklist addsubnet assertion args isint failed additional information
","A issue descreve um erro de asserção ('Assertion `args[2]->IsInt32()' failed')  ao adicionar um subnet com prefixo NaN.  Não há menção a refatoração de código ou testes de regressão. O foco é na correção de um bug relacionado a validação de entrada."
277,43360,"2022-06-09 15:54:51","2022-06-25 12:47:28","2022-06-25 12:47:28","/32 subnet mask erroneously matches all IP addresses","### Version

v18.3.0

### Platform

Darwin xxx 21.5.0 Darwin Kernel Version 21.5.0: Tue Apr 26 21:08:22 PDT 2022; root:xnu-8020.121.3~4/RELEASE_X86_64 x86_64

### Subsystem

net

### What steps will reproduce the bug?

A /32 subnet mask such as `1.1.1.1/32` should match only the IP address `1.1.1.1` as all 32 bits should be compared. However, if a /32 subnet mask is used with `net.Blocklist()`, it erroneously matches all IP addresses.

The issue can be reproduced by running the following code snippet:

```js
const net = require('net')

const reservedIPBlocklist = new net.BlockList()
reservedIPBlocklist.addSubnet('1.1.1.1', 32, 'ipv4')

for (const ip of [""10.0.0.1"", ""1.1.1.1"", ""4.3.2.4"", ""27.192.11.1"", 
""192.168.1.9""]) {
    console.log(ip, reservedIPBlocklist.check(ip, 'ipv4'))    
}
```

Even though only `1.1.1.1` should match, `true` is printed for all the IPs:

```console
10.0.0.1 true
1.1.1.1 true
4.3.2.4 true
27.192.11.1 true
192.168.1.9 true
```

If the subnet mask is changed to < 32, Node behaves correctly.

### How often does it reproduce? Is there a required condition?

The bug can always be reproduced.

### What is the expected behavior?

See above.

### What do you see instead?

See above.

### Additional information

This bug is present across other versions of Node too, for example see https://www.mycompiler.io/view/1JuZ56bnWhl where the Node version is Node 16.15.0.","closed","supriyo-biswas",27079933,"{confirmed-bug,""good first issue""}","https://github.com/nodejs/node/issues/43360",8,"Refatoração",NULL,16,NULL,"A issue descreve um bug em uma função de máscara de sub-rede (/32) que está retornando resultados incorretos.  A solução requer corrigir o comportamento da função `net.BlockList().addSubnet()` para que ela funcione corretamente com máscaras /32. Isso indica a necessidade de refatoração do código para corrigir um erro de lógica, sem a necessidade imediata de novos testes, além dos existentes para garantir o funcionamento correto após a correção.  A discussão nos comentários foca na correção do código e na criação de um pull request para resolver o problema."
280,43274,"2022-06-01 05:28:35","2022-06-17 08:20:48","2022-06-17 08:20:48","`require` throws, but `require.resolve` does not","### Version

16.15.0

### Platform

Darwin computername.local 20.6.0 Darwin Kernel Version 20.6.0: Wed Jan 12 22:22:42 PST 2022; root:xnu-7195.141.19~2/RELEASE_X86_64 x86_64

### Subsystem

node:readline/promises

### What steps will reproduce the bug?

1. run `node -pe ""require.resolve('readline/promises2')""` and `node -pe ""require('readline/promises2')""`. Observe that both throw.
2. run `node -pe ""require('node:readline/promises')""`. Observe that it throws ""no such builtin module"".
3. run `node -pe ""require.resolve('node:readline/promises')""` or `node -pe ""require.resolve('node:readline/promises2')`, and instead of throwing, both print the given specifier.

Modules that are not requireable must NEVER be require.resolveable; that's part of the contract of require.

### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior?

_No response_

### What do you see instead?

See above.

### Additional information

_No response_","closed","ljharb",45469,"{confirmed-bug,module}","https://github.com/nodejs/node/issues/43274",4,"Ambos",NULL,16,NULL,"A issue relata um problema onde `require` lança exceção, mas `require.resolve` não,  indicando um bug no funcionamento do módulo `node:readline/promises`. Os comentários confirmam a existência do problema em diferentes versões do Node.js e discutem a necessidade de correção e backporting, o que envolve tanto a refatoração do código para corrigir o bug quanto testes de regressão para garantir que a correção não introduza novos problemas.  A natureza do problema afeta tanto a funcionalidade (requerimento do módulo) quanto a consistência interna da implementação do `require` e `require.resolve`."
118,54603,"2024-08-28 01:20:53","2024-09-24 21:18:30","2024-09-24 21:18:30","Node.js `structuredClone` objects do not preserve prototypes","When using `structuredClone` with and transferring the original in Node.js, the resulting clone's prototype is not the same as the original's. However, in other environments, the prototype remains consistent. 

```js
const original = new ReadableStream();
const transfer = structuredClone(original, { transfer: [original] });
console.log(Object.getPrototypeOf(transfer) === ReadableStream.prototype);
```

In Node.js, the above snippet logs `false`, however, in other environments, it logs `true`.","closed","avivkeller",38299977,"{confirmed-bug,""web streams"",web-standards,v22.x}","https://github.com/nodejs/node/issues/54603",5,"Nenhum",NULL,28,"use structuredclone transfer original nodejs result clone prototype original environment prototype remain consistent snippet log nodejs environment log true
","A issue descreve um problema com a preservação de protótipos ao usar `structuredClone` no Node.js.  Não há menção a refatoração de código ou a execução de testes de regressão. O foco é um bug específico em uma versão do Node.js, relacionado à compatibilidade com o V8 e a maneira como o `structuredClone` lida com protótipos.  Os comentários também se concentram em diagnosticar e reproduzir o problema, não em atividades de refatoração ou testes."
119,54601,"2024-08-28 00:49:54","2024-09-21 16:07:22","2024-09-21 16:07:22","Internal Assertion in `AbortSignal`","I am working on updating the Web Platform Tests in #54468, but ran into an issue occuring with `AbortSignal`. I narrowed down the issue to a minimal reproduction, with leads to an `ERR_INTERNAL_ASSERTION`:

```js
const controller = new AbortController();
const signal1 = AbortSignal.any([controller.signal]);

controller.signal.addEventListener('abort', () => {
    AbortSignal.any([signal1]);
})

controller.abort();
```
```
node:internal/event_target:1090
  process.nextTick(() => { throw err; });
                           ^

Error [ERR_INTERNAL_ASSERTION]: This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues

    at assert (node:internal/assert:14:11)
    at AbortSignal.any (node:internal/abort_controller:253:11)
    at AbortSignal.<anonymous> (/repro.js:5:17)
    at [nodejs.internal.kHybridDispatch] (node:internal/event_target:816:20)
    at AbortSignal.dispatchEvent (node:internal/event_target:751:26)
    at abortSignal (node:internal/abort_controller:374:10)
    at AbortController.abort (node:internal/abort_controller:396:5)
    at Object.<anonymous> (/repro.js:8:12)
    at Module._compile (node:internal/modules/cjs/loader:1546:14)
    at Module._extensions..js (node:internal/modules/cjs/loader:1691:10) {
  code: 'ERR_INTERNAL_ASSERTION'
}

Node.js v22.7.0
```

The failed assertion is https://github.com/nodejs/node/blob/885692a34f582c99d74430ba351879431738e43a/lib/internal/abort_controller.js#L253

---

It seems to me that Node.js's current behavior is to fail the assertion when a signal has already aborted, however the WPT's expected behavior is that ""Dependent signals for AbortSignal.any() are marked aborted before abort events fire"":
<https://github.com/web-platform-tests/wpt/blob/e78446e34a1921371658a5df08c71d83f50a2a2f/dom/abort/resources/abort-signal-any-tests.js#L193>","closed","avivkeller",38299977,"{confirmed-bug,abortcontroller,web-standards}","https://github.com/nodejs/node/issues/54601",6,"Ambos",NULL,25,"trabalho atualizar plataforma web teste encontrar problema ocorrer abortsignal reduzir problema reprodução mínima levar err_internal_assertion erro err_internal_assertion causar erro nodejs uso incorreto interno nodejs abrir problema rastro pilha falha asserção comportamento nodejs falhar asserção sinal já abortar comportamento esperado wpt sinal dependente abortsignal qualquer marcar abortar evento disparar
","O título da issue ""Internal Assertion in `AbortSignal`"" sugere um problema de funcionamento interno (possivelmente relacionado a refatoração). O corpo e os comentários discutem extensivamente testes, falhas de asserções, compatibilidade com WPT (Web Platform Tests), e propostas de soluções que envolvem modificações nos testes e no código.  A menção repetida a testes ('test', 'testing', 'test case'), asserções ('assertion', 'fail assertion'), e WPT indica fortemente a necessidade de testes de regressão.  A discussão sobre a correção do comportamento interno ('comportamento nodejs', 'comportamento esperado') implica em refatoração do código para resolver o problema raiz. Portanto, a issue abrange tanto refatoração quanto testes de regressão."
120,54577,"2024-08-26 21:33:13","2024-09-17 10:35:24","2024-10-23 17:33:05","ERR_INTERNAL_ASSERTION thrown when using --experimental-require-module and --import together","### Version

v22.7.0

### Platform

```text
Darwin Kyles-MBP-2.home 23.6.0 Darwin Kernel Version 23.6.0: Mon Jul 29 21:14:30 PDT 2024; root:xnu-10063.141.2~1/RELEASE_ARM64_T6000 arm64
```


### Subsystem

_No response_

### What steps will reproduce the bug?

With two files `test.mjs` and `test.cjs` (both files can be empty):
```sh
node --experimental-require-module --import=./test.mjs test.cjs
```

### How often does it reproduce? Is there a required condition?

Always.

### What is the expected behavior? Why is that the expected behavior?

No error should be thrown, and `--experimental-require-module` and `--import` can be used in combination. For example, to use module customization hooks when ECMAScript and CommonJS module types need to be mixed.

### What do you see instead?

This error is thrown:
```
node:internal/assert:14
    throw new ERR_INTERNAL_ASSERTION(message);
          ^

Error [ERR_INTERNAL_ASSERTION]: This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues

    at assert (node:internal/assert:14:11)
    at ModuleLoader.requireCommonJS (node:internal/modules/esm/translators:316:3)
    at callTranslator (node:internal/modules/esm/loader:428:14)
    at ModuleLoader.moduleProvider (node:internal/modules/esm/loader:434:30)
    at async link (node:internal/modules/esm/module_job:87:21) {
  code: 'ERR_INTERNAL_ASSERTION'
}
```

### Additional information

_No response_","closed","kylesmile",5431741,"{confirmed-bug,loaders}","https://github.com/nodejs/node/issues/54577",6,"Ambos",NULL,22,"erro interno asserção node js módulo comum js importar experimental require module
","O título e o corpo da issue mencionam um erro interno ('ERR_INTERNAL_ASSERTION'), indicando a necessidade de correção de bugs.  Porém, os comentários discutem extensamente a necessidade de refatoração do código relacionado ao carregamento de módulos (ESM, CJS), incluindo a menção explícita a 'refactoring' e a sugestão de melhorias na estrutura do código para lidar com diferentes tipos de módulos. Portanto, a issue abrange tanto a correção de bugs (Testes de Regressão) quanto a melhoria da estrutura do código (Refatoração)."
282,43182,"2022-05-22 21:25:47","2022-07-13 16:48:21","2022-10-26 17:23:53","Assertion failure when calling `process.exit()` from a Worker that has TLA","### Version

`master`

### Platform

macOS

### Subsystem

worker_threads

### What steps will reproduce the bug?

```js
new worker_threads.Worker(new URL(""data:text/javascript,process.exit(0);await new Promise(()=>{})""))
```


### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior?

No crash

### What do you see instead?

```console
$ out/Release/node -e 'new worker_threads.Worker(new URL(""data:text/javascript,process.exit(0);await new Promise(()=>{})""))'


#
# Fatal error in , line 0
# Check failed: (location_) != nullptr.
#
#
#
#FailureMessage Object: 0x700008060840
 1: 0x108604622 node::NodePlatform::GetStackTracePrinter()::$_3::__invoke() […/out/Release/node]
 2: 0x109772823 V8_Fatal(char const*, ...) […/out/Release/node]
 3: 0x108be671c v8::internal::SourceTextModule::ExecuteAsyncModule(v8::internal::Isolate*, v8::internal::Handle<v8::internal::SourceTextModule>) […/out/Release/node]
 4: 0x108be5f35 v8::internal::SourceTextModule::InnerModuleEvaluation(v8::internal::Isolate*, v8::internal::Handle<v8::internal::SourceTextModule>, v8::internal::ZoneForwardList<v8::internal::Handle<v8::internal::SourceTextModule> >*, unsigned int*) […/out/Release/node]
 5: 0x108be5d6b v8::internal::SourceTextModule::InnerModuleEvaluation(v8::internal::Isolate*, v8::internal::Handle<v8::internal::SourceTextModule>, v8::internal::ZoneForwardList<v8::internal::Handle<v8::internal::SourceTextModule> >*, unsigned int*) […/out/Release/node]
 6: 0x108be583b v8::internal::SourceTextModule::Evaluate(v8::internal::Isolate*, v8::internal::Handle<v8::internal::SourceTextModule>) […/out/Release/node]
 7: 0x10871b43c v8::Module::Evaluate(v8::Local<v8::Context>) […/out/Release/node]
 8: 0x10855c6ae node::loader::ModuleWrap::Evaluate(v8::FunctionCallbackInfo<v8::Value> const&) […/out/Release/node]
 9: 0x10877c9f8 v8::internal::FunctionCallbackArguments::Call(v8::internal::CallHandlerInfo) […/out/Release/node]
10: 0x10877c54b v8::internal::MaybeHandle<v8::internal::Object> v8::internal::(anonymous namespace)::HandleApiCallHelper<false>(v8::internal::Isolate*, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::FunctionTemplateInfo>, v8::internal::Handle<v8::internal::Object>, v8::internal::BuiltinArguments) […/out/Release/node]
11: 0x10877bc2b v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) […/out/Release/node]
12: 0x1090d2b39 Builtins_CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit […/out/Release/node]
13: 0x109056a90 Builtins_InterpreterEntryTrampoline […/out/Release/node]
[1]    43848 trace trap  out/Release/node -e 
```

### Additional information

The bug is reproducable on v14.x, v16.x, and v18.x lines.","closed","aduh95",14309773,"{confirmed-bug,worker}","https://github.com/nodejs/node/issues/43182",10,"Ambos",NULL,52,NULL,"A issue relata um erro de asserção (`Assertion failure`) ao chamar `process.exit()` de um Worker, causando um crash.  O problema está relacionado a como o V8 (motor JavaScript do Node.js) lida com a terminação da execução iniciada por `process.exit()` dentro de um Worker. A solução envolve correções tanto no Node.js (backporting de patches,  gerenciamento de exceções de terminação) quanto no V8 (correção da asserção no motor JavaScript).  Os comentários discutem a dificuldade de backportar para versões mais antigas do Node.js devido às mudanças no V8, indicando a necessidade de refatoração em algumas partes do código.  Além disso, há menção à inclusão de testes (`added a test case`), indicando a necessidade de testes de regressão para garantir que a correção não introduza novos problemas."
285,42976,"2022-05-05 15:00:18","2022-12-19 12:28:11","2022-12-19 12:28:11","deps: regression in openssl","### Version

18.1.0

### Platform

Linux host2 5.15.0-25-generic #25-Ubuntu SMP Wed Mar 30 15:54:22 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

openssl

### What steps will reproduce the bug?

build a simple addon

### How often does it reproduce? Is there a required condition?

always

### What is the expected behavior?

addon is built

### What do you see instead?

```console
$ yarn build 
yarn run v1.22.18
$ node-gyp configure --silent && node-gyp build --silent
make: Entering directory '/home/user/src/addon/build'
  CXX(target) Release/obj.target/addon/addon.o
In file included from /home/s/.cache/node-gyp/18.1.0/include/node/openssl/opensslconf.h:9,
                 from /home/s/.cache/node-gyp/18.1.0/include/node/openssl/macros.h:14,
                 from /home/s/.cache/node-gyp/18.1.0/include/node/openssl/evp.h:14,
                 from ../addon.cc:5:
/home/s/.cache/node-gyp/18.1.0/include/node/openssl/./opensslconf_asm.h:97:11: fatal error: ./archs/linux-x86_64/asm/include/openssl/opensslconf.h: No such file or directory
   97 | # include ""./archs/linux-x86_64/asm/include/openssl/opensslconf.h""
      |           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
compilation terminated.
make: *** [addon.target.mk:120: Release/obj.target/addon/addon.o] Error 1
$ head -n 5 addon.cc
#include <stdlib.h>
#include <string.h>
#include <iostream>

#include <openssl/evp.h>
```

### Additional information

commit https://github.com/nodejs/node/commit/7fae2c9d6efe4bdd5c3778ff6e0d906fa8277ca3 breaks C++ addons which use any `openssl` header","closed","yanovich",576586,"{confirmed-bug,openssl}","https://github.com/nodejs/node/issues/42976",6,"Ambos",NULL,228,NULL,"O título da issue ""deps: regression in openssl"" e o corpo da issue descrevem uma regressão (erro de regressão) na dependência OpenSSL que quebra a construção de addons C++. Isso indica um problema de testes de regressão, pois o problema não foi detectado antes da liberação.  A solução proposta envolve a correção do código, o que também implica refatoração. Os comentários reforçam a necessidade de testes de regressão e a correção do problema no código. Portanto, a issue envolve tanto refatoração quanto testes de regressão."
124,54518,"2024-08-23 08:12:48","2024-08-27 08:48:53","2024-08-27 08:48:53","ERR_BUFFER_OUT_OF_BOUNDS error with Google Vision package on Node 22.7.0","### Version

22.7.0

### Platform

```text
Darwin Sebastian-MacBook-Pro.local 23.5.0 Darwin Kernel Version 23.5.0: Wed May  1 20:12:58 PDT 2024; root:xnu-10063.121.3~5/RELEASE_ARM64_T6000 arm64
```


### Subsystem

_No response_

### What steps will reproduce the bug?


Create a file called test.js with the following content.
Add the `@google-cloud/vision` package to your package.json and run `npm install`.

```
const vision = require('@google-cloud/vision');

// Set up your Google Cloud Vision client
const client = new vision.ImageAnnotatorClient({
    keyFilename: 'XXX.json'
});
```

Start via `node test.js`

### How often does it reproduce? Is there a required condition?

On each NodeJS start

### What is the expected behavior? Why is that the expected behavior?

It should not crash. 

The same code starts with version 22.5.0, here is the output:

```
node test.js                                                                                                                                                                       
(node:34273) [DEP0040] DeprecationWarning: The `punycode` module is deprecated. Please use a userland alternative instead.
(Use `node --trace-deprecation ...` to show where the warning was created)
```

### What do you see instead?

```
node:internal/buffer:1066
      throw new ERR_BUFFER_OUT_OF_BOUNDS('length');
      ^

RangeError [ERR_BUFFER_OUT_OF_BOUNDS]: ""length"" is outside of buffer bounds
    at proto.utf8Write (node:internal/buffer:1066:13)
    at Op.writeStringBuffer [as fn] (/Users/sebastianscheibe/Code/XXX/node_modules/protobufjs/src/writer_buffer.js:61:13)
    at BufferWriter.finish (/Users/sebastianscheibe/Code/XXX/node_modules/protobufjs/src/writer.js:453:14)
    at /Users/sebastianscheibe/Code/XXX/node_modules/@grpc/proto-loader/build/src/index.js:177:109
    at Array.map (<anonymous>)
    at createPackageDefinition (/Users/sebastianscheibe/Code/XXX/node_modules/@grpc/proto-loader/build/src/index.js:177:39)
    at Object.fromJSON (/Users/sebastianscheibe/Code/XXX/node_modules/@grpc/proto-loader/build/src/index.js:230:12)
    at GrpcClient.loadProtoJSON (/Users/sebastianscheibe/Code/XXX/node_modules/google-gax/build/src/grpc.js:228:51)
    at new ImageAnnotatorClient (/Users/sebastianscheibe/Code/XXX/node_modules/@google-cloud/vision/build/src/v1/image_annotator_client.js:148:38)
    at Object.<anonymous> (/Users/sebastianscheibe/Code/XXX/test.js:5:16) {
  code: 'ERR_BUFFER_OUT_OF_BOUNDS'
}

Node.js v22.7.0
```

### Additional information

_No response_","closed","Ecostack",8505607,"{confirmed-bug,buffer,regression,v22.x}","https://github.com/nodejs/node/issues/54518",15,"Refatoração",NULL,4,"crash nodejs version nodejs start google cloud vision package install rangeerror err buffer out bounds protobufjs grpc proto loader google gax
","A issue descreve um erro de ""RangeError: ERR_BUFFER_OUT_OF_BOUNDS"", relacionado a manipulação de buffer.  Os comentários discutem soluções envolvendo alteração no código para lidar com limites de buffer e ajustes na função `utf8Write`.  Não há menção explícita a testes de regressão, embora a correção do erro possa exigir testes subsequentes.  O foco principal está em corrigir um problema no código existente (refatoração) para evitar o erro de limite de buffer. A menção à versão do Node.js e a solução com a alteração de versões também reforça o foco na refatoração do código para compatibilidade, e não na criação de testes."
125,54504,"2024-08-22 18:16:10","2024-09-25 08:51:13","2024-09-25 08:51:13","Speculative execution in REPL shows TypeError overwriting input","### Version

v22.6.0

### Platform

```text
Darwin Mikes-MacBook-Pro.local 23.6.0 Darwin Kernel Version 23.6.0: Mon Jul 29 21:13:00 PDT 2024; root:xnu-10063.141.2~1/RELEASE_X86_64 x86_64
```


### Subsystem

_No response_

### What steps will reproduce the bug?

As shown in attached video:

1. From command line run `node`
2. At the prompt, enter the following without hitting enter: `'\v'.codeAt(0)`
3. As soon as the close parenthesis is typed, see:

> TypeError: ""
            "".codeAt is not a function

The vertical tab pulled the cursor away from the prompt line.

Mitigation: Hitting Ctrl-l resets the cursor to expected.

https://github.com/user-attachments/assets/1e77ab0a-7097-420a-a598-08dc16e363a3



### How often does it reproduce? Is there a required condition?

Occurs every time

### What is the expected behavior? Why is that the expected behavior?

The REPL cursor should stay on the prompt line, not overlap any error message due to speculative execution.

### What do you see instead?

The vertical tab pulled the cursor away from the prompt line.

### Additional information

_No response_","closed","mikesamuel",368886,"{confirmed-bug,repl}","https://github.com/nodejs/node/issues/54504",1,"Nenhum",NULL,34,"node prompt enter close parenthesis typeerror function vertical tab cursor prompt line mitigation ctrl reset cursor expected repl cursor prompt line overlap error message speculative execution vertical tab cursor prompt line
","O título e o corpo da issue descrevem um erro (TypeError) relacionado à execução especulativa no REPL (Read-Eval-Print Loop).  Os comentários também mencionam um erro de tipo.  Não há menção a refatoração de código ou testes de regressão. O problema parece ser um bug ou um comportamento inesperado, necessitando de correção, mas não diretamente ligado às categorias mencionadas."
194,49675,"2023-09-16 22:13:39","2023-09-21 16:56:35","2023-09-21 16:56:35","Snapshotting is persisting the cwd","### Version

v20.6.1

### Platform

Darwin

### Subsystem

snapshots

### What steps will reproduce the bug?

Generate a snapshot of the given script, then run it from a different directory. The `process.cwd()` function will keep returning the cwd you had while building the snapshot.

```ts
const v8 = require(`v8`);

if (v8.startupSnapshot.isBuildingSnapshot()) {
    v8.startupSnapshot.setDeserializeMainFunction(() => {
        console.log(process.cwd());
    });
}
```

### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior? Why is that the expected behavior?

It should return the actual cwd.

### What do you see instead?

It returns the cwd at the time of `--build-snapshot`.

### Additional information

_No response_","closed","arcanis",1037931,"{confirmed-bug,snapshot}","https://github.com/nodejs/node/issues/49675",1,"Refatoração",NULL,5,"version platform darwin subsystem snapshot step reproduce bug generate snapshot script run different directory process cwd function keep return cwd build snapshot expected behavior return actual cwd see instead return cwd time build snapshot
","O título ""Snapshotting is persisting the cwd"" e o corpo da issue indicam um problema com o caminho de trabalho atual (cwd) sendo persistido durante a criação de snapshots.  A sugestão nos comentários de corrigir e limpar o `cachedcwd`  ('fix clear cachedcwd lib internal bootstrap switch own process state') aponta para uma modificação interna no código para resolver o problema, sem necessariamente envolver a adição ou execução de testes de regressão.  A solução proposta foca na melhoria do código existente, característica principal de uma refatoração."
288,42742,"2022-04-14 20:19:11","2022-05-01 19:50:01","2022-05-01 19:50:01","performance.timerify(fn, options) always return the same timerifed function","### Version

master branch

### Platform

All

### Subsystem

perf_hooks

### What steps will reproduce the bug?

```js
function f() {}
let h1 = perf_hooks.createHistogram()
let h2 = perf_hooks.createHistogram()
let f1 = perf_hooks.performance.timerify(f, {histogram: h1})
let f2 = perf_hooks.performance.timerify(f, {histogram: h2})
f1 !== f2 // expect true, actual false
```

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior?

Every calls of `performance.timerify(fn)` should return a new timerified function instance for `fn`, at least if `options` is provided.

### What do you see instead?

Currently `timerify` will cache the timerfied function as `fn[kTimerified]`, so `timerify(fn)` always return same  timerified function for `fn`, even different `options` was given.

### Additional information

Current cache behavior is not very useful, and cause problems for the use cases which need multiple timerified versions (for example, record timing for different usage of the same function).

PS. It also will throw if `fn` is frozen/sealed/non-extensible.","closed","hax",159840,"{confirmed-bug,perf_hooks}","https://github.com/nodejs/node/issues/42742",3,"Refatoração",NULL,17,NULL,"O problema relatado é que a função `performance.timerify` sempre retorna a mesma função, mesmo com opções diferentes. A solução proposta envolve remover o cache da função timerificada, o que sugere uma mudança na implementação da função sem adicionar novos recursos ou testes, indicando uma refatoração.  O corpo da issue menciona explicitamente que o comportamento atual de cache 'não é muito útil' e causa problemas, reforçando a necessidade de uma refatoração para melhorar o código existente."
289,42721,"2022-04-13 14:19:25","2022-05-25 14:40:28","2022-05-25 14:40:28","custom loader fails to resolve nested http(s) import","### Version

v17.9.0

### Platform

Darwin MacBook-Pro.local 21.4.0 Darwin Kernel Version 21.4.0: Fri Mar 18 00:45:05 PDT 2022; root:xnu-8020.101.4~15/RELEASE_X86_64 x86_64

### Subsystem

_No response_

### What steps will reproduce the bug?

Use a custom loader based on the [http loader example](https://nodejs.org/api/esm.html#https-loader)
Start node with the --experimental-loader flag.
Try to load any external esm module file via https using the following function
```js
import('https://my-domain.com/my-module.js'); 
```



### How often does it reproduce? Is there a required condition?

Always from version v17.7.0 and onwards

### What is the expected behavior?

To load and import the external module

### What do you see instead?

The data is loaded in the custom loader as a string and gets resolved as the loader example. Then the following error is thrown.
```
Error [ERR_INTERNAL_ASSERTION]: Base url for module undefined not loaded.
This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues
    at new NodeError (node:internal/errors:372:5)
    at ESMLoader.getBaseURL (node:internal/modules/esm/loader:290:15)
    at ModuleWrap.<anonymous> (node:internal/modules/esm/module_job:79:37)
    at link (node:internal/modules/esm/module_job:78:36)
    at processTicksAndRejections (node:internal/process/task_queues:96:5) {
  code: 'ERR_INTERNAL_ASSERTION'
}
```


### Additional information

_No response_","closed","basmasking",94599650,"{confirmed-bug,loaders}","https://github.com/nodejs/node/issues/42721",24,"Refatoração",NULL,42,NULL,"A issue relata um erro em um carregador customizado para módulos ESM via HTTPS.  Os comentários indicam que o problema está relacionado a como o carregador interage com o sistema de importação de módulos do Node.js, especificamente com o `ESMLoader::getBaseURL()`.  A solução proposta envolve ajustes internos no carregador e no sistema de importação, para corrigir o comportamento com o objetivo de carregar os módulos corretamente.  Não há menção direta a testes de regressão, embora a correção provavelmente exija testes para garantir que a funcionalidade esteja funcionando corretamente após as mudanças. O foco principal é refatorar e corrigir o código existente para melhorar seu funcionamento e resolver o erro relatado."
127,54436,"2024-08-18 05:38:03","2024-08-25 07:30:36","2024-08-27 09:25:33","vm: regression for ""in"" operator on global between 22.4.1 and 22.5.0; breaks jsdom","### Version

v22.5.0

### Platform

```text
Microsoft Windows NT 10.0.22631.0 x64
```


### Subsystem

vm

### What steps will reproduce the bug?

```js
""use strict"";

const vm = require(""vm"");

class EventTarget {
  addEventListener() {}
}

const windowConstructor = function () {};
Object.setPrototypeOf(windowConstructor, EventTarget);
const windowPrototype = Object.create(EventTarget.prototype);

function Window() {
  vm.createContext(this);
  this._globalProxy = vm.runInContext(""this"", this);

  Object.setPrototypeOf(this, windowPrototype);

  const window = this;
  Object.defineProperty(this, ""window"", {
    get() {
      return window._globalProxy;
    },
    enumerable: true,
    configurable: true
  });
}

const window = new Window();

console.log(vm.runInContext(`""addEventListener"" in window`, window));
```

### How often does it reproduce? Is there a required condition?

Every time

### What is the expected behavior? Why is that the expected behavior?

Outputs true. (That occurs on v22.4.1.)

### What do you see instead?

Outputs false

### Additional information

_No response_","closed","domenic",617481,"{confirmed-bug,vm,v22.x}","https://github.com/nodejs/node/issues/54436",10,"Ambos",NULL,7,"version v22 5 0 platform microsoft windows nt x64 subsystem vm step reproduce bug eventtarget addEventListener windowConstructor windowPrototype window vm createContext globalProxy runInContext setPrototypeOf defineProperty get window enumerable configurable window console log runInContext addEventListener window reproduce every time expect behavior output true occur v22 4 1 see instead output false additional information response
","O título da issue menciona ""regression"", indicando um problema de regressão.  O corpo e os comentários discutem a necessidade de refatoração na hierarquia de classes e na forma como o `globalThis` é manipulado, para corrigir o problema de regressão.  A menção a testes quebrados ('lot test break') reforça a necessidade de testes de regressão após a refatoração. Portanto, a issue envolve tanto refatoração quanto testes de regressão."
128,54285,"2024-08-09 13:25:27","2024-09-28 13:50:55","2024-09-28 13:50:55","fs.cpSync fails when copying to a directory with a name starting with the source directory name","### Version

v22.6.0

### Platform

```text
Darwin ikemoto-macmini.local 23.6.0 Darwin Kernel Version 23.6.0: Mon Jul 29 21:14:21 PDT 2024; root:xnu-10063.141.2~1/RELEASE_ARM64_T8103 arm64
```


### Subsystem

fs module

### What steps will reproduce the bug?

```javascript
fs = require(""fs"");
fs.cpSync(""./foo"", ""./foobar"", { recursive: true });
```

### How often does it reproduce? Is there a required condition?

This bug reproduces consistently in Node.js v22.6.0. It works correctly in v22.5.1.

### What is the expected behavior? Why is that the expected behavior?

The expected behavior, as seen in v22.5.1, is that the `./foo` directory should be copied to `./foobar`. This is the normal operation of the `fs.cpSync` function and aligns with the documented behavior.

### What do you see instead?

In v22.6.0, the following error is thrown:

```
node:internal/fs/cp/cp-sync:56
  fsBinding.cpSyncCheckPaths(src, dest, opts.dereference, opts.recursive);
            ^

Error: Cannot copy ./foo to a subdirectory of self ./foobar
    at cpSyncFn (node:internal/fs/cp/cp-sync:56:13)
    at Object.cpSync (node:fs:3044:3)
    at Object.<anonymous> (/Users/ikemo/tmp/main.js:2:4)
    at Module._compile (node:internal/modules/cjs/loader:1546:14)
    at Module._extensions..js (node:internal/modules/cjs/loader:1691:10)
    at Module.load (node:internal/modules/cjs/loader:1317:32)
    at Module._load (node:internal/modules/cjs/loader:1127:12)
    at TracingChannel.traceSync (node:diagnostics_channel:315:14)
    at wrapModuleLoad (node:internal/modules/cjs/loader:217:24)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:166:5) {
  code: 'ERR_FS_CP_EINVAL'
}
```

### Additional information

The issue is caused by the misuse of the `starts_with` function in a newly added check. This check incorrectly prevents copying to directories whose names start with the source directory name. For details, see:
https://github.com/nodejs/node/pull/53614/files#diff-70e3325bd2115867617ae2a16321c5de53c070ff2841976fe5b849675a5111e6R3186-R3190","closed","ikemo3",17794311,"{confirmed-bug,fs}","https://github.com/nodejs/node/issues/54285",3,"Refatoração",NULL,50,"erro copiar subdiretorio nodejs versao problema fs cpsync funcao copia diretorio subdiretorio nome inicia nome diretorio fonte detalhe link github
","A issue descreve um erro na função `fs.cpSync` do Node.js ao copiar subdiretórios com nomes que iniciam com o nome do diretório fonte.  A menção a um patch e PR (Pull Request) sugere uma correção de código, que é característica de refatoração.  Embora haja menção a erros, não há foco em testes de regressão, apenas na correção do problema em si."
195,49650,"2023-09-14 11:29:39","2023-09-30 18:38:24","2023-09-30 18:38:24","URL: invalid assignments to .host & .hostname not ignored, crashes","### Version

v20.6.1

### Platform

```
Darwin jannis-mba2.local 21.6.0 Darwin Kernel Version 21.6.0: Thu Jul  6 22:20:00 PDT 2023; root:xnu-8020.240.18.702.13~1/RELEASE_ARM64_T8110 arm64
```

### Subsystem

url

### What steps will reproduce the bug?

```js
{
	const url = new URL('http://foo')
	url.hostname = '::'
	console.log(url.href) // `http:///`, should be either `http://foo` or `http://[::]`, not sure?
}
{
	const url = new URL('http://foo')
	url.host = '::'
	console.log(url.href) // `http:///`, should probably be `http://foo`?
}
{
	const url = new URL('http://foo')
	url.host = '::' // does *not* crash
	url.port = 3000 // crashes with the described error below
}
```

```
node[7108]: ../src/node_url.cc:278:static void node::url::BindingData::Update(const FunctionCallbackInfo<v8::Value> &): Assertion `out' failed.
 1: 0x10292d660 node::Abort() [/opt/homebrew/Cellar/node/20.6.1/bin/node]
 2: 0x10292d644 node::Abort() [/opt/homebrew/Cellar/node/20.6.1/bin/node]
 3: 0x1029ce6d0 node::url::BindingData::Update(v8::FunctionCallbackInfo<v8::Value> const&) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
 4: 0x102af8820 v8::internal::FunctionCallbackArguments::Call(v8::internal::CallHandlerInfo) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
 5: 0x102af8384 v8::internal::MaybeHandle<v8::internal::Object> v8::internal::(anonymous namespace)::HandleApiCallHelper<false>(v8::internal::Isolate*, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::FunctionTemplateInfo>, v8::internal::Handle<v8::internal::Object>, unsigned long*, int) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
 6: 0x102af8158 v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
 7: 0x102760b24 Builtins_CEntry_Return1_ArgvOnStack_BuiltinExit [/opt/homebrew/Cellar/node/20.6.1/bin/node]
 8: 0x1026d83e4 Builtins_InterpreterEntryTrampoline [/opt/homebrew/Cellar/node/20.6.1/bin/node]
 9: 0x1026d650c Builtins_JSEntryTrampoline [/opt/homebrew/Cellar/node/20.6.1/bin/node]
10: 0x1026d61f4 Builtins_JSEntry [/opt/homebrew/Cellar/node/20.6.1/bin/node]
11: 0x102bb6a14 v8::internal::(anonymous namespace)::Invoke(v8::internal::Isolate*, v8::internal::(anonymous namespace)::InvokeParams const&) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
12: 0x102bb6030 v8::internal::Execution::Call(v8::internal::Isolate*, v8::internal::Handle<v8::internal::Object>, v8::internal::Handle<v8::internal::Object>, int, v8::internal::Handle<v8::internal::Object>*) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
13: 0x102e5d078 v8::internal::Object::SetPropertyWithAccessor(v8::internal::LookupIterator*, v8::internal::Handle<v8::internal::Object>, v8::Maybe<v8::internal::ShouldThrow>) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
14: 0x102e61284 v8::internal::Object::SetPropertyInternal(v8::internal::LookupIterator*, v8::internal::Handle<v8::internal::Object>, v8::Maybe<v8::internal::ShouldThrow>, v8::internal::StoreOrigin, bool*) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
15: 0x102e61018 v8::internal::Object::SetProperty(v8::internal::LookupIterator*, v8::internal::Handle<v8::internal::Object>, v8::internal::StoreOrigin, v8::Maybe<v8::internal::ShouldThrow>) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
16: 0x102cb378c v8::internal::StoreIC::Store(v8::internal::Handle<v8::internal::Object>, v8::internal::Handle<v8::internal::Name>, v8::internal::Handle<v8::internal::Object>, v8::internal::StoreOrigin) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
17: 0x102cb66a8 v8::internal::Runtime_StoreIC_Miss(int, unsigned long*, v8::internal::Isolate*) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
18: 0x102760c44 Builtins_CEntry_Return1_ArgvOnStack_NoBuiltinExit [/opt/homebrew/Cellar/node/20.6.1/bin/node]
19: 0x102809714 Builtins_SetNamedPropertyHandler [/opt/homebrew/Cellar/node/20.6.1/bin/node]
20: 0x1026d83e4 Builtins_InterpreterEntryTrampoline [/opt/homebrew/Cellar/node/20.6.1/bin/node]
21: 0x1026d83e4 Builtins_InterpreterEntryTrampoline [/opt/homebrew/Cellar/node/20.6.1/bin/node]
22: 0x1026d83e4 Builtins_InterpreterEntryTrampoline [/opt/homebrew/Cellar/node/20.6.1/bin/node]
23: 0x1026d83e4 Builtins_InterpreterEntryTrampoline [/opt/homebrew/Cellar/node/20.6.1/bin/node]
24: 0x1026d83e4 Builtins_InterpreterEntryTrampoline [/opt/homebrew/Cellar/node/20.6.1/bin/node]
25: 0x1026d83e4 Builtins_InterpreterEntryTrampoline [/opt/homebrew/Cellar/node/20.6.1/bin/node]
26: 0x1026d83e4 Builtins_InterpreterEntryTrampoline [/opt/homebrew/Cellar/node/20.6.1/bin/node]
27: 0x1026d650c Builtins_JSEntryTrampoline [/opt/homebrew/Cellar/node/20.6.1/bin/node]
28: 0x1026d61f4 Builtins_JSEntry [/opt/homebrew/Cellar/node/20.6.1/bin/node]
29: 0x102bb6a14 v8::internal::(anonymous namespace)::Invoke(v8::internal::Isolate*, v8::internal::(anonymous namespace)::InvokeParams const&) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
30: 0x102bb6030 v8::internal::Execution::Call(v8::internal::Isolate*, v8::internal::Handle<v8::internal::Object>, v8::internal::Handle<v8::internal::Object>, int, v8::internal::Handle<v8::internal::Object>*) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
31: 0x102ab3d54 v8::Function::Call(v8::Local<v8::Context>, v8::Local<v8::Value>, int, v8::Local<v8::Value>*) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
32: 0x10290f100 node::builtins::BuiltinLoader::CompileAndCall(v8::Local<v8::Context>, char const*, node::Realm*) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
33: 0x10299f6c4 node::Realm::ExecuteBootstrapper(char const*) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
34: 0x1028f01b8 node::StartExecution(node::Environment*, char const*) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
35: 0x1028f0168 node::StartExecution(node::Environment*, std::__1::function<v8::MaybeLocal<v8::Value> (node::StartExecutionCallbackInfo const&)>) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
36: 0x102855eb8 node::LoadEnvironment(node::Environment*, std::__1::function<v8::MaybeLocal<v8::Value> (node::StartExecutionCallbackInfo const&)>) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
37: 0x102972830 node::NodeMainInstance::Run(node::ExitCode*, node::Environment*) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
38: 0x1029725b0 node::NodeMainInstance::Run() [/opt/homebrew/Cellar/node/20.6.1/bin/node]
39: 0x1028f3e78 node::Start(int, char**) [/opt/homebrew/Cellar/node/20.6.1/bin/node]
40: 0x1056ad08c 
```

### How often does it reproduce? Is there a required condition?

Seems to be reproducible all the time.

### What is the expected behavior? Why is that the expected behavior?

I would expect Node.js to either a) accept input if it is valid, b) ignore invalid input as documented, or c) throw a helpful error (but this wouldn't match e.g. Chromium's behaviour).

The Node.js docs say this:

> `url.host`
> Gets and sets the host portion of the URL.
> […]
> Invalid host values assigned to the `host` property are ignored.

> `url.hostname`
> Gets and sets the host name portion of the URL. The key difference between `url.host` and `url.hostname` is that `url.hostname` does *not* include the port.
> […]
> Invalid host name values assigned to the `hostname` property are ignored.

### What do you see instead?

Unexpected results and crashes, see the reproduction steps above.

### Additional information

_No response_","closed","derhuerst",5072613,"{confirmed-bug,whatwg-url}","https://github.com/nodejs/node/issues/49650",3,"Refatoração",NULL,16,"node crash unexpected result input valid ignore invalid helpful error chromium behavior node doc say get set host portion url invalid host value assign property ignore get set host name portion url key difference url hostname hostname include port invalid host name value assign property ignore reproduce time expect node accept input valid ignore invalid input document throw helpful error node doc say get set host portion url invalid host value assign property ignore get set host name portion url key difference url hostname hostname include port
","O título da issue (""URL: invalid assignments to .host & .hostname not ignored, crashes"") indica um problema com o comportamento atual da URL, sugerindo a necessidade de ajustes no código para corrigir um erro de atribuição inválida.  O corpo da issue descreve um comportamento inesperado e sugere que a documentação está incorreta.  Os comentários mencionam uma correção ('issue fix') e problemas de compatibilidade ('old gcc version'),  mas o foco principal é a correção de um comportamento incorreto no código existente,  característica central de uma tarefa de refatoração.  Não há menção explícita a testes de regressão, embora implicitamente sejam necessários após a refatoração."
291,42558,"2022-04-01 08:56:05","2022-04-29 14:06:32","2022-04-29 14:06:33","Heap snapshot crash on v14.x","### Version

v14.19.1

### Platform

all

### Subsystem

v8 engine

### What steps will reproduce the bug?

Run the following script:

```js
function that() {
  const p = new Promise(resolve => {
    setTimeout(resolve, 1);
  });
  Promise.all([p]); // <= The key problem here, it created a PromiseAllResolveElementContext which crashes the HeapSnapshotGenerator
}
that();

const v8 = require('v8');
const fs = require('fs');
const stream = fs.createWriteStream('./node.heapsnapshot');
v8.getHeapSnapshot().pipe(stream);
```

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior?

No crashes.

### What do you see instead?

The program crashed with SIGSEGV.

![image](https://user-images.githubusercontent.com/8500303/161229903-7b716ae2-0533-44e0-adb4-c2fd577916fc.png)



### Additional information

Node.js v16.x doesn't have this problem. So I'd think we may need to find the v8 commit that fixed the problem and backport it to v14.x.","closed","legendecas",8500303,"{confirmed-bug,""v8 engine""}","https://github.com/nodejs/node/issues/42558",4,"Refatoração",NULL,28,NULL,"A issue descreve um crash no heap snapshot do Node.js v14.x.  A solução envolve encontrar um commit do V8 que corrigiu o problema e backportá-lo para a versão 14.x. Isso indica uma necessidade de alteração no código fonte (refatoração) para corrigir o bug,  sem a menção explícita de novos testes além da verificação da correção do problema. Os comentários reforçam essa ideia, apontando para um patch do V8 que resolve a questão e a subsequente inclusão dele em um pull request."
293,42206,"2022-03-03 23:51:32","2022-03-06 09:24:42","2022-03-06 09:24:42","Revoking a blob url twice causes an internal error and crashes node","### Version

v17.6.0

### Platform

Linux the-mistery-machine 5.13.0-30-generic #33~20.04.1-Ubuntu SMP Mon Feb 7 14:25:10 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

_No response_

### What steps will reproduce the bug?

The following code will cause Node to crash:

```js
import { Blob } from ""node:buffer"";

const url = URL.createObjectURL(new Blob([]));

URL.revokeObjectURL(url);
URL.revokeObjectURL(url);
```

### How often does it reproduce? Is there a required condition?

It happens consistently.

### What is the expected behavior?

The second `URL.revokeObjectURL` should just be a no-op, this is consistent with web behaviour.

### What do you see instead?

It produces the following crash:

```
node[1082797]: ../src/node_blob.cc:447:void node::BlobBindingData::revoke_data_object(const string&): Assertion `(data_objects_.find(uuid)) != (data_objects_.end())' failed.
 1: 0xb2e180 node::Abort() [node]
 2: 0xb2e1fe  [node]
 3: 0xb01e7a node::BlobBindingData::revoke_data_object(std::string const&) [node]
 4: 0xb02157 node::Blob::RevokeDataObject(v8::FunctionCallbackInfo<v8::Value> const&) [node]
 5: 0xd7c07e  [node]
 6: 0xd7d49f v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) [node]
 7: 0x1632979  [node]
zsh: abort (core dumped)  node --input-type=module < test.js
```

### Additional information

_No response_","closed","Jamesernator",8518303,"{confirmed-bug,buffer}","https://github.com/nodejs/node/issues/42206",1,"Nenhum",NULL,2,NULL,"A issue descreve um bug no Node.js relacionado a um crash ao chamar `URL.revokeObjectURL` duas vezes com a mesma URL.  Não há menção a refatoração de código ou testes de regressão. O foco é exclusivamente na correção de um erro de funcionamento do Node.js."
131,54257,"2024-08-07 23:15:27","2024-10-20 02:17:23","2024-10-20 02:17:23","`--heap-prof` is not allowed in NODE_OPTIONS","### Version

20.15.1

### Platform

```text
GitHub Action ubuntu-latest
```


### Subsystem

_No response_

### What steps will reproduce the bug?

```shell
> NODE_OPTIONS=""--heap-prof"" node ./custom-server.mjs
node: --heap-prof is not allowed in NODE_OPTIONS
```

### How often does it reproduce? Is there a required condition?

everytimeevery time

### What is the expected behavior? Why is that the expected behavior?

should allow pass `heap-prof` https://github.com/nodejs/node/pull/17600Should

### What do you see instead?

error

### Additional information

_No response_","closed","himself65",14026360,"{confirmed-bug,cli}","https://github.com/nodejs/node/issues/54257",4,"Nenhum",NULL,73,"allow heap prof node option error
","O título e corpo da issue não indicam diretamente refatoração ou testes de regressão.  O título menciona um erro relacionado à opção `--heap-prof` no NODE_OPTIONS, e o corpo fala sobre permitir essa opção. Os comentários discutem a solução do problema e a atribuição a um desenvolvedor.  Não há menção a mudanças estruturais no código (refatoração) nem a execução de testes para verificar o impacto de uma alteração (testes de regressão)."
133,54193,"2024-08-03 17:40:04","2024-10-23 14:02:37","2024-10-23 14:02:37","Node.js REPL freezes with ""while (true);"" or ""while (true){}"" input","### Version

v22.5.1

### Platform

```text
Linux linux 6.10.2-arch1-1 #1 SMP PREEMPT_DYNAMIC Sat, 27 Jul 2024 16:49:55 +0000 x86_64 GNU/Linux
```


### Subsystem

no modules were involved

### What steps will reproduce the bug?

Open Node.js interactive mode by typing `node` in the terminal.
2. Enter `while (false){}` or `while (false);`.
   - Notice the ""undefined"" display ready to be output.
3. Enter `while (true);` or `while (true){}`.
   - The terminal freezes and becomes unresponsive.


### How often does it reproduce? Is there a required condition?

It reproduces 100% of the time, the required condition is that you're on node.js interactive shell.

### What is the expected behavior? Why is that the expected behavior?

the expected behavior would be the return value of the block of code used in the while-loop, since 'while (false);' returned `undefined`, something predictably consistent is also expected with 'while (true);'

### What do you see instead?

The terminal stops working until I kill the process manually with htop or `kill` command from another terminal.

### Additional information

the issue is that in node.js interactive mode, when I type ""while (false){}"" or ""while (false);"" it will make a vague display of undefined ready to be output, sort of like a google suggestion. Now, here's the real deal issue: try typing ""while (true);"" or ""while (true){}"" instead. Your terminal will freeze and the only way to stop node.js at that point would be to kill the process with kill or htop. I think I know the reason behind the issue: the ""semi-google-suggestion-like"" vague display. Its purpose is it show you what is ready to be displayed when you press Enter, to save you ease and time by assuming that you likely are just wanting to glance at outcomes oftentimes. But to achieve this process of simulating the google-like output display, it has to execute the command in the background, and wait for the return result of executing that command, then send it to the vague display, therefore resulting in the bug that freezes your terminal when you type ""while (true);"" in interactive mode.","closed","dmand-commits",175909111,"{confirmed-bug,repl,""v8 engine"",inspector}","https://github.com/nodejs/node/issues/54193",14,"Refatoração",NULL,81,"node js interactivo terminal congelar processo matar htop comando  loop while falso verdadeiro indefinido comportamento esperado retorno valor bloco codigo  execução comando plano fundo resultado visualização  sugestão google  tempo  problema  modo interactivo digitar while falso  exibir indefinido  digitar while verdadeiro  terminal congelar  processo kill htop  razão  visualização  comando  fundo resultado  visualização  congelar terminal  while verdadeiro  modo interactivo
","A issue descreve um problema de congelamento do REPL do Node.js ao executar loops infinitos (""while (true)"").  Os comentários discutem  soluções envolvendo  limites de tempo no preview de código, ajustes no V8 e possivelmente uma alteração no funcionamento interno do Node.js para lidar melhor com loops infinitos no REPL.  Não há menção explícita a testes de regressão, embora uma solução possa exigir testes para validar a correção. A ênfase está na melhoria do comportamento e da performance do REPL, o que caracteriza uma refatoração."
134,54186,"2024-08-03 11:24:17","2024-11-05 01:09:49","2024-11-05 01:09:50","FATAL ERROR `v8::FromJust Maybe value is Nothing` ","### Version

v22.5.1

### Platform

```text
Debian 5.10.103-1  x86_64
```


### Subsystem

_No response_

### What steps will reproduce the bug?

Hi, 
I want to report a node bug, by running the following code snippet, node.js gives a FATAL error. 
```javascript
 Object.defineProperty(Object.prototype, '0', {   
     set() {
        console.log(123);        
     }
 });

const http = require('http');
```


AH

### How often does it reproduce? Is there a required condition?

By just running the given code, node runtime gives node crash. 

### What is the expected behavior? Why is that the expected behavior?

Not a crash, by looking at the stack trace, it seems it is connected to `v8::FromJust Maybe value is Nothing`.

### What do you see instead?

```shell
FATAL ERROR: v8::FromJust Maybe value is Nothing
----- Native stack trace -----

 1: 0xe22fb7 node::OnFatalError(char const*, char const*) [node]
 2: 0x122ada6 v8::Utils::ReportApiFailure(char const*, char const*) [node]
 3: 0x10da3d5 node::TTYWrap::GetWindowSize(v8::FunctionCallbackInfo<v8::Value> const&) [node]
 4: 0x7f44475cf6e2 

----- JavaScript stack trace -----

1: WriteStream (node:tty:115:28)
2: createWritableStdioStream (node:internal/bootstrap/switches/is_main_thread:56:16)
3: getStdout (node:internal/bootstrap/switches/is_main_thread:153:12)
4: get (node:internal/console/constructor:207:42)
5: value (node:internal/console/constructor:338:50)
6: log (node:internal/console/constructor:385:61)
7: set (/home/abdullah/node-deno-bun/test.js:3:25)
8: WriteStream (node:tty:115:28)
9: createWritableStdioStream (node:internal/bootstrap/switches/is_main_thread:56:16)
10: getStdout (node:internal/bootstrap/switches/is_main_thread:153:12)


Aborted

```

### Additional information

_No response_","closed","vdata1",10380316,"{confirmed-bug,""v8 engine""}","https://github.com/nodejs/node/issues/54186",10,"Ambos",NULL,94,"node bug fatal error run code snippet nodejs crash v8 fromjust maybe value nothing stack trace connect v8 fromjust maybe value nothing writestream createstdiostream getstdout get value log set writestream createstdiostream getstdout
","O título e o corpo da issue indicam um erro fatal ('FATAL ERROR') no Node.js, relacionado a um problema no V8 ('v8::FromJust Maybe value is Nothing').  Comentários subsequentes discutem a reprodução do erro, sua causa raiz (possivelmente um bug no V8), e a sugestão de uma solução através de refatoração do código ('code cleanup'). Além disso, há menção explícita à adição de testes ('think add test'), indicando a necessidade de testes de regressão após a correção. Portanto, a issue abrange tanto refatoração quanto testes de regressão."
294,42177,"2022-03-01 21:44:59","2022-03-08 22:00:56","2022-03-09 06:37:00","lib, doc: fix AsyncResource.bind not using 'this' from the caller by default","<!--
Before submitting a pull request, please read
https://github.com/nodejs/node/blob/HEAD/CONTRIBUTING.md.

Commit message formatting guidelines:
https://github.com/nodejs/node/blob/HEAD/doc/contributing/pull-requests.md#commit-message-guidelines

For code changes:
1. Include tests for any bug fixes or new features.
2. Update documentation if relevant.
3. Ensure that `make -j4 test` (UNIX), or `vcbuild test` (Windows) passes.

Developer's Certificate of Origin 1.1

By making a contribution to this project, I certify that:

(a) The contribution was created in whole or in part by me and I
    have the right to submit it under the open source license
    indicated in the file; or

(b) The contribution is based upon previous work that, to the best
    of my knowledge, is covered under an appropriate open source
    license and I have the right under that license to submit that
    work with modifications, whether created in whole or in part
    by me, under the same open source license (unless I am
    permitted to submit under a different license), as indicated
    in the file; or

(c) The contribution was provided directly to me by some other
    person who certified (a), (b) or (c) and I have not modified
    it.

(d) I understand and agree that this project and the contribution
    are public and that a record of the contribution (including all
    personal information I submit with it, including my sign-off) is
    maintained indefinitely and may be redistributed consistent with
    this project or the open source license(s) involved.
-->

This PR updates the default behaviour of `AsyncResource.bind()` to keep the value of `this` untouched by default when the `thisArg` option is not provided instead of setting it to the resource, meaning that the bound function will have the same value for `this` as if it wasn't bound at all.

Fixes #42158","closed","rochdev",1596303,"{confirmed-bug,async_hooks,""author ready"",commit-queue-squash}","https://github.com/nodejs/node/pull/42177",10,"Refatoração","https://api.github.com/repos/nodejs/node/pulls/42177",7,NULL,"O título e o corpo da issue indicam uma correção no comportamento padrão da função `AsyncResource.bind()`, alterando a forma como o valor de 'this' é tratado.  Não há menção explícita a novos testes ou funcionalidades, mas sim a uma mudança na implementação existente para corrigir um comportamento indesejado. Os comentários discutem o comportamento da função, reforçando a natureza da mudança como uma refatoração e não introduzindo novas funcionalidades que demandariam testes de regressão."
382,36162,"2020-11-18 07:43:24","2022-03-15 05:22:17","2022-03-15 05:22:17","doc: history shows wrong version for conditional package export support","# 📗 API Reference Docs Problem

<!-- The output of “node --version”. -->

- **Version**: 12.16.0

<!-- The output of “uname -a” (UNIX) or version
and 32-bit or 64-bit (Windows). -->

- **Platform**: All

<!-- The name of affected core module. -->

- **Subsystem**: loader

## Location

Modules: Packages

Affected URL(s):

- https://nodejs.org/api/packages.html#packages_exports

## Description

Under the ""history"" section, the docs say that conditional export support was added and also unflagged in 12.16, which doesn't seem to be the case. 12.17.0 appears to be the first version that supports conditional exports and I can't get either conditional exports or the `--experimental-conditional-exports` flag to work in 12.16.0.

![image](https://user-images.githubusercontent.com/2898433/99498789-1d811c80-29cc-11eb-9505-0978cad0b281.png)

---

- [x] I would like to work on this issue and
      submit a pull request.
","closed","gpoole",2898433,"{confirmed-bug,doc,esm}","https://github.com/nodejs/node/issues/36162",5,"Refatoração",NULL,482,"problema documentação api referência seção história documentação indicar suporte exportação condicional adicionar desativar versão parecer caso versão aparecer primeira versão suporte exportação condicional conseguir exportação condicional sinal experimental conditional exports funcionar versão
","A issue trata de problemas na documentação da API ( ""problema documentação api referência seção história documentação indicar suporte exportação condicional"").  A menção à versão e a necessidade de correções na documentação para refletir corretamente o suporte à exportação condicional sugerem uma tarefa de refatoração da documentação, sem menção direta a testes de regressão."
136,54057,"2024-07-26 10:48:37","2024-07-30 04:38:22","2024-07-30 09:37:09","`console.timeEnd` and `console.timeLog` throw when using `--frozen-intrinsics`","### Version

v22.5.1

### Platform

```text
Linux jfhr-ms7c80 6.1.0-18-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.76-1 (2024-02-01) x86_64 GNU/Linux
```


### Subsystem

console

### What steps will reproduce the bug?

demo.js:

```javascript
console.time('bunch-of-stuff')
console.timeEnd('bunch-of-stuff')
```

run:

```
node --frozen-intrinsics demo.js
```

### How often does it reproduce? Is there a required condition?

This always reproduces as far as I can tell. It is caused by the `console.timeEnd` / `console.timeLog` implementation

### What is the expected behavior? Why is that the expected behavior?

Expected behavior is what happens when running without `--frozen-intrinsics`:

```
$ node demo.js 
bunch-of-stuff: 0.061ms
```

### What do you see instead?

```
$ node --frozen-intrinsics demo.js 
node:internal/console/constructor:418
      this[kInternalTimeLogImpl] = FunctionPrototypeBind(timeLogImpl, this);
                                 ^

TypeError <Object <Object <[Object: null prototype] {}>>>: Cannot add property Symbol(kInternalTimeLogImpl), object is not extensible
    at console.timeLog (node:internal/console/constructor:418:34)
    at Object.<anonymous> (/home/jfhr/source/demo.js:2:9)
    at Module._compile (node:internal/modules/cjs/loader:1504:14)
    at Module._extensions..js (node:internal/modules/cjs/loader:1588:10)
    at Module.load (node:internal/modules/cjs/loader:1282:32)
    at Module._load (node:internal/modules/cjs/loader:1098:12)
    at TracingChannel.traceSync (node:diagnostics_channel:315:14)
    at wrapModuleLoad (node:internal/modules/cjs/loader:215:24)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:158:5)
    at node:internal/main/run_main_module:30:49

Node.js v22.5.1
```

### Additional information

The first call to `console.timeEnd` / `console.timeLog` tries to write to `this[kInternalTimeLogImpl]` (see [console/constructor.js](https://github.com/nodejs/node/blob/b32732b1ee48e09b3c6e48b36a4f01d5245a7c2a/lib/internal/console/constructor.js#L411)) which fails if `this` is frozen. This property stores the `timeLog` implementation that is passed to `util/debuglog`.

Perhaps a `WeakMap` could be used to store the `timeLog` implementation instead of a writable private property?","closed","jfhr",31999724,"{confirmed-bug,console}","https://github.com/nodejs/node/issues/54057",3,"Refatoração",NULL,4,"console timeEnd timeLog implement write property fail object extensible use WeakMap store implement property
","O título da issue sugere uma correção em como `console.timeEnd` e `console.timeLog` funcionam com a flag `--frozen-intrinsics`. O corpo da issue menciona implementação, armazenamento em WeakMap e propriedades, indicando uma mudança na estrutura interna do código, sem menção explícita a testes ou casos de teste. Os comentários são muito concisos e não fornecem mais informações relevantes para a classificação."
138,53902,"2024-07-17 18:20:56","2024-07-18 22:25:21","2024-07-23 02:09:14","Node 22.5.0 started to crash and hangs on different cases","### Version

22.5.0

### Platform

```text
macOS 15.0, M1
```

### What steps will reproduce the bug?

Now I haven't much time to properly debug it, so a couple of cases:

Clone [`core-js` repo](https://github.com/zloirock/core-js).

`npm i` just hangs on.

Ok, if we somehow install dependencies and run `npm test`, Node crashes with:
```
FATAL ERROR: v8::Object::GetCreationContextChecked No creation context available
----- Native stack trace -----

 1: 0x104a4e230 node::OnFatalError(char const*, char const*) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
 2: 0x104c20898 v8::Utils::ReportApiFailure(char const*, char const*) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
 3: 0x104c358fc v8::Object::GetCreationContextChecked() [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
 4: 0x104a55f88 node::fs::FastClose(v8::Local<v8::Object>, int, v8::FastApiCallbackOptions&) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
 5: 0x10b9accc4 
 6: 0x1056a6c0c Builtins_JSEntryTrampoline [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
 7: 0x1056a68f4 Builtins_JSEntry [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
 8: 0x104d50564 v8::internal::(anonymous namespace)::Invoke(v8::internal::Isolate*, v8::internal::(anonymous namespace)::InvokeParams const&) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
 9: 0x104d4fadc v8::internal::Execution::Call(v8::internal::Isolate*, v8::internal::Handle<v8::internal::Object>, v8::internal::Handle<v8::internal::Object>, int, v8::internal::Handle<v8::internal::Object>*) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
10: 0x104c369cc v8::Function::Call(v8::Local<v8::Context>, v8::Local<v8::Value>, int, v8::Local<v8::Value>*) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
11: 0x104970fa0 node::InternalMakeCallback(node::Environment*, v8::Local<v8::Object>, v8::Local<v8::Object>, v8::Local<v8::Function>, int, v8::Local<v8::Value>*, node::async_context) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
12: 0x104987d8c node::AsyncWrap::MakeCallback(v8::Local<v8::Function>, int, v8::Local<v8::Value>*) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
13: 0x104a53ca4 node::fs::FSReqCallback::Resolve(v8::Local<v8::Value>) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
14: 0x104a549a8 node::fs::AfterInteger(uv_fs_s*) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
15: 0x104a482fc node::MakeLibuvRequestCallback<uv_fs_s, void (*)(uv_fs_s*)>::Wrapper(uv_fs_s*) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
16: 0x105684a70 uv__work_done [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
17: 0x105688544 uv__async_io [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
18: 0x10569ab08 uv__io_poll [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
19: 0x105688b08 uv_run [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
20: 0x104971714 node::SpinEventLoopInternal(node::Environment*) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
21: 0x104a8f8f0 node::NodeMainInstance::Run(node::ExitCode*, node::Environment*) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
22: 0x104a8f688 node::NodeMainInstance::Run() [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
23: 0x104a15928 node::Start(int, char**) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
24: 0x18b2cf274 start [/usr/lib/dyld]


#
# Fatal error in , line 0
# Missing deoptimization information for OptimizedFrame::Summarize.
#
#
#
#FailureMessage Object: 0x16b488648
----- Native stack trace -----

 1: 0x104ab7a4c node::NodePlatform::GetStackTracePrinter()::$_3::__invoke() [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
 2: 0x105f3e5d4 V8_Fatal(char const*, ...) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
 3: 0x104d5993c v8::internal::OptimizedFrame::Summarize(std::__1::vector<v8::internal::FrameSummary, std::__1::allocator<v8::internal::FrameSummary>>*) const [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
 4: 0x104d62c60 v8::internal::Isolate::CaptureDetailedStackTrace(int, v8::StackTrace::StackTraceOptions) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
 5: 0x104c2ace0 v8::StackTrace::CurrentStackTrace(v8::Isolate*, int, v8::StackTrace::StackTraceOptions) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
 6: 0x104a4cc0c node::GetCurrentStackTrace(v8::Isolate*, int) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
 7: 0x1049b869c node::DumpJavaScriptBacktrace(__sFILE*) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
 8: 0x104a4e238 node::OnFatalError(char const*, char const*) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
 9: 0x104c20898 v8::Utils::ReportApiFailure(char const*, char const*) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
10: 0x104c358fc v8::Object::GetCreationContextChecked() [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
11: 0x104a55f88 node::fs::FastClose(v8::Local<v8::Object>, int, v8::FastApiCallbackOptions&) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
12: 0x10b9accc4 
13: 0x1056a6c0c Builtins_JSEntryTrampoline [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
14: 0x1056a68f4 Builtins_JSEntry [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
15: 0x104d50564 v8::internal::(anonymous namespace)::Invoke(v8::internal::Isolate*, v8::internal::(anonymous namespace)::InvokeParams const&) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
16: 0x104d4fadc v8::internal::Execution::Call(v8::internal::Isolate*, v8::internal::Handle<v8::internal::Object>, v8::internal::Handle<v8::internal::Object>, int, v8::internal::Handle<v8::internal::Object>*) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
17: 0x104c369cc v8::Function::Call(v8::Local<v8::Context>, v8::Local<v8::Value>, int, v8::Local<v8::Value>*) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
18: 0x104970fa0 node::InternalMakeCallback(node::Environment*, v8::Local<v8::Object>, v8::Local<v8::Object>, v8::Local<v8::Function>, int, v8::Local<v8::Value>*, node::async_context) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
19: 0x104987d8c node::AsyncWrap::MakeCallback(v8::Local<v8::Function>, int, v8::Local<v8::Value>*) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
20: 0x104a53ca4 node::fs::FSReqCallback::Resolve(v8::Local<v8::Value>) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
21: 0x104a549a8 node::fs::AfterInteger(uv_fs_s*) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
22: 0x104a482fc node::MakeLibuvRequestCallback<uv_fs_s, void (*)(uv_fs_s*)>::Wrapper(uv_fs_s*) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
23: 0x105684a70 uv__work_done [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
24: 0x105688544 uv__async_io [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
25: 0x10569ab08 uv__io_poll [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
26: 0x105688b08 uv_run [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
27: 0x104971714 node::SpinEventLoopInternal(node::Environment*) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
28: 0x104a8f8f0 node::NodeMainInstance::Run(node::ExitCode*, node::Environment*) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
29: 0x104a8f688 node::NodeMainInstance::Run() [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
30: 0x104a15928 node::Start(int, char**) [/Users/denispuskarev/.nvm/versions/node/v22.5.0/bin/node]
31: 0x18b2cf274 start [/usr/lib/dyld]
/bin/bash: line 1: 92352 Trace/BPT trap: 5       npm run build-compat
```
on [this script](https://github.com/zloirock/core-js/blob/master/scripts/build-compat/entries.mjs).

The same error happens, for example, if we somehow built it (for example, with the previous Node version) and run other scripts like [this](https://github.com/zloirock/core-js/blob/master/scripts/check-unused-modules.mjs).

In most of those cases used [`zx`](https://www.npmjs.com/package/zx) and / or [`konan`](https://www.npmjs.com/package/konan).

Sure, before Node 22.5.0, everything worked fine.","closed","zloirock",2213682,"{confirmed-bug,fs,""v8 engine"",regression,v22.x}","https://github.com/nodejs/node/issues/53902",47,"Ambos",NULL,1,"node crash fatal error creation context available npm install hang npm test run script build compat check unused modul zx konan node version work
","A issue relata crashes e hangs do Node.js (Node 22.5.0 started to crash and hangs on different cases), indicando um problema que necessita de refatoração para corrigir a causa raiz.  Ao mesmo tempo, há diversas menções a testes (npm test, run script build, test locally, reproducible test case, etc.),  e a busca por uma solução envolve testes de regressão para garantir que a correção não introduza novos problemas.  A combinação de ambos os aspectos sugere que a classificação seja 'Ambos'."
139,53868,"2024-07-16 13:25:04","2024-07-23 06:49:53","2024-07-23 06:49:53","test_runner: remove global event handlers after run is completed","https://github.com/nodejs/node/blob/362afa52ebe462a39874915e5e70d261db153c58/lib/internal/test_runner/harness.js#L182-L188 register some event handlers on process. After all the tests are finished, we should unregister them because multiple `run()` call could be done from the same process.

These warnings are currently shown by running 

```
$ ./node --expose-internals test/parallel/test-runner-run.mjs
(node:50708) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 11 uncaughtException listeners added to [process]. MaxListeners is 10. Use emitter.setMaxListeners() to increase limit
(Use `node --trace-warnings ...` to show where the warning was created)
(node:50708) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 11 unhandledRejection listeners added to [process]. MaxListeners is 10. Use emitter.setMaxListeners() to increase limit
(node:50708) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 11 beforeExit listeners added to [process]. MaxListeners is 10. Use emitter.setMaxListeners() to increase limit
▶ require('node:test').run
  ✔ should run with no tests (123.090125ms)
  ✔ should fail with non existing file (129.730834ms)
/Users/matteo/Repositories/node/test/fixtures/test-runner/shards/a.cjs
  ✔ should succeed with a file (300.698708ms)
/Users/matteo/Repositories/node/test/fixtures/test-runner/shards/f.cjs
  ✔ should run same file twice (435.653792ms)
  ✔ should run a failed test (271.949208ms)
  ✔ should support timeout (208.373834ms)
  ✔ should be piped with dot (309.843ms)
  ▶ should be piped with spec reporter
    ✔ new spec (306.557334ms)
    ✔ spec() (295.876667ms)
    ✔ spec (283.325875ms)
  ▶ should be piped with spec reporter (314.147333ms)
  ✔ should be piped with tap (308.117917ms)
  ✔ should skip tests not matching testNamePatterns - RegExp (305.547959ms)
  ✔ should skip tests not matching testNamePatterns - string (301.231583ms)
  ✔ should pass only to children (310.300084ms)
  ✔ should emit ""test:watch:drained"" event on watch mode (113.593959ms)
  ▶ AbortSignal
    ✔ should accept a signal (105.751667ms)
    ✔ should stop watch mode when abortSignal aborts (290.386167ms)
    ✔ should abort when test succeeded (300.463708ms)
    ✔ should abort when test failed (310.130792ms)
  ▶ AbortSignal (314.604833ms)
  ▶ sharding
    ▶ validation
      ✔ should require shard.total when having shard option (7.7285ms)
      ✔ should require shard.index when having shards option (1.060042ms)
      ✔ should require shard.total to be greater than 0 when having shard option (1.074709ms)
      ✔ should require shard.index to be greater than 0 when having shard option (0.914833ms)
      ✔ should require shard.index to not be greater than the shards total when having shard option (0.867417ms)
      ✔ should require watch mode to be disabled when having shard option (0.930333ms)
    ▶ validation (58.07875ms)
    ✔ should run only the tests files matching the shard index (401.742875ms)
    ✔ different shards should not run the same file (426.680209ms)
    ✔ combination of all shards should be all the tests (439.040334ms)
  ▶ sharding (454.904625ms)
  ▶ validation
    ✔ should only allow array in options.files (83.029041ms)
    ✔ should only allow object as options (81.610708ms)
    ✔ should pass instance of stream to setup (281.134208ms)
  ▶ validation (299.106417ms)
  ✔ should run with no files (119.761708ms)
  ℹ 'only' and 'runOnly' require the --test-only command-line option.
  ✔ should run with no files and use spec reporter (115.012084ms)
  ✔ should run with no files and use dot reporter (114.977625ms)
  ✔ should avoid running recursively (296.492291ms)
▶ require('node:test').run (474.936791ms)
▶ forceExit
  ✔ throws for non-boolean values (0.275833ms)
  ✔ throws if enabled with watch mode (0.088125ms)
▶ forceExit (0.436042ms)
ℹ tests 37
ℹ suites 7
ℹ pass 37
ℹ fail 0
ℹ cancelled 0
ℹ skipped 0
ℹ todo 0
ℹ duration_ms 479.010458
```","closed","mcollina",52195,"{confirmed-bug,""good first issue"",test_runner}","https://github.com/nodejs/node/issues/53868",4,"Refatoração",NULL,7,"memory leak detect uncaughtException listener add process MaxListeners use emitter setMaxListeners increase limit unhandledRejection listener add process MaxListeners use emitter setMaxListeners increase limit beforeExit listener add process MaxListeners use emitter setMaxListeners increase limit run test succeed file run same file twice run fail test support timeout pipe dot pipe spec reporter pipe tap skip test match testNamePatterns regexp string pass child emit test watch drain event watch mode abortsignal accept signal stop watch mode abortsignal abort abort test succeed abort test fail shard require shard total shard option require shard index shard option require shard total greater shard option require shard index greater shard option require shard index greater shard total shard option require watch mode disable shard option run test file match shard index different shard run file combination shard test validation allow array option file allow object option pass instance stream setup run file use spec reporter use dot reporter avoid run recursively throw boolean value throw enable watch mode test suite pass fail cancel skip todo duration
","O título da issue ""test_runner: remove global event handlers after run is completed"" e o corpo da issue indicam claramente uma atividade de refatoração.  O texto menciona remoção de handlers de eventos globais para corrigir vazamento de memória,  o que é uma tarefa típica de refatoração focada em melhorar a performance e estabilidade do código, sem adicionar novas funcionalidades ou testes diretos.  Os comentários não fornecem informações relevantes para mudar esta classificação."
141,53742,"2024-07-06 09:37:53","2024-09-06 22:07:18","2024-09-06 22:07:18","Node silently allows using dh and x25519 keys for signing / verification","### Version

v22.4.0

### Platform

Linux pop-os 6.9.3-76060903-generic #202405300957~1718348209~22.04~7817b67 SMP PREEMPT_DYNAMIC Mon J x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

crypto

### What steps will reproduce the bug?

```js
import crypto from 'node:crypto';

const { privateKey, publicKey } = crypto.generateKeyPairSync('x25519', {});

const sign = crypto.createSign('sha512');
sign.update('some data to sign');
sign.end();
const signature = sign.sign(privateKey);
console.log('Signature:', signature.toString('hex'));

const verify = crypto.createVerify('sha512');
verify.update('some data to sign');
verify.end();
console.log('Verify:', verify.verify(publicKey, signature));
```

Produces output like:



### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

Node throws an error that x25519 keys can not be used for signing. Same should happen for `dh` keys.

### What do you see instead?

```
Signature: 8603053600000000000000000000000000930436000000000000000000000000
Verify: false
```

(invalid output)

### Additional information

_No response_","closed","lucacasonato",7829205,"{confirmed-bug,crypto}","https://github.com/nodejs/node/issues/53742",1,"Nenhum",NULL,63,"versão plataforma linux subsystem crypto passo reproduzir erro node lançar erro x25519 chave usar assinatura acontecer dh chave esperar comportamento node lançar erro x25519 chave usar assinatura acontecer dh chave ver comportamento saída inválida informação adicional
","A issue descreve um problema de compatibilidade com chaves criptográficas (x25519 e DH) no Node.js.  Não há menção a refatoração de código ou a testes de regressão. O texto foca em um comportamento inesperado e um possível bug, não em atividades de desenvolvimento como refatoração ou testes."
142,53697,"2024-07-02 17:16:55","2024-10-15 20:07:29","2024-10-15 20:07:29","util.stripVTControlCharacters does not strip hyperlinks","### Version

22.4.0

### Platform

```text
Darwin moxy.lan 23.5.0 Darwin Kernel Version 23.5.0: Wed May  1 20:17:33 PDT 2024; root:xnu-10063.121.3~5/RELEASE_ARM64_T6031 arm64
```


### Subsystem

util

### What steps will reproduce the bug?

```
console.log(util.stripVTControlCharacters('\x1b]8;;http://example.com\x1b\\This is a link\x1b]8;;\x1b\\ hello'))
```

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

Should output:

```
This is a link hello
```

(With ""This is a link"" not hyperlinked.)

### What do you see instead?

```
ttp://example.comThis is a link;; hello
```

### Additional information

OCS codes are a bit tricky to capture and strip, but this is what I'm using in ansi-to-pre:

```
/\u001B\]8;;(.*?)(?:\u001B\\|\u0007)(.*?)\u001B]8;;(?\u001B\\|\u0007)/
```

Adding `str.replaceAll(/\u001b\]8;;(.*?)(?:\u001b\\|\u0007)(.*?)\u001b]8;;(?:\u001b\\|\u0007)/g, '$2')` should do the right thing, but not sure if there's some better way to do it in context.","closed","isaacs",9287,"{confirmed-bug,util}","https://github.com/nodejs/node/issues/53697",11,"Ambos",NULL,105,"version 22.4 platform darwin subsystem util step reproduce bug console log util strip vtcontrolcharacter link expect behavior output link hello see instead ttp link hello additional information ocs code tricky capture strip use ansi pre add str replaceall right thing sure better way context
","A issue relata um bug no código que remove caracteres ANSI de strings, incluindo links. Os comentários discutem a necessidade de atualizar a expressão regular usada para corrigir o bug e a adição de testes para garantir que a correção funcione.  A solução envolve tanto refatoração do código (atualizando a regex) quanto testes de regressão (testes para garantir que a nova regex funcione corretamente e não quebre outras funcionalidades)."
143,53461,"2024-06-15 01:13:47","2024-07-17 09:22:43","2024-07-17 09:22:43","[--env-file] Space between = and "" will cause the value to be parsed as an unquoted string","Meaning if you have this in your `.env` file:

```dotenv
FOO= ""BAR""
```

This command:

```bash
node --env-file=.env -e 'console.log({ FOO: process.env.FOO })'
```

Will print this:

```JavaScript
{ FOO: '""BAR""' }
```

I.e. the variable value includes the quotes. (The spaces aren't included in the value, though.) I think this is unexpected.

If this is not intentional there needs to be white space skipping before this line:

https://github.com/nodejs/node/blob/9495a2bf1f20f853e90c8208741ad53448df986a/src/node_dotenv.cc#L153","closed","panzi",134175,"{confirmed-bug,dotenv}","https://github.com/nodejs/node/issues/53461",15,"Ambos",NULL,32,"variável valor incluir aspas espaço incluir valor inesperado intencional espaço branco pular linha
","O título da issue indica um problema de parsing de strings em um arquivo .env, sugerindo uma necessidade de refatoração no código que trata este arquivo.  Os comentários discutem implementações alternativas em diferentes linguagens (C++, Node.js, Rust),  a necessidade de testes de regressão para garantir compatibilidade com o comportamento original do analisador dotenv, e a criação de uma especificação formal do comportamento esperado.  A menção a 'edge cases',  'bugs', e a necessidade de corrigir o comportamento em diferentes implementações reforça a necessidade de testes de regressão e refatoração do código."
144,53423,"2024-06-12 02:44:29","2024-06-17 13:30:25","2024-06-17 13:30:25","`deepStrictEqual` fails for Sets that contain both object references and equivalent object values","### Version

v20.0.0

### Platform

Darwin MacBookPro2019.local 22.6.0 Darwin Kernel Version 22.6.0: Wed Oct  4 21:25:26 PDT 2023; root:xnu-8796.141.3.701.17~4/RELEASE_X86_64 x86_64

### Subsystem

_No response_

### What steps will reproduce the bug?

Run the following JavaScript in Node v20:
```js
const x = ['x'];
assert.deepStrictEqual(new Set([x, ['y']]), new Set([x, ['y']])); // AssertionError
```

An AssertionError is reported, which is unexpected.

### How often does it reproduce? Is there a required condition?

It is reproducible 100% of the time. It is not reproducible in v18.20.2, but reproducible starting in v20. No required condition.

### What is the expected behavior? Why is that the expected behavior?

The expected behavior is that the assertion should pass. Both sets contain a reference to `x` (reference-equal) and also a new object `['y']` (deep-equal), so the sets should be deeply equal.

### What do you see instead?

An assertion error is reported:

> AssertionError [ERR_ASSERTION]: Values have same structure but are not reference-equal:
> ```
> Set(2) {
>   [
>     'x'
>   ],
>   [
>     'y'
>   ]
> }
> ```


### Additional information

The bug occurs only when comparing `Set` objects, with a mix of elements where some elements are objects compared by reference (===) and other elements are objects compared by deep equality.

I believe it was introduced by #46593. Looking at the changed code, a new ""SafeSet"" is created only containing the values (of type `'object'`) in `a` that are not in `b`. So this SafeSet only contains `['y']`. But then on [line 468 of comparisons.js](https://github.com/nodejs/node/pull/46593/files#diff-bf43bcaa5596c38bf749716194186c2f0be79712e737752d9bb2d63830c2c4d5R468), `for (const val of b)`, *every* value of `b` is checked, including the reference `x`, which causes the failure because the SafeSet does not contain it.","closed","chharvey",1362083,"{confirmed-bug}","https://github.com/nodejs/node/issues/53423",8,"Ambos",NULL,5,"assertion error set object reference deep equality nodejs version javascript v20 unexpected behavior reproducible v18 safe set comparison line  file  github  object type
","O título da issue indica um problema de comportamento inesperado (`deepStrictEqual` falhando para Sets com referências de objetos e valores de objetos equivalentes), sugerindo a necessidade de refatoração para corrigir o bug. Os comentários, por sua vez, discutem a investigação e solução do problema, incluindo testes de regressão para verificar a correção (`verify issue occur node 18 occur systematically node 20`, `run benchmark option see less impact`).  A menção a testes e a necessidade de correção de código apontam para a necessidade de ambos, refatoração e testes de regressão."
295,42157,"2022-02-28 23:39:40","2022-03-03 04:53:59","2022-03-03 04:53:59","Creating Transform from stream/web.TransformStream emits ERR_INVALID_ARG_TYPE on third write","### Version

17.6.0

### Platform

Darwin moxy.lan 21.3.0 Darwin Kernel Version 21.3.0: Wed Jan  5 21:37:58 PST 2022; root:xnu-8019.80.24~20/RELEASE_ARM64_T6000 arm64

### Subsystem

stream, stream/web

### What steps will reproduce the bug?

```js
const { TransformStream: WebTS } = require('stream/web')
const { Transform: NodeTS } = require('stream')

const s = NodeTS.fromWeb(new WebTS())
s.pipe(process.stderr)
s.write(Buffer.from('hello'))
s.write(Buffer.from('hello'))
s.write(Buffer.from('hello'))
s.write(Buffer.from('hello'))
s.write(Buffer.from('hello'))
s.end()

/*
hellonode:events:505
      throw er; // Unhandled 'error' event
      ^

TypeError [ERR_INVALID_ARG_TYPE]: The ""chunk"" argument must be of type string or an instance of Buffer or Uint8Array. Received an instance of Object
    at new NodeError (node:internal/errors:372:5)
    at readableAddChunk (node:internal/streams/readable:266:13)
    at Duplex.Readable.push (node:internal/streams/readable:234:10)
    at node:internal/webstreams/adapters:719:20
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
Emitted 'error' event on Duplex instance at:
    at emitErrorNT (node:internal/streams/destroy:164:8)
    at emitErrorCloseNT (node:internal/streams/destroy:129:3)
    at processTicksAndRejections (node:internal/process/task_queues:83:21) {
  code: 'ERR_INVALID_ARG_TYPE'
}

Node.js v17.6.0
*/
```

### How often does it reproduce? Is there a required condition?

always

### What is the expected behavior?

Should print ""hellohellohellohellohello"" to stderr.

### What do you see instead?

```
hellonode:events:505
      throw er; // Unhandled 'error' event
      ^

TypeError [ERR_INVALID_ARG_TYPE]: The ""chunk"" argument must be of type string or an instance of Buffer or Uint8Array. Received an instance of Object
    at new NodeError (node:internal/errors:372:5)
    at readableAddChunk (node:internal/streams/readable:266:13)
    at Duplex.Readable.push (node:internal/streams/readable:234:10)
    at node:internal/webstreams/adapters:719:20
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
Emitted 'error' event on Duplex instance at:
    at emitErrorNT (node:internal/streams/destroy:164:8)
    at emitErrorCloseNT (node:internal/streams/destroy:129:3)
    at processTicksAndRejections (node:internal/process/task_queues:83:21) {
  code: 'ERR_INVALID_ARG_TYPE'
}

Node.js v17.6.0
```

### Additional information

_No response_","closed","isaacs",9287,"{confirmed-bug,stream,""web streams""}","https://github.com/nodejs/node/issues/42157",0,"Ambos",NULL,2,NULL,"A issue descreve um erro (ERR_INVALID_ARG_TYPE) em um `TransformStream` no Node.js, especificamente na conversão entre `stream/web` e `stream`.  A correção envolveria tanto refatoração do código que lida com a conversão entre os tipos de stream (para resolver o problema de tipo incorreto), quanto a adição ou atualização de testes de regressão para prevenir que o erro ocorra novamente em futuras versões.  O erro indica uma falha fundamental no processamento, justificando ambos os tipos de ação."
146,52797,"2024-05-02 12:50:51","2024-09-19 06:33:04","2024-09-19 09:48:14","Maglev on x64 causes segmentation fault while running TypeScript","### Version

v22.0.0

### Platform

Linux vali 6.8.0-76060800daily20240311-generic #202403110203~1714077665~22.04~4c8e9a0 SMP PREEMPT_DYNAMIC Thu A x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

_No response_

### What steps will reproduce the bug?

On Linux using Node.js 22:

```sh
git clone git@github.com:remcohaszing/typescript-bug-58369.git
cd typescript-bug-58369
npm ci
tsc
```

See also this failed GitHub action: https://github.com/remcohaszing/typescript-bug-58369/actions/runs/8899456400/job/24438867767

### How often does it reproduce? Is there a required condition?

For this reproduction it’s reproduced consistently on Linux on both my machine and GitHub actions.

While troubleshooting by trimming down the content of `node_modules/@types/mdast/index.d.ts`, I got into a state where it seemed to happen randomly. The major factor is the `👉` emoji in a comment.

The error did not occur on macOS in the GitHub action, but it did happen consistently for @wooorm on their macbook.

The problem was not reproducible on Windows.

### What is the expected behavior? Why is that the expected behavior?

No segmentation fault

### What do you see instead?

```
Segmentation fault (core dumped)
```

### Additional information

This was originally reported to TypeScript: https://github.com/microsoft/TypeScript/issues/58369. This issue contains more information.

This has coincidentally already been fixed for the upcoming TypeScript 5.5. Still, a segfault should not occur.

We were unable to make a smaller reproduction.","closed","remcohaszing",779047,"{confirmed-bug,""v8 engine"",regression,linux,v22.x}","https://github.com/nodejs/node/issues/52797",45,"Ambos",NULL,140,"linux node js segfault typescript emoji github action reprodução consistente máquina consistente macbook windows problema reproduzir menor reprodução  segmentação falha corrigido typescript  
","O título e o corpo da issue indicam um problema de segmentação (segfault) ao executar o TypeScript em um ambiente x64,  sugerindo um bug em uma versão específica do Node.js ou do V8 (motor JavaScript do Chrome). Os comentários discutem tentativas de reprodução, depuração, investigação da causa raiz (possível problema no compilador Maglev do V8 ou em otimizações de inlining),  proposta de testes adicionais e até mesmo a sugestão de reportar um bug no V8.  A menção a 'regression' em um comentário reforça a possibilidade de uma regressão, e a busca por uma solução envolve tanto depuração (Refatoração) quanto testes (Testes de Regressão) para isolar e corrigir o problema. "
148,52740,"2024-04-28 22:54:01","2024-05-08 11:37:09","2024-05-08 11:37:09","node --run doesn't split additional params","### Version

v22.0.0

### Platform

Linux penguin 6.6.21-01327-gc9107f2d4947 #1 SMP PREEMPT_DYNAMIC x86_64 GNU/Linux

### Subsystem

`node --run`

### What steps will reproduce the bug?

```sh
mkdir nodeRunBug
cd nodeRunBug
echo 'console.log(process.argv)' > script.js
echo '{""scripts"":{""test"":""node script.js""}}' > package.json
node --run test -- A B
```


### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior? Why is that the expected behavior?

```
[ '/usr/bin/node', '/home/alex/nodeRunBug/script.js', 'A', 'B' ]
(node:8670) ExperimentalWarning: Task runner is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
```

### What do you see instead?

```
[ '/usr/bin/node', '/home/alex/nodeRunBug/script.js', 'A B' ]
(node:8670) ExperimentalWarning: Task runner is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
```

### Additional information

```console
$ npm run test -- A B

> test
> node script.js A B

[ '/usr/bin/node', '/home/alex/nodeRunBug/script.js', 'A', 'B' ]
```","closed","alexsch01",5721147,"{confirmed-bug,cli}","https://github.com/nodejs/node/issues/52740",3,"Ambos",NULL,10,"node run test argumento espaço argumento esperado array completo ver array incompleto argumento espaço argumento experimental warning
","O título da issue ""node --run doesn't split additional params"" sugere um problema de funcionamento do comando 'node run', indicando uma necessidade de refatoração no código para corrigir o comportamento. Os comentários, especialmente ""node run test a b node script js a b experimental warning task runner experimental feature change time"", demonstram testes de regressão sendo executados para verificar se a correção funciona como esperado após as alterações. A presença de ambos os aspectos (refatoração e testes) justifica a classificação 'Ambos'."
198,49075,"2023-08-09 00:41:32","2023-10-22 21:20:53","2023-10-22 21:20:53","Segmentation Fault on Contextifying MessagePort Transferred to a Worker Thread","### Version

* v17.1.0
* v18.14.2
* v19.9.0

### Platform

* `Linux WORKSTATION 5.15.90.1-microsoft-standard-WSL2 #1 SMP Fri Jan 27 02:56:13 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux`
* `Microsoft Windows NT 10.0.19045.0 x64`

### Subsystem

vm, maybe node:internal/per_context

### What steps will reproduce the bug?

1. Create a `MessagePort`
2. Create a `Worker` and transfer the message port to the worker.
3. Create a VM context and contextify the message port
4. (Sometimes) Attempt to access the contextified message port

Sample code to reproduce

```js
/* eslint-disable */
const { Worker } = require('node:worker_threads');

const messageChannel = new MessageChannel();

const text = `
const vm = require('node:vm');
const {
	isMainThread,
	moveMessagePortToContext,
	workerData,
} = require('node:worker_threads');

const context = Object.create(null);

context.console = console;

vm.createContext(context, {
    codeGeneration: {
        strings: false,
        wasm: false,
    },
});

console.log('[WT] messagePort ctor:', workerData.messagePort.constructor.name);

const messageChannel = new MessageChannel();
messageChannel.port1.onmessage = (ev) => {
	console.log('[WT] RECV MSG', ev.data);
	messageChannel.port1.close();
};

context.messagePort = moveMessagePortToContext(
    workerData.crash ? workerData.messagePort : messageChannel.port2,
    context,
);

// This vm.runInContext doesn't seem entirely necessary to trigger the crash
// Sometimes just accessing the properties of 'messagePort' is required
vm.runInContext(
    \`
        console.log(""[VM] Started"");
        messagePort.postMessage(""Hello, World!"")
    \`,
    context,
    { displayErrors: true }
);
`;

// Change this to false to avoid crashing
// NOTE: Just transferring the MessagePort to the worker,
// without contextifying, or even using it from the worker
// does NOT trigger a crash and works as expected.
const crash = true;

new Worker(text, {
	workerData: {
		crash,
		messagePort: messageChannel.port2,
	},
	env: Object.create(null),
	eval: true,
	transferList: [messageChannel.port2],
});

if (crash) {
	messageChannel.port1.onmessage = (ev) => {
		console.log('[MAIN] RECV MSG', ev.data);
		messageChannel.port1.close();
	};
}
```

### How often does it reproduce? Is there a required condition?

It always reproduces. It sometimes (on Node 18 on Windows, apparently) requires accessing a property in the contextified port. Otherwise just contextifying the port is enough.

### What is the expected behavior? Why is that the expected behavior?

The port is contextified and usable, even across multiple contexts. At worst, an error should occur without crashing or aborting the Node process.

### What do you see instead?

Node crashes with a segmentation fault.

Sample output (Node 17)
```
[WT] messagePort ctor: MessagePort
[MAIN] RECV MSG Hello, World!
[VM] Started

Command terminated by signal 11
```

Sample output (Node 18)

```
[WT] messagePort ctor: MessagePort
```

Sample output (Node 19)

```
[WT] messagePort ctor: MessagePort
[MAIN] RECV MSG Hello, World!
[VM] Started
[1]    4551 segmentation fault  node sample.js
```


### Additional information

_No response_","closed","corrideat",3857362,"{confirmed-bug,worker}","https://github.com/nodejs/node/issues/49075",2,"Ambos",NULL,75,"worker messageport contextify crash segmentation fault node version platform linux windows subsystem vm node worker thread messagechannel port postmessage context property access messageport property node version  expected behavior port contextify usable context error crash node process instead node crash segmentation fault sample output node version  additional information
","O título da issue ""Segmentation Fault on Contextifying MessagePort Transferred to a Worker Thread"" indica um problema de funcionamento (crash, segmentation fault).  O corpo da issue descreve detalhes técnicos do problema, incluindo versões do Node.js e plataformas afetadas. Os comentários sugerem uma investigação e uma possível correção (""investigate send possible fix""), indicando que o problema precisa ser resolvido e possivelmente implica em refatoração do código para corrigir o bug.  A menção de um 'repro case' sugere que testes de regressão serão necessários para garantir que a correção não introduza novos problemas. Portanto, a issue envolve tanto refatoração quanto testes de regressão."
152,52448,"2024-04-10 11:47:11","2024-09-20 17:59:23","2024-09-20 17:59:23","Typo in error code ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED","### Version

v21.7.2

### Description

One of the error codes, `ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED`, misspells ""identity"". The code was introduced in 2019 when PSK support got added in #23188.

The issue is purely cosmetic since [all other sources and documents](https://github.com/search?q=repo%3Anodejs%2Fnode%20ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED&type=code) reference the correct (i.e. misspelled) code.

### Additional information

It's probably too late (or simply not worth it) to fix it now, so I'm filing this issue mostly for posterity.","closed","mootari",322014,"{confirmed-bug,tls,errors}","https://github.com/nodejs/node/issues/52448",2,"Refatoração",NULL,163,"erro código identidade ortografia introduzir psk suporte problema cosmético fonte documento referência código correto tarde valer corrigir arquivo questão posteridade
","O título e o corpo da issue mencionam um erro de digitação (typo) no código de erro.  A descrição indica um problema cosmético e sugere a correção de um arquivo, o que se enquadra em uma tarefa de refatoração. Os comentários focam na resolução do problema e na integração do código corrigido, sem menção a testes de regressão."
154,52362,"2024-04-04 07:42:11","2024-04-05 16:01:09","2024-04-05 16:01:09","Comments in .env aren't ignored by loadEnvFile()","### Version

20.12.0

### Platform

Linux xxx 5.15.146.1-microsoft-standard-WSL2 #1 SMP Thu Jan 11 04:09:03 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

_No response_

### Description

`process.loadEnvFile()` doesn't ignore (first) comment line.

### What steps will reproduce the bug?



Create an example `.env` file with two comments

```text
#FOO=123
#BAR=456
```

and run the following code snippet

```javascript
process.loadEnvFile();

console.log(""FOO"", process.env.FOO);
console.log(""BAR"", process.env.BAR);
```

Example repo: https://github.com/steffen-4s1/dotenv

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

All comment lines should be ignored.

```text
FOO undefined
BAR undefined
```

### What do you see instead?

`FOO` isn't ignored.

```text
FOO 123
BAR undefined
```

### Additional information

_No response_","closed","steffen-4s1",33749463,"{confirmed-bug,dotenv}","https://github.com/nodejs/node/issues/52362",1,"Nenhum",NULL,1,"process loadEnvFile ignor comment linha criar exemplo env file dois comment run codigo snippet process loadEnvFile console log FOO process env FOO console log BAR process env BAR comment linha ignorar FOO undefined BAR undefined FOO ignorar FOO 123 BAR undefined
","O título e o corpo da issue descrevem um problema com o processamento de comentários em arquivos .env,  não havendo menção a refatoração de código ou testes de regressão. O comentário 'duplicate issue' não fornece informações relevantes para a classificação."
155,52298,"2024-04-01 02:07:41","2024-09-06 17:39:25","2024-09-06 17:39:25","Buffer.toString() cannot handle large indices","### Version

14.17.3

### Platform

23.4.0 Darwin Kernel Version 23.4.0

### Subsystem

_No response_

### What steps will reproduce the bug?

```js
let buffer = Buffer.alloc(2279415336);

let res = buffer.toString('utf8', 2147483648, 2147483700); // 2^32 - 1 < start

// buffer.js:605
//     slice: (buf, start, end) => buf.utf8Slice(start, end),
                                    ^

// RangeError: Index out of range
```

### How often does it reproduce? Is there a required condition?

everytime

### What is the expected behavior? Why is that the expected behavior?

`Buffer.toString()` should be able to handle buffers smaller than `kMaxLength`.

### What do you see instead?

index out of range error

### Additional information

The bitwise or assignment (`|=`) operation of `Buffer.toString()` seems to be the cause of the error. If start or end parameter greater than `INT_MAX` is passed, the value changes to a negative number, resulting in an index out of range error.","closed","imyp92",26646765,"{confirmed-bug,buffer}","https://github.com/nodejs/node/issues/52298",5,"Ambos",NULL,159,"buffer range error index  int max bitwise assignment operation cause parameter pass value change negative number result
","O título da issue indica um problema de erro de índice ('Buffer.toString() cannot handle large indices'), sugerindo a necessidade de refatoração no código para lidar corretamente com índices grandes. Os comentários, no entanto, discutem a necessidade de verificação de limites ('perform bound check') para evitar o erro, indicando a necessidade de testes de regressão para garantir que a correção não introduza novos problemas. Portanto, a issue envolve tanto refatoração quanto testes de regressão."
314,40377,"2021-10-08 15:07:26","2021-12-22 17:11:34","2021-12-22 17:11:34","Writable is destroyed before calling callback in rare case","### Version

v16.10.0

### Platform

`Linux solus 5.14.7-198.current #1 SMP PREEMPT Wed Sep 22 16:02:46 UTC 2021 x86_64 GNU/Linux`

### Subsystem

stream

### What steps will reproduce the bug?

```js
const {Writable} = require('stream');

class X extends Writable {
    async _destroy(error, callback) {
        (async () => {
            await new Promise(resolve => setTimeout(resolve, 10));
            console.log(w._writableState.closed);

            callback(error);
        })();
    }
}

const w = new X();

w.once('error', error => {
    console.log(error);
});

w.destroy(new Error('oh no!'));
```

### How often does it reproduce? Is there a required condition?

Always.

### What is the expected behavior?

```
false
Error: oh no!
```

### What do you see instead?

```
true
```

### Additional information

Some [undocumented](https://nodejs.org/api/stream.html#stream_writable_destroy_err_callback) behavior here:

https://github.com/nodejs/node/blob/aff2a0a4754ddba26e161bc66cd4392fc28dd146/lib/internal/streams/destroy.js#L101-L118","closed","szmarczak",36894700,"{confirmed-bug,doc,stream,""good first issue"",linux}","https://github.com/nodejs/node/issues/40377",15,"Ambos",NULL,75,NULL,"A issue relata um problema de comportamento inesperado na função `_destroy` de um objeto `Writable` em Node.js,  envolvendo o uso de promises e callbacks simultaneamente.  Isso indica um bug que precisa de correção (Refatoração).  Além disso, os comentários discutem a necessidade de testes para garantir que o comportamento esteja de acordo com a documentação e para evitar situações similares no futuro (Testes de Regressão). Portanto, a issue abrange tanto refatoração quanto testes de regressão."
157,52248,"2024-03-28 11:28:35","2024-04-17 05:30:08","2024-04-27 13:06:03","Loading long env value from a file is crashing Node on Windows","### Version

20.12.0

### Platform

Windows 11

### Subsystem

process

### What steps will reproduce the bug?

Try loading .env file with the following entry in it:

```
JWT_PUBLIC_KEY=""-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAzi4k4ful8Q65RWbHvZwD
jKNfspb89typkUATf8KXlYcWp6ibUG9nKpYrig3jmlCdMvCm+S7kZedACshFyRmm
1ocaWjRIt/jJyzntxnMIgWetTedZXXzlFbparDMrdEMmsPbM7LrByCU57iKloZEl
BhOSQZk/JbJK1YpozTCxcs28YlpnTuMBaXvXddrQuNHo+HYhK53XlFXyiOBzmEFY
cBrVqptdjA3z7uNNd6A4IAfEkRYp4lZxZgwTPyjYZ1oXmhalvbr6OAs9ujLIZPSM
QoP1VoHLdOqrs7QTmi2rrNCfIcFkFp02N39TovMm9zZQJjQvFEJqIKe4db2457vr
uJ5qxkWmbBu+/tf6ytKfbiA433neLSvpfquPXbq3OLGzJ4H2YHiHa0ddfUCqdN49
t5nCPEMp6OTa5kXuwObf8yvHyoP8HgQQD+/sftHUIE/1sdQ6fzB/9L+smzp5SW/X
nI8NY0k1SH9MLlweGuXi6M1jS62kPWk4HTDQmiqUTImcG0XYRrVd5ISXPdfnVgnq
KKht+SUmkPrfaWMDc21FsXXmmVSRTjvBhA6Cy6PLPzGZaeA4TVkOZUkp1OvcyfiI
HixuZca1OASxGeUM8lcPi9my8TJCtw5ZR0M/uqVV/1o3U0nx+U5z54ulWN9leMLY
vgv+lGrqfFWRemajGXSm8L0CAwEAAQ==
-----END PUBLIC KEY-----""
```

by running this code:
```js
import { loadEnvFile } from 'node:process'

loadEnvFile('./.env')
```

This fails with an error `Process finished with exit code -1073740791 (0xC0000409)`

### How often does it reproduce? Is there a required condition?

It is always reproduceable

### What is the expected behavior? Why is that the expected behavior?

The value should be loaded correctly. This works with `dotenv`.

### What do you see instead?

An error `Process finished with exit code -1073740791 (0xC0000409)`

### Additional information

_No response_","closed","kibertoad",1847934,"{confirmed-bug,windows,dotenv}","https://github.com/nodejs/node/issues/52248",13,"Ambos",NULL,20,"version 20.12 windows 11 subsystem process step reproduce bug try load env file following entry jwt public key value run code import loadenvfile node process loadenvfile env fail error process finish exit code 0xc0000409 often reproduce require condition always reproduceable expect behavior value load correctly work dotenv see instead error process finish exit code 0xc0000409 additional information
","A issue relata um erro de crash no Node.js em Windows ao carregar um arquivo de ambiente grande (Refatoração:  sugestões de soluções como ler o valor em chunks são apresentadas, indicando a necessidade de refatorar o código para lidar com grandes valores de variáveis de ambiente).  Ao mesmo tempo, há menções a testes falhando localmente e em CI (Testes de Regressão:  Comentários como ""confirm happen windows test fail local"" e ""reproduce node windows ci"" indicam a necessidade de testes de regressão para garantir que a correção funcione em diferentes ambientes)."
158,52112,"2024-03-16 10:52:59","2024-03-18 16:29:37","2024-03-18 16:29:37","test_runner: skip beforeEach and afterEach hooks if test is skipped","### What is the problem this feature will solve?

Currently beforeEach and afterEach hooks are run even for tests that are skipped.
This becomes problematic when there are many hooks that are expensive to run and one wants to run only a few tests.

Consider case:
```js
beforeEach(() => {
    expensiveSetup();
});
afterEach(() => {
    expensiveTeardown();
});
test('test1', () => {
    expensiveTest1();
});
test('test2', () => {
    expensiveTest2();
});
```
Now `--test-name-pattern test1` will run both hooks twice or even if no test is run (both skipped) they will still be run twice.

It would be logical to assume that if the test is skipped, then before/afterEach hook is also skipped for that test. This is in fact the behavior in other popular js test runners such as mocha and jest.

Also, current documentation says that:
>The [--test-name-pattern](https://nodejs.org/api/cli.html#--test-name-pattern) command-line option can be used to only run tests whose name matches the provided pattern. (...)
For each test that is executed, any corresponding test hooks, such as beforeEach(), are also run.

Even though it is not explicitly said that beforeEach() would be skipped if test is _not_ executed, I think this implies that, because otherwise that statement would be useless, if test hooks are ran regardless of whether test is filtered in or out.

### What is the feature you are proposing to solve the problem?

If test case is skipped, beforeEach and afterEach hooks for that case should also be skipped.

### What alternatives have you considered?

_No response_","closed","ArktinenKarpalo",5880180,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/52112",1,"Refatoração",NULL,2,"problema hook beforeEach afterEach executar teste pular problemático hook caro executar poucos teste caso hook caro executar teste pular hook executar lógico assumir teste pular hook pular comportamento popular js mocha jest documentação dizer test name pattern executar teste nome corresponder padrão teste executar hook beforeEach executar teste executar explicitamente dizer beforeEach pular teste executar implicar caso contrário afirmação inútil hook executar teste filtrar proposta teste pular hook beforeEach afterEach pular alternativa resposta
","O título e o corpo do texto da issue indicam uma proposta de melhoria na forma como os hooks `beforeEach` e `afterEach` são tratados quando um teste é pulado.  A descrição foca em otimizar o desempenho (evitando execução desnecessária de hooks caros) e melhorar a lógica de execução, sem mencionar diretamente a adição ou alteração de testes.  A palavra 'Refatoração' é implícita na busca por melhorar o código existente sem adicionar novas funcionalidades de teste."
159,52097,"2024-03-15 12:39:36","2024-04-08 06:18:44","2024-04-08 06:18:45","Ed25519/Ed448 does not throw when used with invalid digest in crypto.createSign","### What is the problem this feature will solve?

The following example:
```JavaScript
const crypto = require('crypto');

const key = crypto.generateKeyPairSync(""ed25519"");

var signature = crypto.sign(null, ""hello"", key.privateKey);
console.log(""crypto.sign:"", signature.toString('hex'));

var signer = crypto.createSign('SHA256');
signer.update('hello');
var signature = signer.sign(key.privateKey);
console.log(""signer.sign:"", signature.toString('hex'));
```
will output the following:
```sh
crypto.sign: d58fdfa69f9d0bf4fd5358a6ed22031af3585ce9812b2bde5a5045a4e3cefd719a5af771af85e5a0c406fd48852574debe4deb32845785b761c59978b21fa903
signer.sign: 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
```
When Signer is used for Ed25519 signing, Signer does not report any errors, but returns an all-zero Buffer as the signature result.
This can be confusing for programmers who think they have signed successfully, but in fact the returned signature is not available.

### What is the feature you are proposing to solve the problem?

I think in this case Signer.sign should throw an error so that the programmer can deal with the problem early on.

### What alternatives have you considered?

_No response_","closed","xicilion",26833060,"{confirmed-bug,crypto}","https://github.com/nodejs/node/issues/52097",4,"Ambos",NULL,24,"problema assinatura ed25519 retorna buffer zero programador pensa sucesso assinatura indisponível  proposta signer sign lançar erro programador lidar problema alternativa nenhuma resposta
","O título da issue indica um problema na assinatura digital (bug), sugerindo a necessidade de refatoração para corrigir o comportamento incorreto do `crypto.createSign`.  Os comentários reforçam a existência de um bug e a necessidade de lançar um erro em vez de retornar um buffer zero.  A necessidade de lidar com o problema e a menção de uma API 'oneshot' indicam que testes de regressão são necessários para garantir que a correção não introduza novos problemas e que a funcionalidade existente continue funcionando corretamente após a refatoração."
160,51993,"2024-03-06 22:38:54","2024-03-08 13:35:54","2024-03-26 18:45:18","fs.createWriteStream can cause out-of-order writes, in v18.16+","### Version

v18.16.0 and up, v19.8.0 and up, v20.x, v21.x

### Platform

Darwin x86_64

### Subsystem

fs, stream

### What steps will reproduce the bug?

```js
const fs = require('fs');

const w = fs.createWriteStream('file.txt');

w.on('open', () => {
  w.write('hello');

  process.nextTick(() => {
    w.write('world');
    w.end();
  });
});

w.on('close', () => {
  console.log(fs.readFileSync('file.txt', 'utf8'));
});
```

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

```helloworld```

### What do you see instead?

```worldhello```

### Additional information

The issue was caused by this change: https://github.com/nodejs/node/pull/46818, which landed in node `v18.16.0` and `v19.8.0`.
(Thanks to @Fadorico for tracking down this change. I have also confirmed this by building node locally.)

This is causing the ['unzipper' module](https://github.com/ZJONSSON/node-unzipper/issues/286) to create corrupted files, because its ['fstream' dependency](https://github.com/npm/fstream/blob/bffea43c6a201c76bc85842539e09a779508790b/lib/file-writer.js#L38-L44) uses `fs.createWriteStream()` like in the example above.

It looks like when the stream's ""open"" event fires, the stream does not yet have the ""constructed"" flag set, so that might be why things are getting weird.

As a workaround, if I wait an additional tick after the ""open"" event, there are no issues:
```js
w.on('open', () => {
  process.nextTick(() => {
    w.write('hello');

    process.nextTick(() => {
      w.write('world');
      w.end();
    });
  });
});
```","closed","dy-dx",1074881,"{confirmed-bug}","https://github.com/nodejs/node/issues/51993",3,"Ambos",NULL,2,"versão plataforma subsystem passo reproduzir erro comportamento esperado comportamento visto informação adicional problema causou mudança aterrissou causar módulo criar arquivo corrompido dependência usar exemplo cima parecer evento disparar stream ainda ter sinal construir coisa ficar estranho solução alternativa esperar adicional evento problema
","O título da issue indica um problema de funcionamento ('out-of-order writes') que necessita de correção (Refatoração).  Os comentários mencionam um patch e a confirmação da correção em uma versão do Node.js, indicando que testes de regressão foram realizados para validar a solução (Testes de Regressão). Portanto, a issue envolve ambos os aspectos."
298,41785,"2022-01-31 15:13:30","2022-02-06 10:05:52","2022-02-06 10:05:52","Readable.pipe() behaves inconsistently resuming (or not) the source","### Version

14.17.0

### Platform

Linux tufopad 5.4.0-91-generic #102-Ubuntu SMP Fri Nov 5 16:31:28 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

stream

### What steps will reproduce the bug?

Prior to v14.17.0 (versions <= v14.16.1), calling to `Readable.pipe()` would always resume the source if it had been previously paused. This behaviour was not documented, but it was consistent (it always happened). Since version 14.17.0 this behaviour changed and now it only resumes the source _in some cases_. If you run the following code
```js
const { PassThrough } = require('stream');

// FIRST EXPERIMENT
console.info('********** FIRST EXPERIMENT **********');
const source1 = new PassThrough();
const target1 = new PassThrough();

// `Readable.pipe()` resumes the source if it was previously paused
source1.pause();
console.info(`source1 before pipe. Paused: ${source1.isPaused()}`);
source1.pipe(target1);
console.info(`source1 after pipe. Paused: ${source1.isPaused()}`);

// SECOND EXPERIMENT
console.info('\n********** SECOND EXPERIMENT **********');
const source2 = new PassThrough();
const target2 = new PassThrough();

// stall target2
const chunk = Buffer.allocUnsafe(1000);
let chunks = 1;
while (target2.write(chunk)) chunks++;
console.info(`${chunks} chunks of ${chunk.length} bytes to stall target2`);

// `Readable.pipe()` DOES NOT resume the source if it was previously paused, but
// the target needs drain (only in version >= v14.17.0)
source2.pause();
console.info(`source2 before pipe. Paused: ${source2.isPaused()}`);
source2.pipe(target2);
console.info(`source2 after pipe. Paused: ${source2.isPaused()}`);
target2.on('drain', () => {   
  console.info('target2 drained');
  console.info(`source2 after drain. Paused: ${source2.isPaused()}`);
});
target2.on('data', () => {});
```
with version v14.16.1 you will get the following output
```text
********** FIRST EXPERIMENT **********
source1 before pipe. Paused: true
source1 after pipe. Paused: false

********** SECOND EXPERIMENT **********
34 chunks of 1000 bytes to stall target2
source2 before pipe. Paused: true
source2 after pipe. Paused: false
target2 drained
source2 after drain. Paused: false
```
whereas with version v14.17.0 you get
```text
********** FIRST EXPERIMENT **********
source1 before pipe. Paused: true
source1 after pipe. Paused: false

********** SECOND EXPERIMENT **********
34 chunks of 1000 bytes to stall target2
source2 before pipe. Paused: true
source2 after pipe. Paused: true
target2 drained
source2 after drain. Paused: true
```
In versions higher or equal to v14.17.0, the source is NOT resumed if the target needs a drain, and it does not resume even when the target drains. Furthermore, if the source wasn't paused, `Readable.pipe()` will pause it if the piped target needs to drain. This did not happen in versions <= v14.16.1.

The fact that `Readable.pipe()` decides if it should pause or resume the source depending on the status of the target looks a bit inconsistent to me, and if not fixed, I believe that at least it would need to be documented.


### How often does it reproduce? Is there a required condition?

It always happens

### What is the expected behavior?

It's a change of an undocumented behaviour, so it's hard for me to say what's the expected behaviour. The previous behaviour (resuming always the source) seemed a bit more consistent than the current

### What do you see instead?

Read the experiment described in the ""What steps will reproduce the bug?"" section

### Additional information

_No response_","closed","tufosa",5946180,"{confirmed-bug,stream}","https://github.com/nodejs/node/issues/41785",11,"Refatoração",NULL,6,NULL,"A issue relata uma mudança de comportamento na função `Readable.pipe()` a partir da versão 14.17.0 do Node.js.  O comportamento anterior, embora não documentado, era consistente. A mudança afeta como a função lida com a pausa e a retomada da fonte dependendo do estado do destino.  Embora haja discussão sobre se a mudança é um bug ou uma melhoria, a descrição foca principalmente na inconsistência introduzida e na necessidade de documentação ou correção do comportamento, caracterizando-a como uma refatoração do código existente para melhor consistência e clareza."
162,51725,"2024-02-11 20:44:07","2024-04-28 16:51:46","2024-04-28 16:51:46","Update ongoing promise in async iterator `return()` method","There's an edge case with [the current Web IDL bindings for async iterators](https://webidl.spec.whatwg.org/commit-snapshots/47c5c920811b1bfdd56304a9d8313766d482897b/#ref-for-asynchronous-iterator-return) where manually calling `return(); next()` could result in the `next()` promise resolving before the `return()` promise. The latest version of the Web IDL specification fixes this by updating the ""ongoing promise"" in the async iterator `return()` method.

For Node.js, this affects `ReadableStream.prototype[Symbol.asyncIterator]`. More specifically, this part needs to be changed: https://github.com/nodejs/node/blob/a8de25ed1523594dd6bf0ee08a24f146d38cb4e8/lib/internal/webstreams/readablestream.js#L547-L554

* [Web IDL spec change](https://github.com/whatwg/webidl/pull/1387)
* [Web platform tests](https://github.com/web-platform-tests/wpt/pull/44456) (for `ReadableStream[@@asyncIterator]`)","closed","MattiasBuelens",649348,"{confirmed-bug}","https://github.com/nodejs/node/issues/51725",3,"Refatoração",NULL,77,"edge case current web idl binding async iterator manually call return next promise resolve return promise late version web idl specification fix update ongoing promise async iterator return method node affect readablestream prototype symbol asynciterator part need change web idl spec change web platform test readablestream asynciterator
","O título ""Update ongoing promise in async iterator `return()` method"" e o corpo da issue indicam uma atualização em um método existente para melhorar o código.  As menções a mudanças na especificação web IDL e testes ('web platform test') sugerem uma atualização para melhor conformidade e não diretamente para adicionar novos testes de regressão.  Os comentários focam na implementação da solução e na sincronização com a especificação, reforçando a natureza de refatoração da issue."
163,51671,"2024-02-05 21:24:49","2024-03-30 02:58:12","2024-03-30 02:58:12","Order of nested vs outer `afterEach` hooks is unexpected and inconsistent with `after`","### Version

21.6.1

### Platform

darwin

### Subsystem

test runner

### What steps will reproduce the bug?

Create a file called `hooks.mjs` containing:

```js
import { describe, afterEach, after, it } from 'node:test';

describe('parent', () => {
  afterEach(() => console.log('parent after each'));
  after(() => console.log('parent after'));

  describe('child', () => {
    afterEach(() => console.log('child after each'));
    after(() => console.log('child after'));

    it('works', () => {});
  });
});
```

and run `node --test hooks.mjs`.

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

```
child after each
parent after each
child after
parent after
<test results>
```

As with `mocha`, `qunit`, `jest`, `vitest`, and probably others, a child suite's `afterEach` hooks should be called _before_ those of parent suites, not after them. Also, the execution order of parent/child `afterEach` hooks should match the order of parent/child `after` hooks.

Currently, `after` hooks correctly run child-first, but `afterEach` hooks run incorrectly parent-first.

### What do you see instead?

```
parent after each
child after each
child after
parent after
<test results>
```

### Additional information

This also reproduces with the `test()`/subtest API -- a test's `afterEach` hook will run before a subtest's `afterEach` hook. ","closed","bendemboski",559001,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/51671",2,"Testes de Regressão",NULL,53,"version platform darwin subsystem test runner step reproduce bug create file name hook mjs contain import describe aftereach after node test describe parent aftereach console log parent aftereach after console log parent after describe child aftereach console log child aftereach after console log child after work run node test hook mjs often reproduce require condition always expect behavior expect behavior child aftereach parent aftereach child after parent after test result mocha qunit jest vitest probably others child suite aftereach hook call before parent suite execution order parent child aftereach hook match order parent child after hook currently after hook correctly run child first aftereach hook run incorrectly parent first see instead parent aftereach child aftereach child after parent after test result additional information reproduce test subtest api test aftereach hook run before subtest aftereach hook
","A issue descreve um problema de ordem de execução inesperada e inconsistente de hooks `afterEach` aninhados em testes.  Os comentários reforçam a natureza do problema como um bug de execução em diferentes frameworks de teste (Mocha, Qunit, Jest, Vitest). A busca por reproduzir o bug e a menção de resultados de testes demonstram que se trata de um problema de regressão em testes existentes."
164,51593,"2024-01-29 12:25:31","2024-02-04 17:15:55","2024-02-04 17:15:56","Internal Assertion failed when parsing incorrect URL containing u200b Unicode character","### Version

v20.10.0

### Platform

Linux blackbox 6.7.1-arch1-1 #1 SMP PREEMPT_DYNAMIC Sun, 21 Jan 2024 22:14:10 +0000 x86_64 GNU/Linux

### Subsystem

url

### What steps will reproduce the bug?

Trying to parse this will crash the process instead of throwing an exception. Not sure what would be the intended behavior here:
```
u = new URL(""http://​123.123.123.123"")
u.username = """"
```
The URL contains a u200b unicode character in front of the first digit!

### How often does it reproduce? Is there a required condition?

Always reproducible

### What is the expected behavior? Why is that the expected behavior?

An exception that can be caught.

### What do you see instead?

Process crashes with 
```
node[1296311]: ../src/node_url.cc:309:static void node::url::BindingData::Update(const v8::FunctionCallbackInfo<v8::Value>&): Assertion `out' failed.
 1: 0x604dba5723d5 node::Abort() [node]
 2: 0x604dba572731 node::Assert(node::AssertionInfo const&) [node]
 3: 0x604dba64cd18 node::url::BindingData::Update(v8::FunctionCallbackInfo<v8::Value> const&) [node]
 4: 0x604dba7ec1f6  [node]
 5: 0x604dba7ecd92 v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) [node]
 6: 0x604dbb160df6  [node]
```

### Additional information

_No response_","closed","heipei",6072,"{confirmed-bug,whatwg-url}","https://github.com/nodejs/node/issues/51593",7,"Ambos",NULL,6,"crash processo excecao url unicode caractere processo abort assercao
","O título da issue indica um problema de parsing de URL com caracteres Unicode, sugerindo uma necessidade de refatoração no código de parsing.  Porém, o comentário ""test ipv4 address contain unicode character untested code path"" evidencia a necessidade de testes de regressão para cobrir o cenário identificado, garantindo que a correção não introduza novos problemas.  A combinação desses aspectos aponta para a necessidade de ambos, refatoração e testes de regressão."
300,41648,"2022-01-22 14:00:27","2022-01-27 16:53:00","2022-01-27 16:53:00","Iterator helpers throw the error too late","Currently iterator helpers throw type errors on first iteration - they should likely do so synchronously.

For example:

```js
Readable.from([1]).map(1); // returns a stream, for...awaiting it will throw the error
```

Instead I think we should throw synchronously, which is what I believe the spec says.


A fix would be to take the code in operators.js that does validations that is in an async generator and wrap it so that it does those validations in a function called before the async generator.

So instead of:

```js
async function* map(...) {
  validateFoo(...);
}
```

We'd do:

```js
function map(...) { // not async to throw synchronously
  validateFoo(...);
  return async function*() {

  }();
}
```

The test at test-stream-map would similarly need to be updated from rejecting asynchronously on iteration to throwing synchronously. I've opened an issue in the iterator helper proposal to be sure.

That's my understanding here: https://tc39.es/proposal-iterator-helpers/#sec-asynciteratorprototype.map","closed","benjamingr",1315533,"{confirmed-bug,stream}","https://github.com/nodejs/node/issues/41648",9,"Ambos",NULL,5,NULL,"O título e corpo da issue indicam a necessidade de corrigir um erro em que os helpers de iterador lançam exceções de forma assíncrona, ao invés de sincronamente como deveria ser.  Isso exige refatoração do código para que as validações sejam feitas antes do gerador assíncrono (mudança na estrutura do código). Além disso, o texto menciona que os testes (`test-stream-map`) precisam ser atualizados para refletir a mudança no comportamento, indicando a necessidade de testes de regressão."
302,41391,"2022-01-04 04:12:23","2022-01-19 11:26:39","2022-03-01 21:57:04","「captureRejections」property works different in node REPL with node file.js","### Version

v15.0.1

### Platform

19.5.0 Darwin Kernel Version 19.5.0

### Subsystem

_No response_

### What steps will reproduce the bug?

create a js file with the code blow
```js
const emitter = require('events')
const em1 = new emitter({ captureRejections: true })
console.log(em1)
```
run node file.js
output 
```js
[Symbol(kCapture)]: true
```
as expected.
however then i run with node REPL
output 
```js
[Symbol(kCapture)]: false
```
not expected

### How often does it reproduce? Is there a required condition?

always

### What is the expected behavior?

captureRejections in node REPL works fine

### What do you see instead?

same code
REPL output:
```js
EventEmitter {
  _events: [Object: null prototype] {},
  _eventsCount: 0,
  _maxListeners: undefined,
  [Symbol(kCapture)]: false
}
```
node file.js output
```js
EventEmitter {
  _events: [Object: null prototype] {},
  _eventsCount: 0,
  _maxListeners: undefined,
  [Symbol(kCapture)]: true
}
```


### Additional information

_No response_","closed","Scared-Heart",26789238,"{confirmed-bug,repl}","https://github.com/nodejs/node/issues/41391",2,"Nenhum",NULL,15,NULL,"A issue descreve um comportamento inconsistente da propriedade `captureRejections` do EventEmitter em diferentes contextos (arquivo .js vs. REPL).  Não há menção a refatoração de código ou testes de regressão. O problema se concentra em um comportamento inesperado de uma funcionalidade existente."
167,51381,"2024-01-05 12:45:39","2024-03-19 13:19:05","2024-08-24 02:22:16","Test runner: spurious ""Promise resolution is still pending but the event loop has already resolved"" when a callback tests fails","### Version

v21.4.0

### Platform

Microsoft Windows NT 10.0.22621.0 x64

### Subsystem

test

### What steps will reproduce the bug?

Run the following code with `node --test test.js`:

```js
""use strict"";
const { describe, test } = require(""node:test"");
const assert = require(""node:assert"");

describe(""describe wrapper"", () => {
  test(""callback test"", (t, done) => {
    setTimeout(() => {
      assert.ok(false, ""oh no an assert failed"");
      done();
    });
  });

  test(""promise test"", async () => {
    assert.ok(true, ""this assert will pass"");
  });
});

describe(""another describe block"", () => {
  test(""sync test"", () => {
    assert.ok(true, ""this assert will pass 2"");
  });
});
```

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

It should tell me that `""callback test""` alone is failing

### What do you see instead?

It shows four failure messages: one for `callback test` (correct), one for `describe wrapper`, one for `sync test`, and one for `another describe block`. The latter three have a (green??) `'Promise resolution is still pending but the event loop has already resolved'` failure reason.

```
$ node --test test.js
▶ describe wrapper
  ✖ callback test (2.4042ms)
    AssertionError [ERR_ASSERTION]: oh no an assert failed
        at Timeout._onTimeout (C:\Users\d\OneDrive - domenic.me\Code\GitHub\jsdom\jsdom\test.js:8:14)
        at listOnTimeout (node:internal/timers:573:17)
        at process.processTimers (node:internal/timers:514:7) {
      generatedMessage: false,
      code: 'ERR_ASSERTION',
      actual: false,
      expected: true,
      operator: '=='
    }

  ✔ promise test (0.2519ms)
▶ describe wrapper (5.4167ms)

  'Promise resolution is still pending but the event loop has already resolved'

▶ another describe block
  ✖ sync test
    'Promise resolution is still pending but the event loop has already resolved'

▶ another describe block

  'Promise resolution is still pending but the event loop has already resolved'

ℹ tests 3
ℹ suites 2
ℹ pass 1
ℹ fail 1
ℹ cancelled 1
ℹ skipped 0
ℹ todo 0
ℹ duration_ms 47.7459

✖ failing tests:

test at test.js:6:3
✖ callback test (2.4042ms)
  AssertionError [ERR_ASSERTION]: oh no an assert failed
      at Timeout._onTimeout (C:\Users\d\OneDrive - domenic.me\Code\GitHub\jsdom\jsdom\test.js:8:14)
      at listOnTimeout (node:internal/timers:573:17)
      at process.processTimers (node:internal/timers:514:7) {
    generatedMessage: false,
    code: 'ERR_ASSERTION',
    actual: false,
    expected: true,
    operator: '=='
  }

test at test.js:5:1
✖ describe wrapper (5.4167ms)
  'Promise resolution is still pending but the event loop has already resolved'

test at test.js:19:3
✖ sync test
  'Promise resolution is still pending but the event loop has already resolved'

test at test.js:18:1
✖ another describe block
  'Promise resolution is still pending but the event loop has already resolved'
```

### Additional information

There isn't a lot of documentation about callback-style tests...","closed","domenic",617481,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/51381",9,"Ambos",NULL,74,"erro teste callback estilo esperar falhar somente callback teste mostrar quatro mensagem erro um callback teste correto um describe wrapper um sync test um another describe block tres ultimo ter promise resolution ainda pendente evento loop já resolver node teste teste js sempre dever indicar callback teste falhar mostrar mensagem erro adicional documentação teste estilo callback pouco
","O título da issue indica um problema com o 'test runner', diretamente relacionado a testes.  O corpo da issue descreve erros em testes de callback, mencionando mensagens de erro, promises pendentes e a necessidade de melhorar a documentação de testes.  Os comentários discutem soluções envolvendo asserções, tratamento de erros,  o comportamento de exceções não capturadas e melhorias no 'test runner', incluindo a implementação de técnicas de espera e um novo flag de timeout.  A combinação de problemas de teste e sugestões de melhorias no funcionamento do 'test runner' (refatoração) justifica a classificação 'Ambos'."
168,51371,"2024-01-04 15:16:57","2024-03-09 13:19:10","2024-03-09 13:19:10","test_runner: after() hook is called  for no subtests","### Version

v20.10.0 (also on v22.0.0-pre)

### Platform

Darwin Pulkits-MacBook-Air.local 23.1.0 Darwin Kernel Version 23.1.0: Mon Oct  9 21:28:12 PDT 2023; root:xnu-10002.41.9~6/RELEASE_ARM64_T8103 arm64

### Subsystem

_No response_

### What steps will reproduce the bug?

code
```js
import { test } from 'node:test';
import { open } from 'node:fs/promises';

test('test', async (t) => {
  let filehandle;

  t.before(async () => {
    console.log('before');
    filehandle = await open('./index.mjs', 'r');
  });

  t.after(async () => {
    console.log('after');
    await filehandle.close();
  });

//   await t.test(() => {});
});

```

run with cmd: `node --test --test-reporter tap file.test.mjs`


Note: `before` hook is omitted but `after` hook didn't.

### How often does it reproduce? Is there a required condition?

Always.

### What is the expected behavior? Why is that the expected behavior?

I didn't expect after() hook to be called. This should work same as global `after` hook.
what i mean is that, if the run code below:

```mjs
import { test, before, after } from 'node:test';
import { open } from 'node:fs/promises';

let filehandle;

before(async () => {
  console.log('before');
  filehandle = await open('./index.mjs', 'r');
});

after(async () => {
  console.log('after');
  await filehandle.close();
});


// test('test', async (t) => {
// //   await t.test(() => {});
// });
```

output is:
```bash
TAP version 13
1..0
# Subtest: /Users/pulkitgupta/Desktop/node/file.test.mjs
ok 1 - /Users/pulkitgupta/Desktop/node/file.test.mjs
  ---
  duration_ms: 74.496917
  ...
1..1
# tests 1
# suites 0
# pass 1
# fail 0
# cancelled 0
# skipped 0
# todo 0
# duration_ms 82.408584
```

### What do you see instead?

```bash
TAP version 13
# after
# Subtest: test
not ok 1 - test
  ---
  duration_ms: 2.9665
  location: 'file:///Users/pulkitgupta/Desktop/node/file.test.mjs:4:1'
  failureType: 'hookFailed'
  error: ""Cannot read properties of undefined (reading 'close')""
  code: 'ERR_TEST_FAILURE'
  name: 'TypeError'
  stack: |-
    TestContext.<anonymous> (file:///Users/pulkitgupta/Desktop/node/file.test.mjs:14:22)
    TestHook.runInAsyncScope (node:async_hooks:206:9)
    TestHook.run (node:internal/test_runner/test:631:25)
    TestHook.run (node:internal/test_runner/test:856:18)
    TestHook.run (node:internal/util:531:12)
    node:internal/test_runner/test:565:20
    async Test.runHook (node:internal/test_runner/test:563:7)
    async after (node:internal/test_runner/test:591:9)
    async Test.run (node:internal/test_runner/test:641:7)
    async startSubtest (node:internal/test_runner/harness:216:3)
  ...
1..1
# tests 1
# suites 0
# pass 0
# fail 1
# cancelled 0
# skipped 0
# todo 0
# duration_ms 82.467625
```

### Additional information

_No response_","closed","pulkit-30",76155456,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/51371",2,"Testes de Regressão",NULL,65,"hook after call expect global hook work same run code expect call hook call read property undefined close test fail typeerror
","O título da issue ""test_runner: after() hook is called for no subtests"" e o corpo da issue mencionam explicitamente testes (""test_runner"", ""test fail"").  Os comentários também se referem a execução de testes e hooks.  Não há menção a refatoração de código, apenas a falha em um teste e seu comportamento inesperado. "
223,47828,"2023-05-03 06:52:33","2023-05-05 07:59:27","2023-05-05 07:59:27","`test/reporters` can be required ","```
$ node -p ""require('test/reporters')""
{ dot: [Getter], spec: [Getter], tap: [Getter] }
```

I don't know if it's intended, but I find this confusing since the `node:` scheme is mandatory for `require('node:test')`

@nodejs/test_runner ","closed","targos",2352663,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/47828",1,"Testes de Regressão",NULL,2,"node require test reporter confusing node scheme mandatory require node test
","O título da issue menciona ""test/reporters"", indicando um foco em testes.  O corpo e comentários mencionam ""test"", ""reporter"", e dificuldades com testes.  Não há menção explícita a refatoração de código, apenas a problemas com os testes existentes."
303,41244,"2021-12-19 09:27:53","2024-10-14 22:31:44","2024-10-14 22:31:59","TypeError produces NodeError with ""Please open an issue with this stack trace""","### Version

v17.2.0

### Platform

Darwin Fabians-Mac-mini.local 21.1.0 Darwin Kernel Version 21.1.0: Wed Oct 13 17:33:23 PDT 2021; root:xnu-8019.41.5~1/RELEASE_X86_64 x86_64

### Subsystem

_No response_

### What steps will reproduce the bug?

By replacing the line here: 

https://github.com/virtualstate/x/blob/5e1a4af59fd61b436f02570b1f64ff5a0b90cb79/packages/fringe/src/token.ts#L209

```
...options?.[TokenAncestor] && ancestor ? (
```

With

```
...options[TokenAncestor] && ancestor ? (
```

And running:

```
yarn build && node packages/fringe/lib/token.types-test.js
```

Produces the error. 

### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior?

The error log:

```
TypeError: Cannot read properties of undefined (reading 'Symbol(@virtualstate/fringe/token/ancestor)')
    at defineProperties (file:///Volumes/Extreme/Users/fabian/src/virtualstate/x/packages/fringe/lib/token.js:126:23)
    at createToken (file:///Volumes/Extreme/Users/fabian/src/virtualstate/x/packages/fringe/lib/token.js:57:5)
    at Object.createNode (file:///Volumes/Extreme/Users/fabian/src/virtualstate/x/packages/fringe/lib/create-node.js:115:26)
    at flattenChildrenSource (file:///Volumes/Extreme/Users/fabian/src/virtualstate/x/packages/fringe/lib/children.js:154:27)
    at flattenChildrenSource.next (<anonymous>)
    at Object.get [Symbol.iterator] (file:///Volumes/Extreme/Users/fabian/src/virtualstate/x/packages/fringe/lib/create-node.js:454:37)
    at isIterable (file:///Volumes/Extreme/Users/fabian/src/virtualstate/x/node_modules/iterable/dist/core/async-like.js:31:14)
    at isIterableChildren (file:///Volumes/Extreme/Users/fabian/src/virtualstate/x/packages/fringe/lib/children.js:162:12)
    at flattenChildrenSource (file:///Volumes/Extreme/Users/fabian/src/virtualstate/x/packages/fringe/lib/children.js:144:38)
    at flattenChildrenSource.next (<anonymous>)
```

### What do you see instead?

The error log:

```
node:internal/errors:464
    ErrorCaptureStackTrace(err);
    ^

Error [ERR_INTERNAL_ASSERTION]: Error [ERR_INTERNAL_ASSERTION]: TypeError: Cannot read properties of undefined (reading 'Symbol(@virtualstate/fringe/token/ancestor)')
    at defineProperties (file:///Volumes/Extreme/Users/fabian/src/virtualstate/x/packages/fringe/lib/token.js:126:23)
    at createToken (file:///Volumes/Extreme/Users/fabian/src/virtualstate/x/packages/fringe/lib/token.js:57:5)
    at Object.createNode (file:///Volumes/Extreme/Users/fabian/src/virtualstate/x/packages/fringe/lib/create-node.js:115:26)
    at flattenChildrenSource (file:///Volumes/Extreme/Users/fabian/src/virtualstate/x/packages/fringe/lib/children.js:154:27)
    at flattenChildrenSource.next (<anonymous>)
    at Object.get [Symbol.iterator] (file:///Volumes/Extreme/Users/fabian/src/virtualstate/x/packages/fringe/lib/create-node.js:454:37)
    at isIterable (file:///Volumes/Extreme/Users/fabian/src/virtualstate/x/node_modules/iterable/dist/core/async-like.js:31:14)
    at isIterableChildren (file:///Volumes/Extreme/Users/fabian/src/virtualstate/x/packages/fringe/lib/children.js:162:12)
    at flattenChildrenSource (file:///Volumes/Extreme/Users/fabian/src/virtualstate/x/packages/fringe/lib/children.js:144:38)
    at flattenChildrenSource.next (<anonymous>)
This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues

    at new NodeError (node:internal/errors:371:5)
    at Function.fail (node:internal/assert:20:9)
    at handleMaxCallStackSize (node:internal/util/inspect:1370:10)
    at formatRaw (node:internal/util/inspect:1013:12)
    at formatValue (node:internal/util/inspect:793:10)
    at formatProperty (node:internal/util/inspect:1681:11)
    at formatRaw (node:internal/util/inspect:1006:9)
    at formatValue (node:internal/util/inspect:793:10)
    at inspect (node:internal/util/inspect:340:10)
    at formatWithOptionsInternal (node:internal/util/inspect:2006:40)
This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues

    at new NodeError (node:internal/errors:371:5)
    at Function.fail (node:internal/assert:20:9)
    at handleMaxCallStackSize (node:internal/util/inspect:1370:10)
    at formatRaw (node:internal/util/inspect:1013:12)
    at formatValue (node:internal/util/inspect:793:10)
    at inspect (node:internal/util/inspect:340:10)
    at formatWithOptionsInternal (node:internal/util/inspect:2006:40)
    at formatWithOptions (node:internal/util/inspect:1888:10)
    at console.value (node:internal/console/constructor:323:14)
    at console.log (node:internal/console/constructor:359:61) {
  code: 'ERR_INTERNAL_ASSERTION'
}
 ```
 
 

### Additional information

I don't actually believe this is a valid bug, but the internal bug asked for me to raise, so I have raised. ","closed","fabiancook",4337080,"{confirmed-bug,util}","https://github.com/nodejs/node/issues/41244",4,"Testes de Regressão",NULL,1031,NULL,"A issue relata um erro (TypeError) encontrado durante a execução de testes ('yarn build && node packages/fringe/lib/token.types-test.js').  A descrição foca na reprodução do erro e na comparação entre o comportamento esperado e o observado durante os testes.  A discussão nos comentários também gira em torno da causa raiz do erro nos testes e possíveis soluções, sem mencionar refatoração de código além do contexto da correção do erro nos testes."
305,41096,"2021-12-06 09:46:03","2021-12-11 12:05:45","2021-12-11 12:05:45","Inspection of error with cause fails for non-error causes","### Version

master

### Platform

N/A

### Subsystem

util

### What steps will reproduce the bug?

`./node -p ""new Error('test', { cause: 42 })""`

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior?

It should be able to serialize non-error causes.

### What do you see instead?

```
$ ./node -p ""new Error('test', { cause: 42 })""
node:internal/util/inspect:1194
  return error.stack ? String(error.stack) : ErrorPrototypeToString(error);
                                             ^

TypeError: Method Error.prototype.toString called on incompatible receiver 42
    at Number.toString (<anonymous>)
    at getStackString (node:internal/util/inspect:1194:46)
    at getStackFrames (node:internal/util/inspect:1202:24)
    at formatError (node:internal/util/inspect:1284:19)
    at formatRaw (node:internal/util/inspect:943:14)
    at formatValue (node:internal/util/inspect:798:10)
    at inspect (node:internal/util/inspect:345:10)
    at formatWithOptionsInternal (node:internal/util/inspect:2140:40)
    at formatWithOptions (node:internal/util/inspect:2006:10)
    at console.value (node:internal/console/constructor:323:14)

Node.js v18.0.0-pre
```

### Additional information

_No response_","closed","targos",2352663,"{confirmed-bug,util}","https://github.com/nodejs/node/issues/41096",1,"Nenhum",NULL,5,NULL,"A issue descreve um erro de serialização de causa não-erro em um objeto Error do Node.js.  Não há menção a refatoração de código ou a testes de regressão. O foco é na resolução de um bug específico."
171,51167,"2023-12-15 21:28:38","2025-01-25 18:00:21","2025-01-25 18:00:21","v18.18.2 -> v18.19.0, v20.5.1 -> v20.6.0 regression: pathToFileURL trims whitespace.","### Version

v18.19.0, v20.6.0

### Platform

Darwin Kernel Version 23.2.0: Wed Nov 15 21:53:18 PST 2023; root:xnu-10002.61.3~2/RELEASE_ARM64_T6000 arm64

### Subsystem

url

### What steps will reproduce the bug?

```js
import {pathToFileURL} from 'url';

const filename = `test-${String.fromCharCode(0)}`;
console.log(pathToFileURL(filename).toString()); // file:///[...]/test-
```

### How often does it reproduce? Is there a required condition?

always

### What is the expected behavior? Why is that the expected behavior?

In Node v18.18.2 and v20.5.1:

```js
import {pathToFileURL} from 'url';

const filename = `test-${String.fromCharCode(0)}`;
console.log(pathToFileURL(filename).toString()); // file:///[...]/test-%00
```

### What do you see instead?

Where prior versions retained the trailing whitespace and returned a pathname ending in `/test-%00`, starting in v18.19.0 and v20.6.0 the trailing whitespace is removed and results in a pathname ending in `/test-`.

### Additional information

This regression was introduced by optimizations in https://github.com/nodejs/node/pull/48709, specifically the [switch from](https://github.com/nodejs/node/pull/48709/files#diff-26e6b1e2a90040b1ce20e7f305b2ff3140b483f863ee2573b4c6af9b696ad31eR1480):

```js
const outURL = new URL('file://');
outURL.pathname = encodePathChars(resolved);
return outURL;
```

To:

```js
resolved = encodePathChars(resolved);
return new URL(`file://${resolved}`);
```

While these seem equivalent, `new URL` [uses `parse`](https://github.com/nodejs/node/blob/v20.6.0/lib/internal/url.js#L775), which [trims](https://github.com/nodejs/node/blob/v20.6.0/lib/url.js#L237) [leading and trailing whitespace](https://github.com/nodejs/node/blob/v20.6.0/lib/url.js#L184-L187) from the path. In contrast, the earlier method of setting `pathname` directly does not trim whitespace.

I'm not sure which way is actually preferred, but regardless this was an unexpected (and undocumented) breaking change.","closed","jgerigmeyer",552316,"{confirmed-bug,url,whatwg-url}","https://github.com/nodejs/node/issues/51167",4,"Testes de Regressão",NULL,407,"regression unexpected breaking change version nodejs url path whitespace trim optimization
","O título da issue contém a palavra 'regression', indicando um problema de regressão. O corpo da issue menciona 'regression unexpected breaking change', reforçando a natureza do problema como um teste de regressão.  Os comentários discutem a solução e o impacto da mudança em diferentes versões do Node.js, mas não há menção explícita a refatoração de código."
173,51016,"2023-12-02 15:02:47","2023-12-13 22:34:58","2023-12-18 11:23:19","Removing a signal handler from a process `newListener` event handler doesn't work correctly","### Version

v21.3.0

### Platform

Linux new-hope 6.5.0-2-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.5.6-1 (2023-10-07) x86_64 GNU/Linux

### Subsystem

_No response_

### What steps will reproduce the bug?

Consider this code (the idea is to set up a fallback SIGINT handler that will auto-remove if something else sets a handler):
```js
// sigTest.js
const fallbackHandler = () => console.debug(""in fallback handler"");

process.on(""SIGINT"", fallbackHandler);
process.on(""newListener"", (event) => event === ""SIGINT"" && process.off(""SIGINT"", fallbackHandler));

process.on(""SIGINT"", () => console.debug(""in real handler""));

process.stdin.resume();
```
Run `node sigTest.js` and press Ctrl+C.

### How often does it reproduce? Is there a required condition?

This happens regardless of whether the new listener is installed immediately or at a later point.

### What is the expected behavior? Why is that the expected behavior?

```console
$ node sigintTest.mjs
^Cin real handler
^Cin real handler
```
Note the process shouldn't terminate. Adding the ""real"" handler should cause the ""fallback"" handler to be removed by the `newListener` event listener, leaving only the ""real"" handler as the SIGINT listener.

### What do you see instead?

```console
$ node sigintTest.mjs ; printf ""\nExit code: $?\n""
^C
Exit code: 1
$
```
Note the process terminates with exit code 1. Neither SIGINT handler runs.

### Additional information

Wrapping `process.off` in a `setImmediate` makes the code work as expected.","closed","dividedmind",823636,"{confirmed-bug,wontfix,events,process}","https://github.com/nodejs/node/issues/51016",4,"Ambos",NULL,11,NULL,"A issue descreve um bug (comportamento inesperado ao remover um manipulador de sinal) que requer tanto refatoração do código (para corrigir a condição de corrida identificada) quanto testes de regressão para garantir que a correção não introduza novos problemas.  Os comentários discutem a possibilidade de uma condição de corrida, sugerindo a necessidade de refatoração para corrigir o problema.  Também mencionam a necessidade de testes para validar a solução e garantir que não haja outros impactos. A sugestão de usar `setImmediate` para contornar o problema indica a necessidade de ajuste no código, o que se encaixa na categoria de refatoração."
174,50909,"2023-11-25 20:40:40","2024-05-12 10:28:57","2024-05-12 10:28:57","`console.log(""%s"", { [Symbol.toPrimitive]: () => ""hello"" })` shows the object, not ""hello""","### Version

v21.2.0

### Platform

Linux PIG-2016 5.15.90.1-microsoft-standard-WSL2 #1 SMP Fri Jan 27 02:56:13 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

inspect

### What steps will reproduce the bug?

```sh
jcbhmr@PIG-2016:~$ node
Welcome to Node.js v21.2.0.
Type "".help"" for more information.
> let o; o = { __proto__: null, [Symbol.toPrimitive]: () => ""hello"" }
[Object: null prototype] {
  [Symbol(Symbol.toPrimitive)]: [Function: [Symbol.toPrimitive]]
}
> console.log(""%s"", o)
[Object: null prototype] {
  [Symbol(Symbol.toPrimitive)]: [Function: [Symbol.toPrimitive]]
}
undefined
>
```

### How often does it reproduce? Is there a required condition?

always

### What is the expected behavior? Why is that the expected behavior?

deno does:

```sh
jcbhmr@PIG-2016:~$ deno
Deno 1.38.3
exit using ctrl+d, ctrl+c, or close()
REPL is running with all permissions allowed.
To specify permissions, run `deno repl` with allow flags.
> let o; o = { __proto__: null, [Symbol.toPrimitive]: () => ""hello"" }
[Object: null prototype] {
  [Symbol(Symbol.toPrimitive)]: [Function: [Symbol.toPrimitive]]
}
> console.log(""%s"", o)
hello
undefined
>
```

chrome browser does:

```js
< let o; o = { __proto__: null, [Symbol.toPrimitive]: () => ""hello"" }
> {Symbol(Symbol.toPrimitive): ƒ}
< console.log(""%s"", o)
VM5744:1 hello
> undefined
```

bun does:

```sh
jcbhmr@PIG-2016:~$ bun repl
Welcome to Bun v1.0.14
Type "".help"" for more information.
[!] Please note that the REPL implementation is still experimental!
    Don't consider it to be representative of the stability or behavior of Bun overall.
> let o; o = { __proto__: null, [Symbol.toPrimitive]: () => ""hello"" }
[Object: null prototype] {
  [Symbol(Symbol.toPrimitive)]: [Function: [Symbol.toPrimitive]]
}
> console.log(""%s"", o)
hello
undefined
>
```

firefox browser does:

```js
>> let o; o = { __proto__: null, [Symbol.toPrimitive]: () => ""hello"" }
<- Object { Symbol(""Symbol.toPrimitive""): Symbol.toPrimitive() }

>> console.log(""%s"", o)
hello                                          debugger eval code:1:9
<- undefined
```

makes sense; it has a stringifier so it should act just like it would if it had a toString() which Node.js _does_ recognize:

```sh
jcbhmr@PIG-2016:~$ node
Welcome to Node.js v21.2.0.
Type "".help"" for more information.
> let o; o = { __proto__: null, toString: () => ""hello"" }
[Object: null prototype] { toString: [Function: toString] }
> console.log(""%s"", o)
hello
undefined
>
```

### What do you see instead?

```sh
jcbhmr@PIG-2016:~$ node
Welcome to Node.js v21.2.0.
Type "".help"" for more information.
> let o; o = { __proto__: null, [Symbol.toPrimitive]: () => ""hello"" }
[Object: null prototype] {
  [Symbol(Symbol.toPrimitive)]: [Function: [Symbol.toPrimitive]]
}
> console.log(""%s"", o)
[Object: null prototype] {
  [Symbol(Symbol.toPrimitive)]: [Function: [Symbol.toPrimitive]]
}
undefined
>
```

### Additional information

_No response_","closed","jcbhmr",61068799,"{confirmed-bug,console}","https://github.com/nodejs/node/issues/50909",3,"Nenhum",NULL,169,"node console log object symbol toprimitive hello deno chrome bun firefox stringifier tostring


","O título e o corpo da issue descrevem um problema de comportamento inesperado do `console.log` com o símbolo `toPrimitive`.  Não há menção explícita a refatoração de código ou a execução de testes de regressão. Os comentários também não fornecem indícios relacionados a essas categorias. O problema se concentra em um comportamento específico de uma função built-in do Javascript e sua interação com diferentes engines de Javascript (Node, Chrome, Deno, Bun, Firefox)."
307,40814,"2021-11-15 13:34:07","2022-10-29 20:23:17","2022-11-02 22:25:38","Exception when using `privateEncrypt`/`privateDecrypt` with certain encrypted keys","### Version

v16.13.0

### Platform

Linux EURO01 5.4.0-88-generic #99-Ubuntu SMP Thu Sep 23 17:29:00 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

crypto

### What steps will reproduce the bug?

1. Create an public/private RSA key-pair by using either `aes-128-ecb` or `aes-128-ocb`
2. Attempt to decrypt/encrypt something

Code:
```js
const crypto = require(""crypto"");
let {privateKey, publicKey} = crypto.generateKeyPairSync(""rsa"", {
    modulusLength: 2048,
    publicKeyEncoding: {
        type: ""spki"",
        format: ""pem""
    },
    privateKeyEncoding: {
        type: 'pkcs8',
        format: 'pem',
        cipher: ""aes-128-ecb"",
        passphrase: ""abcdef""
    }
});
const encryptedString = crypto.privateEncrypt({
    key: privateKey,
    passphrase: ""abcdef""
}, Buffer.from(""The quick brown fox jumps over the lazy dog"")).toString(""base64"");
const decryptedString = crypto.publicDecrypt(publicKey, Buffer.from(encryptedString, ""base64"")).toString();
console.log(`Encrypted: ${encryptedString}`);
console.log(`Decrypted: ${decryptedString}`);
```

### How often does it reproduce? Is there a required condition?

This only happens with _some_ ciphers, some like `aes-128-ccm` or `aes-128-cbc` and other variants works just fine, other ciphers fail with an error

### What is the expected behavior?

An successful encryption/decryption with the specified ciphers

### What do you see instead?

```
node:internal/crypto/cipher:79
    return method(data, format, type, passphrase, buffer, padding, oaepHash,
           ^

Error: error:060CC07A:digital envelope routines:EVP_CIPHER_asn1_to_param:cipher parameter error
    at Object.privateEncrypt (node:internal/crypto/cipher:79:12)
    at Object.<anonymous> (/home/pancho7532/Documents/AnotherBotXDDXD/rsaTest.js:25:32)
    at Module._compile (node:internal/modules/cjs/loader:1101:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)
    at node:internal/main/run_main_module:17:47 {
  opensslErrorStack: [
    'error:060CC07A:digital envelope routines:EVP_CIPHER_asn1_to_param:cipher parameter error'
  ],
  library: 'digital envelope routines',
  function: 'EVP_CIPHER_asn1_to_param',
  reason: 'cipher parameter error',
  code: 'ERR_OSSL_EVP_CIPHER_PARAMETER_ERROR'
}
```

### Additional information

In v14.17.3 (the version i had previously) Node.JS would crash with a core dump on some ciphers (like GCM based ciphers)","closed","PANCHO7532B",92986867,"{confirmed-bug,crypto}","https://github.com/nodejs/node/issues/40814",4,"Ambos",NULL,348,NULL,"A issue relata um problema com a criptografia e descriptografia de chaves RSA usando diferentes cifras. O corpo da issue descreve os passos para reproduzir o erro, o comportamento esperado e o comportamento observado.  Os comentários mostram que o problema afeta diferentes versões do Node.js e diferentes cifras, resultando em erros como ""cipher parameter error"" e segmentações de falhas.  A combinação de busca por solução e testes extensivos com diversas cifras indica tanto a necessidade de refatoração do código de criptografia (para corrigir os erros e garantir compatibilidade com diferentes cifras) quanto testes de regressão para verificar se as correções não introduzem novos problemas em outras áreas. "
309,40693,"2021-11-01 14:39:56","2021-11-18 13:15:09","2021-11-18 13:15:09","[REG 16.6->16.7] TCP/TLS drops AsyncLocalStorage","### Version

v16.13.0

### Platform

Microsoft Windows NT 10.0.19043.0 x64

### Subsystem

tcp/tls/async_hooks

### What steps will reproduce the bug?

```javascript
const { AsyncLocalStorage } = require('async_hooks');
const net = require('net');

const asyncLocalStorage = new AsyncLocalStorage();

asyncLocalStorage.run({val: 'abcd'}, () => {
  const socket = new net.Socket();
  socket.on('data', () => {
    // This is 'abcd' with Node 16.6.x, and undefined with Node >=16.7.0
    console.log(asyncLocalStorage.getStore()?.val);
  });
  socket.connect(80, 'google.com', function() {
    socket.write('GET /\n');
  });
});
```

TLS socket is also broken:
```javascript
const { AsyncLocalStorage } = require('async_hooks');
const tls = require('tls');

const asyncLocalStorage = new AsyncLocalStorage();

asyncLocalStorage.run({val: 'abcd'}, () => {
  const socket = tls.connect({ host: 'google.com', port: 443 });
  socket.on('data', () => {
    // This is 'abcd' with Node 16.6.x, and undefined with Node >=16.7.0
    console.log(asyncLocalStorage.getStore()?.val);
    socket.end();
  });
  socket.on('error', console.error);
  socket.write('GET /\n');
});
```

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior?

It should write abcd.

### What do you see instead?

undefined

### Additional information

_No response_","closed","orgads",1246544,"{confirmed-bug,async_hooks}","https://github.com/nodejs/node/issues/40693",5,"Testes de Regressão",NULL,17,NULL,"A issue relata um bug de regressão em versões do Node.js (entre 16.6.2 e 16.7.0) relacionado ao funcionamento do AsyncLocalStorage com sockets TCP/TLS.  Os comentários incluem informações sobre a bisseção do problema para identificar o commit causador e menções a pull requests relacionadas à correção.  O foco principal é testar se a funcionalidade existente continua funcionando após uma alteração de código, caracterizando testes de regressão."
315,40336,"2021-10-05 18:19:56","2021-10-13 01:45:14","2021-10-13 01:45:14","Setting the `objectMode` option in the `net.Socket()` constructor causes an abort on write","### Version

v16.10.0

### Platform

Darwin imac.local 20.6.0 Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64 x86_64

### Subsystem

net

### What steps will reproduce the bug?

```
$ cat crash.js
'use strict';

const net = require('net');

const server = net.createServer();

server.on('connection', function (socket) {
  socket.write(Buffer.from('foo'));
  socket.resume();
});

server.on('listening', function () {
  const { port } = server.address();
  const socket = net.createConnection({ port, objectMode: true });

  socket.on('data', function (chunk) {
    console.log(chunk);
    socket.write(chunk);
  });
});

server.listen();
```

```
$ node crash.js
<Buffer 66 6f 6f>
node[235]: ../src/stream_base.cc:220:int node::StreamBase::WriteString(const v8::FunctionCallbackInfo<v8::Value>&) [with node::encoding enc = (node::encoding)1]: Assertion `args[1]->IsString()' failed.
 1: 0xafd010 node::Abort() [node]
 2: 0xafd08e  [node]
 3: 0xbdfd0e int node::StreamBase::WriteString<(node::encoding)1>(v8::FunctionCallbackInfo<v8::Value> const&) [node]
 4: 0xbe0990 void node::StreamBase::JSMethod<&(int node::StreamBase::WriteString<(node::encoding)1>(v8::FunctionCallbackInfo<v8::Value> const&))>(v8::FunctionCallbackInfo<v8::Value> const&) [node]
 5: 0xd4339b  [node]
 6: 0xd4462c  [node]
 7: 0xd44b06 v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) [node]
 8: 0x15e8099  [node]
Aborted
```

### How often does it reproduce? Is there a required condition?

Always. No required condition.

### What is the expected behavior?

An error should be thrown if any of the `objectMode`, `readableObjectMode`, or `writableObjectMode` options are set when a `net.Socket` is instantiated.

### What do you see instead?

The options are accepted but they not make sense in a socket context.

### Additional information

The issue was found by @pimterry in https://github.com/websockets/ws/issues/1952.","closed","lpinca",1443911,"{confirmed-bug,net}","https://github.com/nodejs/node/issues/40336",1,"Nenhum",NULL,7,NULL,"A issue descreve um bug onde a opção `objectMode` no construtor `net.Socket()` causa um aborto na escrita.  Não há menção a refatoração de código ou a testes de regressão. O foco é em corrigir um comportamento inesperado e potencialmente problemático do código existente."
176,50876,"2023-11-23 11:40:24","2024-01-08 21:25:46","2024-01-08 21:25:46","File Write Operations failing on Virtualbox shared filesystem","### Version

20.10.0

### Platform

Linux vagrant 5.15.0-83-generic #92-Ubuntu SMP Mon Aug 14 09:30:42 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

_No response_

### What steps will reproduce the bug?

I have the following `Vagrantfile` to set up my Virtual Box
```Vagrantfile
Vagrant.configure(""2"") do |config|
  config.vm.box = ""bento/ubuntu-22.04""

  config.vm.synced_folder ""./shared_folder"", ""/vagrant_data""

  config.vm.provision :shell, run: :always, inline: 'which node || snap install node --classic --channel=20'
end
```
the file `shared_folder/create-file.js` 
```javascript
const fs = require(""fs"");

const writeStream = fs.createWriteStream(""empty-file.txt"");
writeStream.end();
```
and the file `shared_folder/create-and-write-file.js`
```javascript
const fs = require(""fs"");

const writeStream = fs.createWriteStream(""file-with-content.txt"");
writeStream.write(""Hello world."");
writeStream.end();
```

1. Start the box using `vagrant up` and log in to the box
2. `cd /vagrant_data`
3. run `node create-file.js` => file `empty-file.txt` is created
4. run `node create-and-write-file.js` => file `file-with-content.txt` is created but does not have any content!
error message is:
```
node:events:492
      throw er; // Unhandled 'error' event
      ^

Error: ENOTSUP: operation not supported on socket, write
Emitted 'error' event on WriteStream instance at:
    at emitErrorNT (node:internal/streams/destroy:151:8)
    at emitErrorCloseNT (node:internal/streams/destroy:116:3)
    at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {
  errno: -95,
  code: 'ENOTSUP',
  syscall: 'write'
}

Node.js v20.10.0
```

### How often does it reproduce? Is there a required condition?

It always happens with the shared filesystem

### What is the expected behavior? Why is that the expected behavior?

File should have content.

### What do you see instead?

This error message and an empty file
```
node:events:492
      throw er; // Unhandled 'error' event
      ^

Error: ENOTSUP: operation not supported on socket, write
Emitted 'error' event on WriteStream instance at:
    at emitErrorNT (node:internal/streams/destroy:151:8)
    at emitErrorCloseNT (node:internal/streams/destroy:116:3)
    at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {
  errno: -95,
  code: 'ENOTSUP',
  syscall: 'write'
}

Node.js v20.10.0
```

### Additional information

- Our hostsystem is Windows. 
- node version 19 works well, but node 18 does not

The main problem for us is, that neither `npm install` works.","closed","ig-onoffice-de",85568061,"{confirmed-bug,fs,libuv}","https://github.com/nodejs/node/issues/50876",2,"Nenhum",NULL,46,"problema arquivo conteudo erro enotsup operaçao nao suportada socket escrever nodejs versao compartilhado sistema arquivo windows node versao funcionar npm instalar funcionar
","A issue descreve um problema com operações de escrita de arquivos em um sistema de arquivos compartilhado VirtualBox, especificamente um erro 'ENOTSUP' (operação não suportada).  Não há menção a refatoração de código ou testes de regressão. Os comentários fornecem informações adicionais sobre o erro, mas não indicam a necessidade de refatoração ou testes de regressão como solução ou causa raiz do problema."
177,50875,"2023-11-23 09:58:16","2023-11-26 07:31:59","2023-11-26 07:31:59","[Node v21] node --test executes tests twice if they are in folder named test","### Version

21.2.0

### Platform

Linux DEU1118 6.2.0-37-generic #38~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Thu Nov  2 18:01:13 UTC 2 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

_No response_

### What steps will reproduce the bug?

# Preparation

1. create a folder for your project `mkdir issue1`
2. go to the project folder `cd issue1` 
3. init the project `npm init`
4. add to package.json `""type"": ""module""`. at the end it will look like this
```json
{
  ""name"": ""issue1"",
  ""version"": ""1.0.0"",
  ""description"": """",
  ""main"": ""index.js"",
  ""scripts"": {
    ""test"": ""echo \""Error: no test specified\"" && exit 1""
  },
  ""author"": """",
  ""license"": ""ISC"",
  ""type"": ""module""
}
```
5. create `test` sub-folder `mkdir test`
6. create test case file `bug.test.js` in the `test` sub-folder with the following content
```javascript
import { describe, it } from ""node:test"";

describe(""Test"", () => {
  it(""Test"", () => {});
});
```
# How to Reproduce
execute from the main folder `node --test`
the test will be executed twice. an example output:
```
▶ Test
  ✔ Test (0.155014ms)
▶ Test (1.222016ms)

▶ Test
  ✔ Test (0.155561ms)
▶ Test (1.22262ms)

ℹ tests 2
ℹ suites 2
ℹ pass 2
ℹ fail 0
ℹ cancelled 0
ℹ skipped 0
ℹ todo 0
ℹ duration_ms 38.641146
```

# How to ""Fix""
rename your `test` folder to something else: `mv test mest`
execute again from the main folder `node --test`
the test will be executed once. an example output:
```
▶ Test
  ✔ Test (0.127919ms)
▶ Test (1.088147ms)

ℹ tests 1
ℹ suites 1
ℹ pass 1
ℹ fail 0
ℹ cancelled 0
ℹ skipped 0
ℹ todo 0
ℹ duration_ms 37.162391
```


### How often does it reproduce? Is there a required condition?

It can be reproduced every single time
the required conditions are:
 - `*.test.js` file(s) in a folder named `test`
-  use `node` `21.*`

### What is the expected behavior? Why is that the expected behavior?

The expected behavior is the test to be executed once:
```
▶ Test
  ✔ Test (0.127919ms)
▶ Test (1.088147ms)

ℹ tests 1
ℹ suites 1
ℹ pass 1
ℹ fail 0
ℹ cancelled 0
ℹ skipped 0
ℹ todo 0
ℹ duration_ms 37.162391
```

This is the expected behavior because I have one single test in one single file in the whole project


### What do you see instead?

Test was executed twice:
```
▶ Test
  ✔ Test (0.155014ms)
▶ Test (1.222016ms)

▶ Test
  ✔ Test (0.155561ms)
▶ Test (1.22262ms)

ℹ tests 2
ℹ suites 2
ℹ pass 2
ℹ fail 0
ℹ cancelled 0
ℹ skipped 0
ℹ todo 0
ℹ duration_ms 38.641146
```

### Additional information

_No response_","closed","Ngorror",2071979,"{confirmed-bug,fs,test_runner}","https://github.com/nodejs/node/issues/50875",0,"Testes de Regressão",NULL,3,"test execute twice folder name test node version 21 test execute once folder rename test mest node version 21 single test single file expect test execute once actual test execute twice  required condition test js file folder name test use node 21
","O título e o corpo da issue descrevem um problema de execução duplicada de testes em Node v21 quando os testes estão em uma pasta chamada 'test'.  A issue foca na execução incorreta dos testes, indicando a necessidade de testes de regressão para garantir que o problema esteja corrigido após a implementação de uma solução.  Não há menção a refatoração de código."
178,50836,"2023-11-21 12:36:07","2024-10-13 14:01:48","2024-10-13 14:01:48","[Node v20] assert.deepEqual doesn't detect two different URLs","### Version

v20.9.0

### Platform

Linux regseblaptop 6.2.0-36-generic #37~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Mon Oct  9 15:34:04 UTC 2 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

_No response_

### What steps will reproduce the bug?

- create file `index.js`:

  ```javascript
  const assert = require(""node:assert/strict"");

  const url1 = new URL(""http://foo1.com/"");
  const url2 = new URL(""http://foo2.com/"");
  assert.deepEqual(url1, url2);
  ```

- `node index.js`

### How often does it reproduce? Is there a required condition?

Always.

### What is the expected behavior? Why is that the expected behavior?

The `index.js` script must raise an error because the two URLs are different.

### What do you see instead?

No error.

### Additional information

- `npx node@18 index.js`

  ```
  node:assert:125
    throw new AssertionError(obj);
    ^

  AssertionError [ERR_ASSERTION]: Expected values to be strictly deep-equal:
  + actual - expected ... Lines skipped

    URL {
      [Symbol(context)]: URLContext {
        hash_start: 4294967295,
        host_end: 15,
        host_start: 7,
  +     href: 'http://foo1.com/',
  -     href: 'http://foo2.com/',
        pathname_start: 15,
  ...
        username_end: 7
      }
    }
      at Object.<anonymous> (/home/regseb/testcase/index.js:5:8)
      at Module._compile (node:internal/modules/cjs/loader:1256:14)
      at Module._extensions..js (node:internal/modules/cjs/loader:1310:10)
      at Module.load (node:internal/modules/cjs/loader:1119:32)
      at Module._load (node:internal/modules/cjs/loader:960:12)
      at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:86:12)
      at node:internal/main/run_main_module:23:47 {
    generatedMessage: true,
    code: 'ERR_ASSERTION',
    actual: URL {
      [Symbol(context)]: URLContext {
        href: 'http://foo1.com/',
        protocol_end: 5,
        username_end: 7,
        host_start: 7,
        host_end: 15,
        pathname_start: 15,
        search_start: 4294967295,
        hash_start: 4294967295,
        port: 4294967295,
        scheme_type: 0
      }
    },
    expected: URL {
      [Symbol(context)]: URLContext {
        href: 'http://foo2.com/',
        protocol_end: 5,
        username_end: 7,
        host_start: 7,
        host_end: 15,
        pathname_start: 15,
        search_start: 4294967295,
        hash_start: 4294967295,
        port: 4294967295,
        scheme_type: 0
      }
    },
    operator: 'deepStrictEqual'
  }

  Node.js v18.18.2
  ```","closed","regseb",1262990,"{confirmed-bug}","https://github.com/nodejs/node/issues/50836",7,"Ambos",NULL,327,"assertion error url deepStrictEqual expect url different raise error script node javascript
","O título da issue indica um problema de asserção em testes ([Node v20] assert.deepEqual doesn't detect two different URLs), sugerindo a necessidade de testes de regressão.  Os comentários discutem a solução, incluindo a sugestão de usar o Node 18 como exemplo e menções à mudança de propriedades de objetos e símbolos, indicando a necessidade de refatoração no código para resolver a incompatibilidade entre as versões do Node e o comportamento da asserção deepEqual."
325,39866,"2021-08-24 15:58:27","2022-07-16 14:18:09","2022-07-16 14:18:09","Error [ERR_INTERNAL_ASSERTION]: TypeError: Method height called on incompatible receiver #<Canvas>","### Version

v16.7.0

### Platform

Microsoft Windows NT 10.0.19043.0 x64

### Subsystem

_No response_

### What steps will reproduce the bug?

First, i have start a PowerShell terminal in visual studio code.

After, i run the command ""npm i canvas"" and i have this error from the command : 
```js
node:internal/errors:464
    ErrorCaptureStackTrace(err);
```



### How often does it reproduce? Is there a required condition?

This error occurs as soon as I require the ""canvas"" module, but only with this module.

### What is the expected behavior?

I should receive this when requesting the module : 
```js
{
  Canvas: [Function],
  Context2d: [Function],
  CanvasRenderingContext2D: [Function],
  CanvasGradient: [Function],
  CanvasPattern: [Function],
  Image: [Function],
  ImageData: [Function],
  PNGStream: [Function],
  PDFStream: [Function],
  JPEGStream: [Function],
  DOMMatrix: [Function],
  DOMPoint: [Function],
  registerFont: [Function],
  parseFont: [Function],
  createCanvas: [Function],
  createImageData: [Function],
  loadImage: [Function],
  backends: [Object],
  version: '2.8.0',
  cairoVersion: '1.17.4',
  jpegVersion: '8',
  gifVersion: '5.2.1',
  freetypeVersion: '2.10.4',
  rsvgVersion: '2.50.3',
  averageColor: [AsyncFunction]
}
```

### What do you see instead?

I see this error : 
```js
node:internal/errors:464
    ErrorCaptureStackTrace(err);
    ^

Error [ERR_INTERNAL_ASSERTION]: Error [ERR_INTERNAL_ASSERTION]: Error [ERR_INTERNAL_ASSERTION]: TypeError: Method height called on incompatible receiver #<Canvas>
    at getOwnPropertyDescriptor (<anonymous>)
    at formatProperty (node:internal/util/inspect:1674:18)
    at formatRaw (node:internal/util/inspect:1004:9)
    at formatValue (node:internal/util/inspect:791:10)
    at formatProperty (node:internal/util/inspect:1679:11)
    at formatRaw (node:internal/util/inspect:1004:9)
    at formatValue (node:internal/util/inspect:791:10)
    at formatProperty (node:internal/util/inspect:1679:11)
    at formatRaw (node:internal/util/inspect:1004:9)
    at formatValue (node:internal/util/inspect:791:10)
    at Object.inspect (node:internal/util/inspect:338:10)
    at msgResponse (C:\Users\CEDRIC2005\code\eden\LanaPUBLIC\exe\cmd\dev\eval.js:42:108)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
Please open an issue with this stack trace at https://github.com/nodejs/node/issues

    at new NodeError (node:internal/errors:371:5)
    at Function.fail (node:internal/assert:20:9)
    at handleMaxCallStackSize (node:internal/util/inspect:1368:10)
    at formatRaw (node:internal/util/inspect:1011:12)
    at formatValue (node:internal/util/inspect:791:10)
    at formatRaw (node:internal/util/inspect:1004:9)
    at formatProperty (node:internal/util/inspect:1679:11)
    at formatRaw (node:internal/util/inspect:1004:9)
    at formatValue (node:internal/util/inspect:791:10)
    at Object.inspect (node:internal/util/inspect:338:10)
    at getGoodLength (C:\Users\CEDRIC2005\code\eden\LanaPUBLIC\exe\cmd\dev\eval.js:31:65)
    at msgResponse (C:\Users\CEDRIC2005\code\eden\LanaPUBLIC\exe\cmd\dev\eval.js:42:108)
    at Object.exe (C:\Users\CEDRIC2005\code\eden\LanaPUBLIC\exe\cmd\dev\eval.js:59:7)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues

    at new NodeError (node:internal/errors:371:5)
    at Function.fail (node:internal/assert:20:9)
    at handleMaxCallStackSize (node:internal/util/inspect:1368:10)
    at formatRaw (node:internal/util/inspect:1011:12)
    at formatValue (node:internal/util/inspect:791:10)
    at formatProperty (node:internal/util/inspect:1679:11)
    at formatRaw (node:internal/util/inspect:1004:9)
    at formatValue (node:internal/util/inspect:791:10)
    at Object.inspect (node:internal/util/inspect:338:10)
    at getGoodLength (C:\Users\CEDRIC2005\code\eden\LanaPUBLIC\exe\cmd\dev\eval.js:31:65)
    at msgResponse (C:\Users\CEDRIC2005\code\eden\LanaPUBLIC\exe\cmd\dev\eval.js:42:108)
    at Object.exe (C:\Users\CEDRIC2005\code\eden\LanaPUBLIC\exe\cmd\dev\eval.js:59:7)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues

    at new NodeError (node:internal/errors:371:5)
    at Function.fail (node:internal/assert:20:9)
    at handleMaxCallStackSize (node:internal/util/inspect:1368:10)
    at formatRaw (node:internal/util/inspect:1011:12)
    at formatValue (node:internal/util/inspect:791:10)
    at Object.inspect (node:internal/util/inspect:338:10)
    at getGoodLength (C:\Users\CEDRIC2005\code\eden\LanaPUBLIC\exe\cmd\dev\eval.js:31:65)
    at msgResponse (C:\Users\CEDRIC2005\code\eden\LanaPUBLIC\exe\cmd\dev\eval.js:42:108)
    at Object.exe (C:\Users\CEDRIC2005\code\eden\LanaPUBLIC\exe\cmd\dev\eval.js:59:7)
    at processTicksAndRejections (node:internal/process/task_queues:96:5) {
  code: 'ERR_INTERNAL_ASSERTION'
}
```

### Additional information

_No response_

### Edit : 
I see the require response with require(""util"").inspect(data).
But if i use the method JSON.stringify(data) or call a string after, no error occured.

```js
// ENTRIES
JSON.stringify(require(""canvas""), null, 2)

// OUTPUT
{
  ""backends"": {},
  ""version"": ""2.8.0"",
  ""cairoVersion"": ""1.17.4"",
  ""jpegVersion"": ""8"",
  ""gifVersion"": ""5.2.1"",
  ""freetypeVersion"": ""2.10.4"",
  ""rsvgVersion"": ""2.50.3""
}
```
or
```js
// ENTRIES
require(""canvas""); ""hello""

// OUTPUT
""hello""
```

*this code is executed from the method eval*","closed","lynn2910",73949405,"{confirmed-bug,util}","https://github.com/nodejs/node/issues/39866",9,"Ambos",NULL,326,"erro instalar modulo canvas nodejs windows visual studio code erro interno asserção tipoerror metodo height chamado receptor incompativel canvas usar require util inspect data json stringify data erro ocorre assim que modulo canvas requisitado modulo canvas somente modulo erro interno asserção stack trace github nodejs nodejs bug uso incorreto nodejs interno
","A issue relata um erro interno de asserção (TypeError) ao usar o módulo Canvas no Node.js.  Comentários sugerem problemas na instalação e uso do módulo (Refatoração, pois pode exigir ajustes no código ou na instalação do módulo), enquanto outros focam na reprodução do erro e na investigação da causa raiz, incluindo análise do comportamento do `getOwnPropertyDescriptor` (Testes de Regressão, pois implica em testar o funcionamento do módulo em diferentes cenários e plataformas).  A combinação de problemas de instalação/uso e investigação de um erro de comportamento justifica a classificação 'Ambos'."
316,40305,"2021-10-04 06:23:54","2021-10-21 14:55:11","2021-10-21 14:55:11","Error importing ES module with an encoded comma in the URL","### Version

v16.10.0

### Platform

_No response_

### Subsystem

_No response_

### What steps will reproduce the bug?

```js
// test.mjs
import './foo%2cbar.mjs';
```

or

```js
// test2.mjs
await import('./foo%2cbar.mjs');
```

### How often does it reproduce? Is there a required condition?

Always.

### What is the expected behavior?

Should import a module named ""foo,bar.mjs"" located in the same folder, if present, or throw an error with code `ERR_MODULE_NOT_FOUND`.

### What do you see instead?

Throws:

**TypeError [ERR_INVALID_MODULE_SPECIFIER]: Invalid module ""./foo%2cbar.mjs"" must not include encoded ""/"" or ""\\"" characters imported from ./test.mjs**

Note that there is no encoded ""/"" or ""\\"" in ""./foo%2cbar.mjs"", just an encoded "",""!

### Additional information

In my understanding, this behavior results from a bug in [lib/internal/modules/esm/resolve.js](https://github.com/nodejs/node/blob/36e2ffe6dc379043be96ebfd889ccd1a3e38aa84/lib/internal/modules/esm/resolve.js#L359), where the regular expression `encodedSepRegEx` incorrectly matches an encoded slash or comma (""/"" or "","") instead of a slash or backslash.","closed","fasttime",6367844,"{confirmed-bug,esm}","https://github.com/nodejs/node/issues/40305",2,"Nenhum",NULL,17,NULL,"A issue descreve um bug no Node.js relacionado ao import de módulos ES com vírgulas codificadas na URL.  Não há menção a refatoração de código ou testes de regressão. O foco é a correção de um erro de comportamento existente."
318,40099,"2021-09-13 20:03:55","2024-06-21 12:49:57","2024-06-21 12:49:57","doc: weird scrolling/anchor behavior in Chrome and Firefox","# 📗 API Reference Docs Problem

<!--

Thank you for wanting to make nodejs.org better!

This template is for issues with the Node.js API
reference documentation.

For problems with nodejs.org beyond the API
reference documentation, please open an issue
using the issue tracker for our site repository.

  https://github.com/nodejs/nodejs.org

For more general support, please open an issue
using the issue tracker for our help repository.

  https://github.com/nodejs/help

---

For the issue title, please enter a one-line
summary after “doc: ” (preferably 50 characters
or less and no more than 72).

The “✍️” are placeholders signifying requests for
input. Replace them with your responses.

If you are unsure of something, do your best.

-->

## Location

Affected URL(s):

- https://nodejs.org/docs/latest/api/modules.html

## Description

At least on Linux and with Chrome, if you load a very long page, like the CommonJS modules API page, and you either press the End key or otherwise scroll to the bottom and then attempt to scroll up or hold down the Page Up key, the scroll bar makes a lot of strange jumps (backwards and forwards).  Even starting at the top of the page and scrolling down causes the scroll bar to do some large, sudden, and unexpected jumps. However, using the Home and End keys seemingly work just fine.

My guess is there is either some javascript on the page listening for scrolling events in general or on particular elements (like code blocks) and that is somehow causing the weird issues.","closed","mscdex",54666,"{confirmed-bug,doc}","https://github.com/nodejs/node/issues/40099",34,"Ambos",NULL,1012,NULL,"A issue relata problemas de navegação e rolagem na documentação (Refatoração),  e sugere diversas soluções, incluindo testes de desempenho e comparações entre navegadores para avaliar o impacto de diferentes abordagens (Testes de Regressão). Os comentários discutem a performance,  o uso de `content-visibility`,  e a necessidade de refatorar o código para melhorar a experiência do usuário. Portanto, a issue abrange ambos os aspectos."
319,40030,"2021-09-07 13:40:31","2021-09-09 11:52:17","2021-09-10 03:46:06","`Check failed: !holder_map.has_named_interceptor().` when running `jest`","### Version

16.9.0

### Platform

Linux oliver-home 5.10.16.3-microsoft-standard-WSL2 #1 SMP Fri Apr 2 22:23:49 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

vm

### What steps will reproduce the bug?

https://github.com/nodejs/node/issues/40030#issuecomment-914417795

### How often does it reproduce? Is there a required condition?

Every single time.

### What is the expected behavior?

Tests run as usual.

### What do you see instead?

```
#
# Fatal error in , line 0
# Check failed: !holder_map.has_named_interceptor().
#
#
#
#FailureMessage Object: 0x7ffe016dc1c0
 1: 0xb691f1  [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
 2: 0x1bf3094 V8_Fatal(char const*, ...) [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
 3: 0x10ac4a1 v8::internal::ConcurrentLookupIterator::TryGetPropertyCell(v8::internal::Isolate*, v8::internal::LocalIsolate*, v8::internal::Handle<v8::internal::JSGlobalObject>, v8::internal::Handle<v8::internal::Name>) [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
 4: 0x1c5aa55  [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
 5: 0x1c5b9eb v8::internal::compiler::JSGlobalObjectRef::GetPropertyCell(v8::internal::compiler::NameRef const&, v8::internal::compiler::SerializationPolicy) const [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
 6: 0x1e61ba3 v8::internal::compiler::JSNativeContextSpecialization::ReduceNamedAccess(v8::internal::compiler::Node*, v8::internal::compiler::Node*, v8::internal::compiler::NamedAccessFeedback const&, v8::internal::compiler::AccessMode, v8::internal::compiler::Node*) [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
 7: 0x1e623c4 v8::internal::compiler::JSNativeContextSpecialization::ReducePropertyAccess(v8::internal::compiler::Node*, v8::internal::compiler::Node*, v8::base::Optional<v8::internal::compiler::NameRef>, v8::internal::compiler::Node*, v8::internal::compiler::FeedbackSource const&, v8::internal::compiler::AccessMode) [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
 8: 0x1e6274e v8::internal::compiler::JSNativeContextSpecialization::ReduceJSLoadNamed(v8::internal::compiler::Node*) [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
 9: 0x1df5e0a v8::internal::compiler::Reducer::Reduce(v8::internal::compiler::Node*, v8::internal::compiler::ObserveNodeManager*) [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
10: 0x1c92604  [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
11: 0x1df60be v8::internal::compiler::GraphReducer::Reduce(v8::internal::compiler::Node*) [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
12: 0x1df7895 v8::internal::compiler::GraphReducer::ReduceTop() [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
13: 0x1df7c48 v8::internal::compiler::GraphReducer::ReduceNode(v8::internal::compiler::Node*) [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
14: 0x1ca03fd v8::internal::compiler::InliningPhase::Run(v8::internal::compiler::PipelineData*, v8::internal::Zone*) [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
15: 0x1ca1291 v8::internal::compiler::PipelineImpl::CreateGraph() [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
16: 0x1ca1668 v8::internal::compiler::PipelineCompilationJob::PrepareJobImpl(v8::internal::Isolate*) [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
17: 0xd94f5d v8::internal::OptimizedCompilationJob::PrepareJob(v8::internal::Isolate*) [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
18: 0xd96358  [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
19: 0xd97e70 v8::internal::Compiler::CompileOptimized(v8::internal::Isolate*, v8::internal::Handle<v8::internal::JSFunction>, v8::internal::ConcurrencyMode, v8::internal::CodeKind) [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
20: 0x11f4463 v8::internal::Runtime_CompileOptimized_Concurrent(int, unsigned long*, v8::internal::Isolate*) [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
21: 0x15e67f9  [/home/oliver/.nvm/versions/node/v16.9.0/bin/node]
```

### Additional information

#13804 sounds very related
16.8.0 didn't produce this result and still works as expected.","closed","oliversalzburg",1658949,"{confirmed-bug,""v8 engine""}","https://github.com/nodejs/node/issues/40030",15,"Testes de Regressão",NULL,2,"fatal error check failed holder_map has named interceptor test run usual
","O título da issue ""`Check failed: !holder_map.has_named_interceptor().` when running `jest`"" indica um erro durante a execução de testes com Jest.  Comentários como ""reproduce bug crash test"", ""test fail github action"",  ""repro jest"", e a menção repetida a testes (e.g., ""citgm smoker test report junit"") reforçam a natureza relacionada a testes de regressão da issue. A busca por reproduzir o bug em testes ('reproduce bug crash test') e a falha nos testes do Github Actions também apontam fortemente para a categoria Testes de Regressão."
180,50700,"2023-11-13 10:01:37","2023-11-19 21:22:51","2023-11-19 21:22:51","Dynamic `import` attributes broken with multiple attributes","I was trying to adapt a [V8 test](https://github.com/nodejs/node/blob/main/deps/v8/test/mjsunit/harmony/modules-import-assertions-dynamic-6.mjs) to run it in Node.js

The following version fails in a C++ CHECK (it doesn't matter if the json file exists or not):

```js
import assert from 'assert';

var life;
import('./modules-skip-1.json', { with: { type: 'json', notARealAssertion: 'value' } }).then(
    namespace => life = namespace.default.life).then(() => {
      assert.strictEqual(life, 42);
    });

var life2;
import('./modules-skip-1.json', { with: { 0: 'value', type: 'json' } }).then(
    namespace => life2 = namespace.default.life).then(() => {
      assert.strictEqual(life2, 42);
    });
```

```
#
# Fatal error in , line 0
# Check failed: i < self->length().
#
#
#
#FailureMessage Object: 0x16d934a68
 1: 0x1025fad74 node::NodePlatform::GetStackTracePrinter()::$_3::__invoke() [/Users/mzasso/.volta/tools/image/node/21.1.0/bin/node]
 2: 0x1036dbcc4 V8_Fatal(char const*, ...) [/Users/mzasso/.volta/tools/image/node/21.1.0/bin/node]
 3: 0x10273d8bc v8::FixedArray::Get(v8::Local<v8::Context>, int) const [/Users/mzasso/.volta/tools/image/node/21.1.0/bin/node]
 4: 0x10255ad78 node::loader::createImportAttributesContainer(node::Environment*, v8::Isolate*, v8::Local<v8::FixedArray>) [/Users/mzasso/.volta/tools/image/node/21.1.0/bin/node]
 5: 0x10255c3d8 node::loader::ImportModuleDynamically(v8::Local<v8::Context>, v8::Local<v8::Data>, v8::Local<v8::Value>, v8::Local<v8::String>, v8::Local<v8::FixedArray>) [/Users/mzasso/.volta/tools/image/node/21.1.0/bin/node]
 6: 0x102895ab0 v8::internal::Isolate::RunHostImportModuleDynamicallyCallback(v8::internal::MaybeHandle<v8::internal::Script>, v8::internal::Handle<v8::internal::Object>, v8::internal::MaybeHandle<v8::internal::Object>) [/Users/mzasso/.volta/tools/image/node/21.1.0/bin/node]
 7: 0x102cc3670 v8::internal::Runtime_DynamicImportCall(int, unsigned long*, v8::internal::Isolate*) [/Users/mzasso/.volta/tools/image/node/21.1.0/bin/node]
 8: 0x103057768 Builtins_CEntry_Return1_ArgvInRegister_NoBuiltinExit [/Users/mzasso/.volta/tools/image/node/21.1.0/bin/node]
```

This happens in Node.js 21 and v20.x-staging.","closed","targos",2352663,"{confirmed-bug,esm}","https://github.com/nodejs/node/issues/50700",4,"Refatoração",NULL,6,"adapt v8 test run nodejs version fail c++ check json file exist import assert life import module skip json then namespace life assert strict equal life life import module skip json then namespace life assert strict equal life fatal error check fail length failure message node get stack trace printer v8 fatal fixed array get loader create import attributes container loader import module dynamically isolate run host import module dynamically callback runtime dynamic import call builtins centry return argv register builtin exit node v20 staging
","O título da issue ""Dynamic `import` attributes broken with multiple attributes"" e o corpo da issue indicam problemas com a importação dinâmica de módulos e atributos.  As menções a 'v8', 'nodejs', 'C++',  'JSON', e a necessidade de adaptar testes ('adapt v8 test run nodejs version') sugerem que a solução envolverá mudanças no código existente para corrigir problemas de funcionamento, sem necessariamente adicionar novos recursos ou testes. A discussão nos comentários gira em torno de erros específicos em uma implementação existente, reforçando a necessidade de refatoração para corrigir esses erros."
181,50437,"2023-10-27 22:42:56","2024-08-08 22:00:47","2024-08-08 22:00:47","`fs/promises`'s `readFile` returns truncated content for files in `/proc/net/`","### Version

v21.1.0

### Platform

Linux ubuntu 6.2.0-35-generic #35~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Fri Oct  6 10:23:26 UTC 2 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

fs/promises

### What steps will reproduce the bug?

Compare the length of the content returned by `fs/promises.readFile` and `fs.readFile` when reading any file larger than 4 KiB in `/proc/net`. `fs/promises` only returns the first 4 KiB or so.

```js
$ node
Welcome to Node.js v21.1.0.
Type "".help"" for more information.
> require(""fs/promises"").readFile(""/proc/net/unix"", ""utf-8"").then(x => console.log(x.length))
Promise {
  <pending>,
  [Symbol(async_id_symbol)]: 31,
  [Symbol(trigger_async_id_symbol)]: 25
}
> 4059
require(""fs"").readFile(""/proc/net/unix"", ""utf-8"", (_, x) => console.log(x.length))
undefined
> 65432
```

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

`fs/promises`'s `readFile` and `fs.readFile` return the same untruncated file contents.

### What do you see instead?

`fs/promises`'s `readFile` truncates procfs file contents to around 4 KiB.

### Additional information

_No response_","closed","notcake",2363584,"{confirmed-bug,fs,promises,linux}","https://github.com/nodejs/node/issues/50437",6,"Refatoração",NULL,286,"readFile  procfs  file  content  kib  promise  node  fs  diferença  comprimento  retorno  arquivo  maior  kib  proc  net  sempre  comportamento  esperado  igual  truncado
","A issue descreve um problema de leitura de arquivos truncados em `/proc/net/` usando `fs/promises.readFile`.  O título e a descrição sugerem uma necessidade de correção no código relacionado à leitura de arquivos neste diretório específico.  Os comentários discutem possíveis otimizações e abordagens para resolver o problema de leitura, indicando uma refatoração do código para corrigir o comportamento inesperado e garantir a leitura completa dos arquivos. Não há menção explícita à necessidade de novos testes de regressão, apesar de uma correção desse tipo normalmente os justificar."
182,50427,"2023-10-27 12:28:03","2023-11-01 12:38:03","2023-11-01 12:38:03","`--import` order is wrong when one of the modules imports a module","### Version

v20.9.0

### Platform

Linux XXXXXXX 5.15.90.1-microsoft-standard-WSL2 #1 SMP Fri Jan 27 02:56:13 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

module

### What steps will reproduce the bug?

1. Run `git clone https://github.com/giltayar/import-order-bug.git`
2. Run the following command:

```sh
$ node --import ./a.mjs --import ./b.mjs main.mjs
a...
b...
```

The output here makes sense, as the order of execution of `a.js` and `b.js` is first `a` then `b`

3. Go to `a.js` and uncomment the first line (with `import './sub.mjs`). Note that `sub.mjs` is an empty file.

Now run the same command again:

```sh
$ node --import ./a.mjs --import ./b.mjs main.mjs
b...
a...
```

This doesn't make sense: the order of execution of the imports shouldn't change if one of the modules has an `import` and the other doesn't.


### How often does it reproduce? Is there a required condition?

Every time.

### What is the expected behavior? Why is that the expected behavior?

The order of the execution of the modules in `--import` should not change based on whether they are importing another module or not. 

### What do you see instead?

The order of the execution of the modules in `--import` changes based on whether they are importing another module or not. 

### Additional information

This stumped me for _3_ hours when modifying my ESM loaders talk for NodeConf EU and the new `register` didn't work with loader chaining. It took me 3 hours to figure out that the chaining didn't change, but the execution order in `--import` does, and that it has nothing to do with loaders.","closed","giltayar",403268,"{confirmed-bug,esm}","https://github.com/nodejs/node/issues/50427",20,"Refatoração",NULL,5,"problema ordem execução módulo importar outro módulo importar mudança ordem execução módulo importar outro módulo execução módulo importar outro módulo  problema  ordem execução  módulo  importar  outro  módulo  importar  mudança  ordem  execução  módulo  importar  outro  módulo  execução  módulo  importar  outro  módulo
","A issue descreve um problema na ordem de importação de módulos (`--import` order is wrong).  O corpo da issue e os comentários focam em como a ordem de execução dos módulos afeta o comportamento do programa, sugerindo mudanças na forma como o carregador de módulos lida com as importações.  Não há menção direta a testes de regressão, embora uma refatoração para corrigir a ordem de importação possa exigir testes subsequentes para garantir que a mudança não introduza novos bugs. A ênfase está na alteração do código para resolver um problema de ordem de execução, característica principal de uma refatoração."
321,39959,"2021-08-31 15:51:57","2022-05-25 14:31:14","2022-05-25 14:31:14","Web Cryptography API compliance wrt. key import/export","Having gone through [Web Cryptography API W3C Editor's Draft](https://w3c.github.io/webcrypto/) here are the discrepancies between the specification and [Node.js v16.8.0 Web Crypto API Module](https://nodejs.org/docs/v16.8.0/api/webcrypto.html) actual implementation when it comes to SubtleCrypto.importKey, SubtleCrypto.exportKey, and in the case of RSA-PSS also SubtleCrypto.sign and SubtleCrypto.verify.

The point is to make a catalogue of known issues and open a discussion about _how_ and _if_ to handle them, knowing upfront that not everything can be achieved the possible resolution for some may just be a note in the documentation about the caveats, similar to what the [Chromium Project > WebCrypto](https://www.chromium.org/blink/webcrypto) page lists.

## RSASSA-PKCS1-v1_5 importKey ""spki""

- does not assert the Public Key type to be an RSA one, it is possible to import any public key
  - proposal: assert that `keyObject.asymmetricKeyType` is `'rsa'` and throw `DataError` if it is not
- does not allow for keys with OID `sha1WithRSAEncryption`, `sha256WithRSAEncryption`, `sha384WithRSAEncryption`, and `sha512WithRSAEncryption`
  - proposal: document this lack of support since OpenSSL does not support these specialized OIDs

## RSASSA-PKCS1-v1_5 importKey ""pkcs8""

- does not assert the Private Key type to be an RSA one, it is possible to import any private key
  - proposal: assert that `keyObject.asymmetricKeyType` is `'rsa'` and throw `DataError` if it is not
- does not allow for keys with OID `sha1WithRSAEncryption`, `sha256WithRSAEncryption`, `sha384WithRSAEncryption`, and `sha512WithRSAEncryption`
  - proposal: document this lack of support since OpenSSL does not support these specialized OIDs

## RSA-PSS importKey ""spki""

- does not assert the Public Key type to be an RSA or RSA-PSS one, it is possible to import any public key
  - proposal: assert that `keyObject.asymmetricKeyType` is `'rsa'` or `'rsa-pss'` and throw `DataError` if it is not
- does not assert that `rsa-pss` key `RSASSA-PSS-params` sequence is present
  - proposal: when `keyObject.asymmetricKeyType` is `'rsa-pss'` assert that `keyObject.asymmetricKeyDetails.mgf1HashAlgorithm` is not `undefined`
- does not assert that `rsa-pss` key `RSASSA-PSS-params` sequence `maskGenAlgorithm` and `hashAlgorithm` match the values required for the given algorithm
  - proposal: when `keyObject.asymmetricKeyType` is `'rsa-pss'` assert that `keyObject.asymmetricKeyDetails.hashAlgorithm` which in turn equals the Node.js normalized digest algorithm name for the WebCrypto algorithm specified `hash.name`

## RSA-PSS exportKey ""spki""

- does not respect the requirement to export OID `id-RSASSA-PSS` keys. The OID and content of the key will always depend on the internal KeyObject representation. If it is an `'rsa'` key, the result will use `rsaEncryption`.
- does not respect the requirement to export OID `id-RSASSA-PSS` keys with `RSASSA-PSS-params` sequence with values depending on the WebCrypto algorithm of the CryptoKey. The behaviour will only be per-spec if the key imported was an RSA-PSS one (given we choose to fix the import steps), but when the imported key was an `rsaEncryption` one (allowed) this requirement will not be upheld.

## RSA-PSS verify

- fails the verify operation with a rejection when the internal `rsa-pss` KeyObject has `keyObject.asymmetricKeyDetails.saltLength` specified larger than the one requested to be used.
  - proposal: since the saltLength is not specified at key import but rather the verify operation, according to the spec, if errors are encountered the promise should be resolved with `false`.

## RSA-PSS importKey ""pkcs8""

- does not assert the Private Key type to be an RSA or RSA-PSS one, it is possible to import any private key
  - proposal: assert that `keyObject.asymmetricKeyType` is `'rsa'` or `'rsa-pss'` and throw `DataError` if it is not
- does not assert that `rsa-pss` key `RSASSA-PSS-params` sequence is present
  - proposal: when `keyObject.asymmetricKeyType` is `'rsa-pss'` assert that `keyObject.asymmetricKeyDetails.mgf1HashAlgorithm` is not `undefined`
- does not assert that `rsa-pss` key `RSASSA-PSS-params` sequence `maskGenAlgorithm` and `hashAlgorithm` match the values required for the given algorithm
  - proposal: when `keyObject.asymmetricKeyType` is `'rsa-pss'` assert that `keyObject.asymmetricKeyDetails.hashAlgorithm` which in turn equals the Node.js normalized digest algorithm name for the WebCrypto algorithm specified `hash.name`

## RSA-PSS exportKey ""pkcs8""

- does not respect the requirement to export OID `id-RSASSA-PSS` keys. The OID and content of the key will always depend on the internal KeyObject representation. If it is an `'rsa'` key, the result will use `rsaEncryption`.
- does not respect the requirement to export OID `id-RSASSA-PSS` keys with `RSASSA-PSS-params` sequence with values depending on the WebCrypto algorithm of the CryptoKey. The behaviour will only be per-spec if the key imported was an RSA-PSS one (given we choose to fix the import steps), but when the imported key was an `rsaEncryption` one (allowed) this requirement will not be upheld.

## RSA-PSS sign

- fails the sign operation with an openssl rejection when the internal `rsa-pss` KeyObject has `keyObject.asymmetricKeyDetails.saltLength` specified larger than the one requested to be used.
  - proposal: since the saltLength is not specified at key import but rather the sign operation, according to the spec, if errors are encountered the promise should be rejected with `OperationError`.

## RSA-OAEP importKey ""spki""

- does not assert the Public Key type to be an RSA one, it is possible to import any public key
  - proposal: assert that `keyObject.asymmetricKeyType` is `'rsa'` and throw `DataError` if it is not
- does not support import of OID `id-RSAES-OAEP` keys
  - proposal: document this lack of support since OpenSSL does not support? this specialized OID
  
## RSA-OAEP importKey ""pkcs8""

- does not assert the Private Key type to be an RSA or RSA-PSS one, it is possible to import any private key
  - proposal: assert that `keyObject.asymmetricKeyType` is `'rsa'` or `'rsa-pss'` and throw `DataError` if it is not
- does not support import of OID `id-RSAES-OAEP` keys
  - proposal: document this lack of support since OpenSSL does not support? this specialized OID

## RSA-OAEP exportKey ""spki"" and ""pkcs8""

- given the lack of support for OID `id-RSAES-OAEP` we will always export OID `rsaEncryption`
  - proposal: document this caveat since OpenSSL does not support? this specialized OID

## ECDH exportKey ""spki"" and ""pkcs8""

- given the lack of support for OID `id-ecDH` we will always export OID `id-ecPublicKey`
  - proposal: document this caveat since OpenSSL does not support? this specialized OID

## General

CryptoKey implementation is a rather thin layer on top of a KeyObject instance and that's where most of the import/export OID issues stem from, this is further elevated when `'node.keyObject'` is used as the import key format.

---

NB: [spki](https://w3c.github.io/webcrypto/#spki-mapping) and [pkcs8](https://w3c.github.io/webcrypto/#pkcs8-mapping) OID mappings","closed","panva",241506,"{confirmed-bug,crypto,discuss,webcrypto}","https://github.com/nodejs/node/issues/39959",3,"Ambos",NULL,267,"rsassa pkcs v1_5 importkey spki assert public key type rsa import any public key proposal assert keyobject asymmetrickeytype rsa throw dataerror rsa importkey pkcs assert private key type rsa import any private key proposal assert keyobject asymmetrickeytype rsa throw dataerror support oid sha1withrsaencryption sha256withrsaencryption sha384withrsaencryption sha512withrsaencryption proposal document lack support openssl support specialized oid rsapss importkey spki assert public key type rsa rsapss import any public key proposal assert keyobject asymmetrickeytype rsa rsa pss throw dataerror assert rsapss key rsassapss params sequence present proposal keyobject asymmetrickeytype rsapss assert keyobject asymmetrickeydetails mgf1hashalgorithm undefined assert rsapss key rsassapss params sequence maskgenalgorithm hashalgorithm match value require algorithm proposal keyobject asymmetrickeytype rsapss assert keyobject asymmetrickeydetails hashalgorithm equal nodejs normalize digest algorithm name webcrypto algorithm specify hash name rsapss exportkey spki respect requirement export oid id rsassapss oid content key always depend internal keyobject representation rsa key result use rsaencryption respect requirement export oid id rsassapss key rsassapss params sequence value depend webcrypto algorithm cryptokey behaviour per spec key import rsapss one import step import key rsaencryption one requirement uphold rsapss verify fail verify operation rejection internal rsapss keyobject keyobject asymmetrickeydetails saltlength specify larger one request use proposal saltlength specify key import verify operation spec error encounter promise resolve false rsapss importkey pkcs assert private key type rsa rsapss import any private key proposal assert keyobject asymmetrickeytype rsa rsa pss throw dataerror assert rsapss key rsassapss params sequence present proposal keyobject asymmetrickeytype rsapss assert keyobject asymmetrickeydetails mgf1hashalgorithm undefined assert rsapss key rsassapss params sequence maskgenalgorithm hashalgorithm match value require algorithm proposal keyobject asymmetrickeytype rsapss assert keyobject asymmetrickeydetails hashalgorithm equal nodejs normalize digest algorithm name webcrypto algorithm specify hash name rsapss exportkey pkcs respect requirement export oid id rsassapss oid content key always depend internal keyobject representation rsa key result use rsaencryption respect requirement export oid id rsassapss key rsassapss params sequence value depend webcrypto algorithm cryptokey behaviour per spec key import rsapss one import step import key rsaencryption one requirement uphold rsapss sign fail sign operation openssl rejection internal rsapss keyobject keyobject asymmetrickeydetails saltlength specify larger one request use proposal saltlength specify key import sign operation spec error encounter promise reject operationerror rsa oaep importkey spki assert public key type rsa import any public key proposal assert keyobject asymmetrickeytype rsa throw dataerror support import oid id rsaes oaep proposal document lack support openssl support specialized oid rsa oaep importkey pkcs assert private key type rsa rsapss import any private key proposal assert keyobject asymmetrickeytype rsa rsa pss throw dataerror support import oid id rsaes oaep proposal document lack support openssl support specialized oid rsa oaep exportkey spki pkcs lack support oid id rsaes oaep always export oid rsaencryption proposal document caveat openssl support specialized oid ecdh exportkey spki pkcs lack support oid id ecdh always export oid id ecpk proposal document caveat openssl support specialized oid general cryptokey implementation rather thin layer top keyobject instance import export oid issue stem further elevate node keyobject use import key format
","O título e corpo da issue mencionam testes de conformidade da Web Cryptography API, incluindo importação e exportação de chaves, e a resolução de problemas de interoperabilidade entre diferentes implementações (Testes de Regressão).  Os comentários discutem a necessidade de ajustes e correções na implementação para garantir a conformidade com os padrões e o funcionamento correto, indicando refatoração do código para atender aos requisitos de conformidade e resolver os problemas encontrados durante os testes."
185,50233,"2023-10-18 03:04:25","2023-12-22 10:15:08","2024-03-07 11:37:50","at processTimers (node:internal/timers:514:7) {   code: 'ERR_INTERNAL_ASSERTION' }","### Version

v20.6.1

### Platform

Darwin 192-168-1-108.tpgi.com.au 22.4.0 Darwin Kernel Version 22.4.0: Mon Mar  6 20:59:28 PST 2023; root:xnu-8796.101.5~3/RELEASE_ARM64_T6000 arm64

### Subsystem

node:internal/timers

### What steps will reproduce the bug?

I'm still working on simplifying this repro - currently it depends on the `node-fetch` library, my version is `v2.6.4`.

Running `node repro.js` and waiting about a minute yields the results in `repro.txt` on my machine. I've included the original typescript for clarity as well.
[repro.zip](https://github.com/nodejs/node/files/12976180/repro.zip)


### How often does it reproduce? Is there a required condition?

Reliably with this repro script.

### What is the expected behavior? Why is that the expected behavior?

I would expect this script to either hang or fail with an exception about running out of file descriptors or RAM.

### What do you see instead?

```
{""t"":""2023-10-18T03:00:22.029Z"",""reason"":{""type"":""aborted"",""message"":""The user aborted a request.""}}
{""t"":""2023-10-18T03:00:31.887Z"",""reason"":{""type"":""aborted"",""message"":""The user aborted a request.""}}
{""t"":""2023-10-18T03:00:37.817Z"",""reason"":{""type"":""aborted"",""message"":""The user aborted a request.""}}
node:internal/assert:14
    throw new ERR_INTERNAL_ASSERTION(message);
    ^

Error [ERR_INTERNAL_ASSERTION]: This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues

    at new NodeError (node:internal/errors:405:5)
    at assert (node:internal/assert:14:11)
    at internalConnectMultiple (node:net:1118:3)
    at Timeout.internalConnectMultipleTimeout (node:net:1687:3)
    at listOnTimeout (node:internal/timers:575:11)
    at process.processTimers (node:internal/timers:514:7) {
  code: 'ERR_INTERNAL_ASSERTION'
}
```

### Additional information

Since posting this i've tried eliminating the node-fetch dependency and using node's builtin `fetch`, and I can't reproduce this issue with `fetch`. Not sure what the major differences are that cause this.","closed","james-rms",18162835,"{confirmed-bug,net}","https://github.com/nodejs/node/issues/50233",10,"Nenhum",NULL,65,"user abort request node internal assertion error node fetch dependency builtin fetch reproduce issue
","A issue descreve um erro de asserção interna ('ERR_INTERNAL_ASSERTION') no Node.js, relacionado a um problema de timeout e possivelmente com a biblioteca gRPC.  Os comentários discutem tentativas de reprodução, versões do Node.js,  workarounds e problemas de rede. Não há menção explícita a refatoração de código ou testes de regressão.  O foco é na resolução de um bug de produção."
186,50176,"2023-10-13 14:35:37","2023-10-16 22:38:33","2023-10-16 22:38:33","impossible to use spec test reporter without new","### Version

v18.18.1 and v20.8.0

### Platform

all

### Subsystem

node:test

### What steps will reproduce the bug?

```js
const { spec } = require('node:test/reporters');
const { run } = require('node:test');
const path = require('node:path');

run({ files: [path.resolve('./tests/test.js')] })
  .compose(spec)
  .pipe(process.stdout);
```

Nothing gets printed.

Instead, the following works:

```js
const { spec } = require('node:test/reporters');
const { run } = require('node:test');
const path = require('node:path');

run({ files: [path.resolve('./tests/test.js')] })
  .compose(new spec)
  .pipe(process.stdout);
```

### How often does it reproduce? Is there a required condition?

all the time.

### What is the expected behavior? Why is that the expected behavior?

_No response_

### What do you see instead?

No output without new

### Additional information

_No response_","closed","mcollina",52195,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/50176",6,"Refatoração",NULL,3,"version v18 v20 platform subsystem node test step reproduce bug code print work expect behavior output new
","A issue descreve problemas com a utilização do `spec test reporter` em novas versões (v18, v20).  Os comentários indicam que a causa raiz é a necessidade de usar o `new` para chamar uma função, que aparentemente não é mais necessária.  A solução proposta parece ser a remoção dessa necessidade, o que se encaixa na definição de refatoração (mudança de código para melhorar a estrutura sem alterar a funcionalidade).  Não há menção a novos testes ou falhas em testes existentes que indiquem a necessidade de testes de regressão."
187,49960,"2023-09-29 16:27:52","2023-10-03 00:48:09","2023-10-03 00:48:09","segfault in ada::url_aggregator","### Version

v20.7.0

### Platform

Darwin moxy.lan 22.6.0 Darwin Kernel Version 22.6.0: Fri Sep 15 13:41:28 PDT 2023; root:xnu-8796.141.3.700.8~1/RELEASE_ARM64_T6000 arm64

### Subsystem

url

### What steps will reproduce the bug?

It's unclear, unfortunately. I'm finding this only when running quite a lot of node processes at one time, when testing all the packages in the tapjs monorepo. It is very sporadic, and only happens on node 20.

### How often does it reproduce? Is there a required condition?

Sporadically

### What is the expected behavior? Why is that the expected behavior?

Expect that a segfault will not happen.

This is expected because programs that don't segfault tend to be more useful 😅

### What do you see instead?

Occasional segfaults.

### Additional information

Here's the stack trace where the segv happens:

```
Thread 7 Crashed:
0   node                          	       0x10145c7b0 ada::url_aggregator ada::parser::parse_url<ada::url_aggregator>(std::__1::basic_string_view<char, std::__1::char_traits<char>>, ada::url_aggregator const*) + 280
1   node                          	       0x1014614f0 ada::can_parse(std::__1::basic_string_view<char, std::__1::char_traits<char>>, std::__1::basic_string_view<char, std::__1::char_traits<char>> const*) + 384
2   ???                           	       0x1160a8bb0 ???
3   node                          	       0x100eaf210 Builtins_AsyncFunctionAwaitResolveClosure + 80
4   node                          	       0x100f5cfb8 Builtins_PromiseFulfillReactionJob + 56
5   node                          	       0x100e9eb94 Builtins_RunMicrotasks + 596
6   node                          	       0x100e763f4 Builtins_JSRunMicrotasksEntry + 148
7   node                          	       0x10074bc58 v8::internal::(anonymous namespace)::Invoke(v8::internal::Isolate*, v8::internal::(anonymous namespace)::InvokeParams const&) + 2932
8   node                          	       0x10074c144 v8::internal::(anonymous namespace)::InvokeWithTryCatch(v8::internal::Isolate*, v8::internal::(anonymous namespace)::InvokeParams const&) + 88
9   node                          	       0x10074c320 v8::internal::Execution::TryRunMicrotasks(v8::internal::Isolate*, v8::internal::MicrotaskQueue*) + 64
10  node                          	       0x1007733dc v8::internal::MicrotaskQueue::RunMicrotasks(v8::internal::Isolate*) + 324
11  node                          	       0x100773b78 v8::internal::MicrotaskQueue::PerformCheckpoint(v8::Isolate*) + 124
12  node                          	       0x1003b8c64 node::InternalCallbackScope::Close() + 252
13  node                          	       0x1003b901c node::InternalMakeCallback(node::Environment*, v8::Local<v8::Object>, v8::Local<v8::Object>, v8::Local<v8::Function>, int, v8::Local<v8::Value>*, node::async_context) + 576
14  node                          	       0x1003cf48c node::AsyncWrap::MakeCallback(v8::Local<v8::Function>, int, v8::Local<v8::Value>*) + 188
15  node                          	       0x1004c9b9c node::worker::MessagePort::OnMessage(node::worker::MessagePort::MessageProcessingMode) + 504
16  node                          	       0x100e55658 uv__async_io + 268
17  node                          	       0x100e67730 uv__io_poll + 1020
18  node                          	       0x100e55c1c uv_run + 476
19  node                          	       0x1003b9754 node::SpinEventLoopInternal(node::Environment*) + 256
20  node                          	       0x10053a7b8 node::worker::Worker::Run() + 2164
21  node                          	       0x10053dad0 node::worker::Worker::StartThread(v8::FunctionCallbackInfo<v8::Value> const&)::$_3::__invoke(void*) + 56
22  libsystem_pthread.dylib       	       0x181ee7fa8 _pthread_start + 148
23  libsystem_pthread.dylib       	       0x181ee2da0 thread_start + 8
```

Stack is always the same when the fault occurs.

Full macOS ips report: https://gist.github.com/isaacs/4f313a514b3a95e6268381e957fb32fe

Happy to capture a proper core dump and share it with y'all if that's useful, but I'd rather not put the contents of my computer's memory buffer on the internet in a gist, just in to be on the safe side. Could be some sensitive stuff in process.env or something.","closed","isaacs",9287,"{confirmed-bug,whatwg-url}","https://github.com/nodejs/node/issues/49960",8,"Ambos",NULL,3,"segfault node process sporadic node twenty package tapjs monorepo expect segfault happen program segfault useful occasional segfault stack trace thread crash node ada url aggregator ada parser parse url ada url aggregator ada can parse node builtin asyncfunctionawaitresolveclosure builtin promisefulfillreactionjob builtin runmicrotasks builtin jsrunmicrotasksentry node anonymous namespace invoke node anonymous namespace invokewithtrycatch node anonymous namespace tryrunmicrotasks node internal microtaskqueue runmicrotasks node internal microtaskqueue performcheckpoint node internalcallbackscope close node internalmakecallback node asyncwrap makecallback node worker messageport onmessage uv async io uv io poll uv run node spineventloopinternal node worker worker run node worker worker startthread libsystem pthread pthread start libsystem pthread thread start stack fault mac os ips report share content computer memory buffer internet gist safe side sensitive stuff process env
","A issue descreve um segfault (falha de segmentação) no processo Node.js dentro do pacote `ada::url_aggregator`.  Comentários sugerem investigação em código C++ (possível vazamento de memória, acesso a memória inválida, corrida de dados), testes de regressão para reproduzir o erro e a necessidade de um caso de teste reprodutível. A menção a refatoração do código Ada e testes em builds diferentes (x64, ARM) indica a necessidade de ambos: refatoração para corrigir a causa raiz e testes de regressão para garantir a estabilidade após as mudanças."
188,49927,"2023-09-28 11:59:40","2023-10-03 18:19:53","2023-10-03 18:19:53","spec reporter crash when `--require`d file keep the process alive and timeout reached ","### Version

20.7.0

### Platform

Darwin Razs-MacBook-Pro.local 23.0.0 Darwin Kernel Version 23.0.0: Fri Sep 15 14:41:43 PDT 2023; root:xnu-10002.1.13~1/RELEASE_ARM64_T6000 arm64

### Subsystem

test_runner

### What steps will reproduce the bug?

1. clone https://github.com/rluvaton/spec-reporter-crash-when-timeout-created-in-required-hook
2. run `npm test` (this will run `node --require ./setup.js ./run-tests.js`)

### How often does it reproduce? Is there a required condition?

always, you should have something that keeps the process up in the `--required` file

### What is the expected behavior? Why is that the expected behavior?

to not crash

### What do you see instead?

crashing:

```
$ npm test

> spec-reporter-crash-when-timeout-created-in-required-hook@1.0.0 test
> node --require ./setup.js ./run-tests.js

✔ should get a (0.88675ms)
node:internal/test_runner/harness:40
      throw err;
      ^

TypeError [ERR_INVALID_ARG_TYPE]: The ""to"" argument must be of type string. Received undefined
    at new NodeError (node:internal/errors:405:5)
    at validateString (node:internal/validators:162:11)
    at relative (node:path:1195:5)
    at SpecReporter._flush (node:internal/test_runner/reporter/spec:148:23)
    at SpecReporter.final [as _final] (node:internal/streams/transform:132:10)
    at callFinal (node:internal/streams/writable:707:12)
    at prefinish (node:internal/streams/writable:719:7)
    at finishMaybe (node:internal/streams/writable:729:5)
    at Writable.end (node:internal/streams/writable:641:5)
    at TestsStream.endFn (node:internal/streams/pipeline:430:11)
Emitted 'error' event on Readable instance at:
    at emitErrorNT (node:internal/streams/destroy:151:8)
    at emitErrorCloseNT (node:internal/streams/destroy:116:3)
    at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {
  code: 'ERR_INVALID_ARG_TYPE'
}

Node.js v20.7.0
```

### Additional information

_No response_","closed","rluvaton",16746759,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/49927",1,"Testes de Regressão",NULL,5,"clone run npm test node require setup run test should get typeerror argument type string receive undefined node internal errors validate string node internal validators relative node path specreporter flush node internal test runner reporter spec specreporter final node internal streams transform callfinal node internal streams writable prefinish node internal streams writable finishmaybe node internal streams writable writable node internal streams writable teststream endfn node internal streams pipeline emit error event readable instance emiterrornt node internal streams destroy emiterrorclosent node internal streams destroy process processticksandrejections node internal process task queues code err invalid arg type node version
","O título da issue (""spec reporter crash when `--require`d file keep the process alive and timeout reached"") indica um problema de falha durante a execução de testes (especificamente, relacionado ao `spec reporter`).  O corpo da issue descreve um erro durante a execução de testes, mencionando `npm test`, `typeerror`,  e  stack trace com referências a módulos internos do Node.js relacionados a testes e streams.  Não há menção explícita a refatoração de código."
328,39758,"2021-08-13 16:10:58","2022-01-04 15:13:59","2022-01-04 15:13:59","`readableStream.tee()` doesn't work when using `process.nextTick(...)`","### Version

v16.6.2

### Platform

Linux solus 5.13.8-191.current #1 SMP PREEMPT Fri Aug 6 11:29:58 UTC 2021 x86_64 GNU/Linux

### Subsystem

stream/web

### What steps will reproduce the bug?

```js
import {ReadableStream} from 'stream/web';

let controller;
let start = c => (controller = c);
let pull = () => {
  if (pull.called) return;
  pull.called = true;

  process.nextTick(() => {
   controller.enqueue(new Uint8Array([102, 111, 111, 98, 97, 114]))

    process.nextTick(() => {
     controller.close()
    });
  });
};

const [a, b] = new ReadableStream({start, pull}).tee();

for (const stream of [a, b]) {
  const chunks = [];

  for await (const chunk of stream) {
    chunks.push(chunk);
  }

  console.log('received:', Buffer.concat(chunks).toString());
}
```

### How often does it reproduce? Is there a required condition?

Always.

### What is the expected behavior?

```
received: foobar
received: foobar
```

### What do you see instead?

```
received: foobar
received:
```

### Additional information

Deno for reference: https://github.com/denoland/deno/blob/a0285e2eb88f6254f6494b0ecd1878db3a3b2a58/ext/web/06_streams.js#L1465-L1543

/cc @ronag @mcollina @jasnell","closed","szmarczak",36894700,"{confirmed-bug,""web streams""}","https://github.com/nodejs/node/issues/39758",12,"Ambos",NULL,144,"version v16 platform linux subsystem stream web step reproduce bug import readablestream stream web controller start c controller c pull pull called return pull called true process nexttick controller enqueue uint array foobar process nexttick controller close const a b new readablestream start pull tee const stream a b chunk stream chunk push chunk console log receive buffer concat chunk tostring how often reproduce required condition always expect behavior received foobar received foobar see instead received foobar received information deno reference cc ronag mcollina jasnell
","O título e o corpo da issue descrevem um problema de funcionamento do `readableStream.tee()` ao usar `process.nextTick(...)`, indicando um bug que precisa de correção (refatoração).  Os comentários discutem a solução envolvendo `queueMicrotask` em vez de `process.nextTick`, e a criação de um PR para resolver o problema.  A discussão aborda também testes e a necessidade de garantir a compatibilidade, indicando a necessidade de testes de regressão após a correção.  Portanto, a issue abrange tanto refatoração quanto testes de regressão."
190,49848,"2023-09-25 05:20:50","2023-10-06 14:33:47","2023-10-06 14:33:48","`vm`: `vm.compileFunction` does not support negative `lineOffset` and `columnOffset`","#### Version:
`v20.6.1`; older versions are also affected

#### Subsystem
`vm`

#### Current issue:

The `vm.compileFunction` method in Node.js currently doesn't support negative `lineOffset` and `columnOffset` values.

1. An error is thrown when the value is negative, as demonstrated below: 

```javascript
let { compileFunction } = require('node:vm');

try {
	compileFunction('', [], { lineOffset: -1 });
} catch (exception) {
	console.log(exception.stack);
}
/*
RangeError [ERR_OUT_OF_RANGE]: The value of 'options.lineOffset' is out of range. It must be >= 0 && <= 4294967295. Received -1
    at internalCompileFunction (node:internal/vm:50:3)
    at Module.compileFunction (node:vm:302:10)
    at ...
*/
```

2. An overflow occurs when the value is passed to the V8 engine if it is larger than `(2^31)-1`, causing it to become -2147483637 with the presence of overflow protection measures:
``` javascript
compileFunction('console.trace()', [], {
	lineOffset: 3456789012,
})();
/*
Trace
    at <anonymous>:-2147483648:9
    at ...
*/
```

#### Additional information:

The `vm.compileFunction` method in Node.js currently doesn't support negative `lineOffset` and `columnOffset` values. This is inconsistent with other methods such as `vm.runInContext`, `vm.runInNewContext`, and `new vm.Script()`, which do support negative values for these parameters. 

The underlying V8 engine also supports negative values for these parameters as indicated in the `ScriptOrigin` class:

``` cpp
class V8_EXPORT ScriptOrigin {
 public:
  V8_INLINE ScriptOrigin(Isolate* isolate, Local<Value> resource_name,
                         int resource_line_offset = 0,
                         int resource_column_offset = 0,
                         bool resource_is_shared_cross_origin = false,
                         int script_id = -1,
```

A common use case for the `lineOffset` option in `vm.compileFunction` is to shift lines in error tracebacks to support adding wrappers. Negative values enable the correct line number to be displayed in stack traces when wrapper code is added, while positive values would require part of the code to be removed to get a correct line number, which is not applicable in most scenarios. Hence, negative options are a primary use case that should be supported. An example use case is shown below:

```javascript
function compileAsyncFunction (code, params, options) {
	if (!params) {
		params = [];
	}
	if (!options) {
		if (!params.join) {
			options = params;
			params = [];
		} else {
			options = {};
		}
	}
	options = {
		...options, lineOffset: (options.lineOffset ?? 0) - 1
	};
	return vm.compileFunction(""(async ("" + params.join("", "") + "") => {\n"" + code + ""\n}).apply(null, arguments)"", params, options);
}

compileAsyncFunction(scriptFileContentReadFromDisk)();
```

#### Possible solution:

Upon investigation, the cause of this issue can be traced back to this line in `lib/internal/vm.js`:
https://github.com/nodejs/node/blob/448996cf95792a8db0c7a41e736e8aa03c440af6/lib/internal/vm.js#L50

A tested and effective solution is to change the `validateUint32` function to `validateInt32` for the `lineOffset` and `columnOffset` parameters.
","closed","wmtdru8xip",111224213,"{confirmed-bug,vm,""good first issue""}","https://github.com/nodejs/node/issues/49848",2,"Refatoração",NULL,11,"support negative lineOffset columnOffset value method inconsistent method support negative value v8 engine support negative value parameter common use case lineOffset option shift line error traceback support add wrapper negative value enable correct line number display stack trace positive value require part code remove get correct line number applicable scenario negative option primary use case support example use case show cause issue trace line lib internal vm js change validateUint32 function validateInt32 lineOffset columnOffset parameter
","A issue descreve um problema de compatibilidade com valores negativos em `lineOffset` e `columnOffset` no método `vm.compileFunction`.  A descrição foca na inconsistência do método com o motor V8 e na necessidade de adicionar um wrapper para lidar com valores negativos.  A solução proposta envolve mudanças na validação dos parâmetros (de `validateUint32` para `validateInt32`) e não adiciona novos testes ou funcionalidades.  O foco principal é a melhoria do código existente para suportar um cenário adicional, característica principal de uma refatoração."
192,49699,"2023-09-18 10:43:43","2023-10-04 07:17:36","2023-10-04 07:17:36","`""ERR_SSL_NO_CIPHER_MATCH""` error when specifying TLS cipher suites","### Version

v18.17.1

### Platform

Darwin 22.6.0 Darwin Kernel Version 22.6.0: Wed Jul  5 22:22:05 PDT 2023; root:xnu-8796.141.3~6/RELEASE_ARM64_T6000 arm64

### Subsystem

tls

### What steps will reproduce the bug?

Run

```js
require('node:https').createServer({ minVersion: 'TLSv1.3', ciphers: 'TLS_AES_256_GCM_SHA384:!TLS_CHACHA20_POLY1305_SHA256'})
```

Weirdly, setting `ECDHE-RSA-AES128-GCM-SHA256` at the end like `'TLS_AES_256_GCM_SHA384:!TLS_CHACHA20_POLY1305_SHA256:ECDHE-RSA-AES128-GCM-SHA256'` causes it work work even though `'ECDHE-RSA-AES128-GCM-SHA256'` is from `TLSv1.2`.


### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

The call to `https.createServer` should succeed and use the cipher suites specified AND (bonus) disallow specifying cipher suites not supported by the current protocol.

### What do you see instead?

```console
Uncaught Error: error:0A0000B9:SSL routines::no cipher match
    at configSecureContext (node:internal/tls/secure-context:231:11)
    at Object.createSecureContext (node:_tls_common:117:3)
    at Server.setSecureContext (node:_tls_wrap:1362:27)
    at Server (node:_tls_wrap:1226:8)
    at new Server (node:https:74:3)
    at Object.createServer (node:https:112:10) {
  library: 'SSL routines',
  reason: 'no cipher match',
  code: 'ERR_SSL_NO_CIPHER_MATCH'
}
```

### Additional information

```js
> tls.DEFAULT_CIPHERS
'TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA'
```","closed","jloleysens",8155004,"{confirmed-bug,tls,https}","https://github.com/nodejs/node/issues/49699",1,"Nenhum",NULL,16,"tls cipher match error createServer tlsv1.3 aes gcm sha384 chacha poly sha256 ecdhe rsa aes gcm sha256  call https createserver succeed cipher suite specify disallow cipher suite support protocol error ssl cipher match library ssl routines reason cipher match code err ssl cipher match default ciphers tls aes gcm sha384 tls chacha poly sha256 tls aes gcm sha256 ecdhe rsa aes gcm sha256 ecdhe ecdsa aes gcm sha256 ecdhe rsa aes gcm sha384 ecdhe ecdsa aes gcm sha384 dhe rsa aes gcm sha256 ecdhe rsa aes sha256 dhe rsa aes sha256 ecdhe rsa aes sha384 dhe rsa aes sha384 ecdhe rsa aes sha256 dhe rsa aes sha256 high anull enull export des rc4 md5 psk srp camellia
","O título e o corpo da issue descrevem um erro de compatibilidade de cifra TLS.  Não há menção a refatoração de código ou a testes de regressão. O problema parece ser um bug ou um problema de configuração relacionado à segurança e compatibilidade de protocolos, não diretamente relacionado a atividades de desenvolvimento como refatoração ou testes."
193,49695,"2023-09-18 02:02:13","2023-09-20 10:09:17","2023-10-03 23:26:06","`import.meta.resolve(…)` is documented to return a string, but returns a `URL` object","### Version

v20.6.1

### Platform

Darwin Germain.local 22.6.0 Darwin Kernel Version 22.6.0: Wed Jul  5 22:22:05 PDT 2023; root:xnu-8796.141.3~6/RELEASE_ARM64_T6000 arm64

### Subsystem

_No response_

### What steps will reproduce the bug?

https://nodejs.org/api/esm.html#importmetaresolvespecifier states:

> Returns: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) The absolute (file:) URL string for the resolved module.

The following prints a `URL` object:

```shell
echo ""console.log(process.versions.node); console.log(import.meta.resolve('./rel'));"" > /tmp/test.mjs
node /tmp/test.mjs
```

(`import.meta.resolve('./rel')) instanceof URL` also evaluates to `true`.)


### How often does it reproduce? Is there a required condition?

N/A

### What is the expected behavior? Why is that the expected behavior?

The documentation and the behaviour match.

All browsers and `deno` return a string, and it sounds like `bun` [would also prefer this](https://github.com/oven-sh/bun/issues/2472). I don't feel strongly myself, although I feel matching browsers would be less surprising if I was learning the API from scratch — it's always possible translate between formats if needed, but the ecosystem benefits from consistent type signatures in several ways.

See https://github.com/nodejs/node/issues/48994 for a related discussion about API ergonomics.

### What do you see instead?

The documentation and behaviour mismatch.

### Additional information

_No response_","closed","lgarron",248078,"{confirmed-bug,esm}","https://github.com/nodejs/node/issues/49695",8,"Refatoração",NULL,2,"documentação comportamento discordância navegador deno retornar string consistência tipo assinatura benefício ecossistema
","O título e o corpo da issue indicam uma discrepância entre a documentação e o comportamento real da função `import.meta.resolve()`.  A issue foca na inconsistência do tipo de retorno (URL em vez de string), sugerindo uma necessidade de ajuste na implementação para alinhar com a documentação.  Os comentários discutem possíveis soluções, incluindo a sugestão de usar uma API de acesso ao sistema de arquivos para melhorar a compatibilidade e consistência, o que se encaixa na definição de refatoração: melhorar o código sem alterar a funcionalidade externa. Não há menção explícita a testes de regressão, embora a correção do comportamento possa exigir a execução desses testes posteriormente."
196,49497,"2023-09-05 04:45:44","2023-09-06 10:12:16","2023-09-18 18:44:40","[v20.6] CJS runs repeatedly when there are circular dependencies when loaded by ESM","### Version

v20.6.0

### Platform

all

### Subsystem

_No response_

### What steps will reproduce the bug?

https://github.com/liuxingbaoyu/node-v20.6-bug

### How often does it reproduce? Is there a required condition?

always

### What is the expected behavior? Why is that the expected behavior?

```
node .\main.js
run
success
```

### What do you see instead?

```
node .\main.js
run
run
success
```

### Additional information

This should be the regression introduced by v20.6.","closed","liuxingbaoyu",30521560,"{confirmed-bug,module,esm}","https://github.com/nodejs/node/issues/49497",25,"Ambos",NULL,1,"regression introduzir v20.6
","O título da issue menciona ""regression"", indicando um problema de regressão.  O corpo da issue também menciona ""regression introduzir v20.6"", reforçando a natureza regressiva do problema.  Porém, os comentários discutem possíveis soluções como 'quick fix', 'revert pr', e adições de 'workaround', sugerindo que além da correção da regressão, refatoração de código pode ser necessária para resolver a raiz do problema de dependências circulares entre módulos ESM e CJS. A discussão sobre compatibilidade com frameworks como Angular e Babel, e ferramentas como Jest, aponta para a necessidade de testes de regressão para garantir que a solução não introduza novos problemas. Portanto, a issue envolve tanto a correção de uma regressão quanto a potencial necessidade de refatoração."
331,39717,"2021-08-09 16:30:08","2023-02-18 10:18:05","2023-02-18 10:18:05","Repl crash when SharedArrayBuffers are disabled","### Version

master

### Platform

Darwin Shelleys-MBP.fritz.box 20.6.0 Darwin Kernel Version 20.6.0: Wed Jun 23 00:26:31 PDT 2021; root:xnu-7195.141.2~5/RELEASE_X86_64 x86_64

### Subsystem

repl

### What steps will reproduce the bug?

1) Run `node --no-harmony-sharedarraybuffer`
2) Try to type an arbitrary command
3) Observe crash:

```
electron_node on git:a3d0cc7244 ❯ node --no-harmony-sharedarraybuffer       6:25PM
Welcome to Node.js v16.2.0.
Type "".help"" for more information.
> snode:internal/readline/emitKeypressEvents:71
            throw err;
            ^

TypeError: SharedArrayBuffer is not a constructor
    at node:internal/worker:96:32
    at NativeModule.compileForInternalLoader (node:internal/bootstrap/loaders:312:7)
    at nativeModuleRequire (node:internal/bootstrap/loaders:341:14)
    at node:worker_threads:11:5
    at NativeModule.compileForInternalLoader (node:internal/bootstrap/loaders:312:7)
    at nativeModuleRequire (node:internal/bootstrap/loaders:341:14)
    at node:inspector:32:26
    at NativeModule.compileForInternalLoader (node:internal/bootstrap/loaders:312:7)
    at nativeModuleRequire (node:internal/bootstrap/loaders:341:14)
    at sendInspectorCommand (node:internal/util/inspector:14:21)
 ```

### How often does it reproduce? Is there a required condition?

100%

### What is the expected behavior?

The repl does not crash.

### What do you see instead?

The repl crashes.

### Additional information

_No response_","closed","codebytere",2036040,"{confirmed-bug,repl}","https://github.com/nodejs/node/issues/39717",0,"Nenhum",NULL,558,"crash repl node sharedarraybuffer constructor type error
","O título e corpo da issue não mencionam refatoração ou testes de regressão.  A issue descreve um crash no REPL relacionado a SharedArrayBuffers, indicando um problema de funcionamento ou bug."
201,48957,"2023-07-28 22:32:53","2023-08-13 21:24:24","2023-08-13 21:24:24","MIME type overmatch in data URLs","### Version

v20.5.0

### Platform

Linux host 5.19.0-45-generic #46-Ubuntu SMP PREEMPT_DYNAMIC Wed Jun 7 09:08:58 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

modules

### What steps will reproduce the bug?

Execute this command.

```sh
node --input-type=module --eval 'import ""data:ONCEUPONAtext/javascriptTHEREWASASNEAKYMODULE,console.log(\""EVALUATED\"")""'
```

The incorrectly typed inline module is evaluated. The string is logged to the console.

```
EVALUATED
```

### How often does it reproduce? Is there a required condition?

Consistently.

### What is the expected behavior? Why is that the expected behavior?

An incorrect MIME type is forbidden.

### What do you see instead?

The module is evaluated.

### Additional information

[`formats.js`](https://github.com/nodejs/node/blob/fe514bf960ca1243b71657af662e7df29f5b57cf/lib/internal/modules/esm/formats.js) has a regex matching the MIME type.

```js
/\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i
```

This will match any MIME type that contains `(text|application)/javascript` anywhere. It maybe needs start and end anchors.","closed","ghost",10137,"{confirmed-bug,esm}","https://github.com/nodejs/node/issues/48957",6,"Ambos",NULL,16,"erro tipo mime modulo avaliar consistentemente esperar tipo mime incorreto proibido modulo avaliar regex corresponder tipo mime precisa ancora inicio fim
","O título da issue indica um problema de correspondência de tipo MIME em URLs de dados, sugerindo uma necessidade de refatoração do código responsável por essa validação.  Os comentários, por outro lado, mencionam a criação de um caso de teste ('criar caso teste') e a submissão de um pull request ('submeter pr'), indicando a necessidade de testes de regressão para garantir que a correção não introduza novos problemas.  A menção a um 'regexp' incorreto reforça a necessidade de refatoração."
202,48951,"2023-07-28 14:48:20","2023-08-12 18:20:56","2023-08-12 18:20:56","Memory leak in `AbortSignal.timeout` and `aborted`","### Version

20.5.0,18.16.0

### Platform

Darwin razluvaXFX99QJK 22.5.0 Darwin Kernel Version 22.5.0: Thu Jun  8 22:22:20 PDT 2023; root:xnu-8796.121.3~7/RELEASE_ARM64_T6000 arm64

### Subsystem

events

### What steps will reproduce the bug?

Run this with the flag `--expose-gc`

```js
// Flags: --expose-gc

const {setImmediate} = require('timers/promises');
const {aborted} = require('util');

const formatMemoryUsage = (data) => `${Math.round(data / 1024 / 1024 * 100) / 100} MB`;

function logMemory() {

  const memoryData = process.memoryUsage();

  const memoryUsage = {
    rss: `${formatMemoryUsage(memoryData.rss)} -> Resident Set Size - total memory allocated for the process execution`,
    heapTotal: `${formatMemoryUsage(memoryData.heapTotal)} -> total size of the allocated heap`,
    heapUsed: `${formatMemoryUsage(memoryData.heapUsed)} -> actual memory used during the execution`,
    external: `${formatMemoryUsage(memoryData.external)} -> V8 external memory`,
  };

  console.log(memoryUsage);
}

(async () => {

  while (true) {
    for (let i = 0; i < 10000; i++) {
      function lis() {

      }

      const timeoutSignal = AbortSignal.timeout(1_000_000_000);
      timeoutSignal.addEventListener('abort', lis);
      aborted(timeoutSignal, {});
      timeoutSignal.removeEventListener('abort', lis);
    }

    await setImmediate();
    global.gc();
  }

})().catch(console.error)

setInterval(() => {
  logMemory();
}, 1000);
```

### How often does it reproduce? Is there a required condition?

always.

required conditions are to add the `aborted` after the regular listener and remove the regular listener after the aborted

### What is the expected behavior? Why is that the expected behavior?

no memory leak

### What do you see instead?

memory leak

### Additional information

this is happening because:
1. the regular listener goes to here which add to the map the `aborted` function add weak listener:
https://github.com/nodejs/node/blob/ccdfb374383a3b0126693089780314f967881d20/lib/internal/abort_controller.js#L250
2. calling the `aborted` function add the listener but as weak listener
3. when the listener is garbage collected we call `remove` on the listener:
https://github.com/nodejs/node/blob/38dee8a1c04237bd231a01410f42e9d172f4c162/lib/internal/event_target.js#L409
4. the `remove` does not call the removeEventListener which decreases the `size`:
5. because the size is not decreased it will never reach 0 so the abort signal won't get GCed
https://github.com/nodejs/node/blob/ccdfb374383a3b0126693089780314f967881d20/lib/internal/abort_controller.js#L257-L259


This is also the reason why calling aborted on the same signal and garbage collecting still emit the max listener warning","closed","rluvaton",16746759,"{confirmed-bug,abortcontroller}","https://github.com/nodejs/node/issues/48951",0,"Refatoração",NULL,15,"memory leak nodejs abortsignal listener garbage collection removeEventListener weak listener
","O título da issue ""Memory leak in `AbortSignal.timeout` and `aborted`"" indica um problema de vazamento de memória.  O corpo da issue menciona ""memory leak"", ""garbage collection"" e ""removeEventListener"", sugerindo a necessidade de refatoração do código para corrigir o vazamento de memória e melhorar a gestão de recursos. Não há menção direta a testes de regressão."
203,48941,"2023-07-27 14:54:25","2023-07-29 18:36:57","2023-07-29 18:36:57","test_runner: incorrect unwrapping of errors in after() when using the tap reporter","Consider this test:

```js
const test = require('node:test')

test('should print the error', (t) => {
  t.after(async () => {
    throw new Error('kaboom')
  })
})
```

If I run it normally, I get:

```
✖ should print the error (0.880917ms)
  Error: kaboom
      at TestContext.<anonymous> (/Users/matteo/tmp/bug.js:5:11)
      at TestHook.runInAsyncScope (node:async_hooks:206:9)
      at TestHook.run (node:internal/test_runner/test:580:25)
      at TestHook.run (node:internal/test_runner/test:759:18)
      at TestHook.run (node:internal/util:500:12)
      at node:internal/test_runner/test:516:20
      at async Test.runHook (node:internal/test_runner/test:514:7)
      at async after (node:internal/test_runner/test:542:9)
      at async Test.run (node:internal/test_runner/test:590:7)
      at async startSubtest (node:internal/test_runner/harness:204:3)

ℹ tests 1
ℹ suites 0
ℹ pass 0
ℹ fail 1
ℹ cancelled 0
ℹ skipped 0
ℹ todo 0
ℹ duration_ms 40.280833

✖ failing tests:

✖ should print the error (0.880917ms)
  Error: kaboom
      at TestContext.<anonymous> (/Users/matteo/tmp/bug.js:5:11)
      at TestHook.runInAsyncScope (node:async_hooks:206:9)
      at TestHook.run (node:internal/test_runner/test:580:25)
      at TestHook.run (node:internal/test_runner/test:759:18)
      at TestHook.run (node:internal/util:500:12)
      at node:internal/test_runner/test:516:20
      at async Test.runHook (node:internal/test_runner/test:514:7)
      at async after (node:internal/test_runner/test:542:9)
      at async Test.run (node:internal/test_runner/test:590:7)
      at async startSubtest (node:internal/test_runner/harness:204:3)
```

If I run in a non-interactive process such as `node --test bug.js | less`, I get the error detail scrambled:

```
TAP version 13
# Subtest: should print the error
not ok 1 - should print the error
  ---
  duration_ms: 0.974875
  failureType: 'hookFailed'
  error: 'failed running after hook'
  code: 'ERR_TEST_FAILURE'
  stack: |-
    TestContext.<anonymous> (/Users/matteo/tmp/bug.js:5:11)
    TestHook.runInAsyncScope (node:async_hooks:206:9)
    TestHook.run (node:internal/test_runner/test:580:25)
    TestHook.run (node:internal/test_runner/test:759:18)
    TestHook.run (node:internal/util:500:12)
    node:internal/test_runner/test:516:20
    async Test.runHook (node:internal/test_runner/test:514:7)
    async after (node:internal/test_runner/test:542:9)
    async Test.run (node:internal/test_runner/test:590:7)
    async startSubtest (node:internal/test_runner/harness:204:3)
  ...
1..1
# tests 1
# suites 0
# pass 0
# fail 1
# cancelled 0
# skipped 0
# todo 0
# duration_ms 43.341875
```

This shows specifically during CI runs, where the pretty reporter is not engaged. ","closed","mcollina",52195,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/48941",5,"Testes de Regressão",NULL,2,"test print error run normally error kaboom test run non interactive process error detail scramble tap version subtest print error ok duration failureType hookFailed error failed running after hook code err test failure stack testcontext anonymous testhook runinasyncope testhook run testhook run testhook run node internal test runner test async testrunhook async after async testrun async startsubtest test suite pass fail cancelled skipped todo duration
","O título da issue ""test_runner: incorrect unwrapping of errors in after() when using the tap reporter"" e o corpo da issue mencionam explicitamente testes ('test', 'testhook', 'testrun', 'test runner', 'after hook', 'subtest', 'test suite', 'assertion'),  erros em testes ('errors', 'error', 'failure', 'failed'), e um reporter de testes ('tap reporter'). Os comentários também se referem a correções de bugs e problemas no relatório de testes.  Isso indica claramente que a issue se relaciona a testes de regressão e não há menção direta a refatoração de código."
204,48937,"2023-07-27 06:57:04","2023-09-21 20:24:34","2023-09-21 20:24:34","Throwing an exception on test reporters silently error the test runner","### Version

v20.4.0

### Platform

Linux executive 6.2.0-25-generic #25-Ubuntu SMP PREEMPT_DYNAMIC Fri Jun 16 17:05:07 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

test runner

### What steps will reproduce the bug?

Write and use a custom test reporter on the test runner that throws an exception.

### How often does it reproduce? Is there a required condition?

Always.

### What is the expected behavior? Why is that the expected behavior?

Throwed exception should be shown to the user in any way. Crashing the test runner with an unhandled exception would be enough. If it's too much agresive and chaotic, at least print the error instance message before exit.

### What do you see instead?

Test runner just only exit with exit code 1, there's no other output that can give a clue of what happened and why the test runner didn't work properly.

### Additional information

_No response_","closed","piranna",532414,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/48937",16,"Ambos",NULL,57,"custom test reporter exception user crash print error message exit code output
","A issue relata um problema em um `test reporter` que silenciosamente esconde erros, levando a falhas no `test runner`.  Comentários discutem a necessidade de  refatoração do código para lidar adequadamente com exceções (ex: usar `try-catch`,  `async iterator` e  `generator function` para tratamento de erros assíncronos).  Ao mesmo tempo, a solução envolve testes de regressão para garantir que a correção não introduza novos problemas.  A discussão foca em como capturar e relatar erros corretamente, o que afeta tanto a estrutura do código (refatoração) quanto a confiabilidade dos testes (testes de regressão)."
333,39400,"2021-07-15 15:07:41","2021-08-05 22:22:00","2021-08-05 22:22:00","http2: `end` is emitted before `error` when destroying client stream","### Version

v16.4.2

### Platform

Linux solus 5.13.1-187.current #1 SMP PREEMPT Wed Jul 7 19:52:26 UTC 2021 x86_64 GNU/Linux

### Subsystem

http2

### What steps will reproduce the bug?

```js
import http2 from 'http2';
import stream from 'stream';

const session = http2.connect('https://petstore.swagger.io/v2/pet/findByStatus?status=available');
const request = session.request({
	':path': '/findByStatus?status=available',
	'x-trace-id': 'foo',
	'user-agent': 'foo-bar/baz, bash'
});

request.on('data', () => {
	request.destroy(new Error('error'));
});

request.on('end', () => {
	console.log('end');
});

request.end();

await stream.promises.pipeline(
	request,
	new stream.PassThrough()
);

console.log('success');

session.close();
```

### How often does it reproduce? Is there a required condition?

Always.

### What is the expected behavior?

```
Error: error
    at ClientHttp2Stream.<anonymous> (file:///home/szm/Desktop/got/demo.js:12:18)
    at ClientHttp2Stream.emit (node:events:406:35)
    at addChunk (node:internal/streams/readable:312:12)
    at readableAddChunk (node:internal/streams/readable:287:9)
    at ClientHttp2Stream.Readable.push (node:internal/streams/readable:226:10)
    at Http2Stream.onStreamRead (node:internal/stream_base_commons:190:23)
```

### What do you see instead?

```
end
success
```

### Additional information

Possibly related with #29929 or #35209","closed","szmarczak",36894700,"{confirmed-bug,stream,http2}","https://github.com/nodejs/node/issues/39400",15,"Ambos",NULL,21,"version v16 platform linux subsystem http2 step reproduce bug always expect behavior error see instead additional information relate
","A issue descreve um problema onde o evento 'end' é emitido antes do evento 'error' em um stream HTTP2. Os comentários discutem a ordem lógica dos eventos, o comportamento esperado, e a necessidade de testes para verificar a correção do problema (Testes de Regressão).  Também há menção à necessidade de consertar o bug e analisar o estado do fluxo (Refatoração). A combinação de correção de bug e necessidade de testes indica que ambos os aspectos são relevantes."
207,48816,"2023-07-17 16:33:38","2023-08-01 00:43:40","2023-08-01 00:43:40","URL.canParse fails when stressed","### Version

20.4.0

### Platform

any

### Subsystem

_No response_

### What steps will reproduce the bug?

```js
while (true) {
  const test = URL.canParse('/ ', 'http://n');
  console.log(test);
}
```

### How often does it reproduce? Is there a required condition?

after some stress

### What is the expected behavior? Why is that the expected behavior?

same result as first one

### What do you see instead?

return false at some point of stress

### Additional information

_No response_","closed","joacub",2091228,"{confirmed-bug,whatwg-url}","https://github.com/nodejs/node/issues/48816",7,"Ambos",NULL,14,"stress causar retorno falso ponto
","O título da issue ""URL.canParse fails when stressed"" sugere um problema de funcionamento (bug) que precisa ser corrigido.  Os comentários mencionam testes ( ""test end 100ms wait behaviour"", ""bug report confirm awkward bug"") e também a necessidade de correções e refatoração ( ""fix issue"", ""abrir pr corrigir"", ""think follow change detail"",  referências a V8 fast API que podem indicar necessidade de ajustes de código). A combinação de correção de bug e modificações de código indicam a necessidade de ambos, refatoração e testes de regressão."
208,48809,"2023-07-17 08:40:39","2023-12-24 08:23:56","2023-12-24 08:23:56","test_runner: test object is incorrectly passed to setup()","### Affected URL(s)

https://nodejs.org/docs/latest-v20.x/api/test.html#runoptions

### Description of the problem

By doc:
> `options.setup` - A function that accepts the `TestsStream` instance

but in fact that is not `TestStream`
[nodejs/node@v20.4.0/lib/internal/test_runner/harness.js#L29-L31](https://github.com/nodejs/node/blob/v20.4.0/lib/internal/test_runner/harness.js?rgh-link-date=2023-07-15T13%3A03%3A30Z#L29-L31)
[nodejs/node@v20.4.0/lib/internal/test_runner/test.js#L165-L192](https://github.com/nodejs/node/blob/v20.4.0/lib/internal/test_runner/test.js?rgh-link-date=2023-07-15T13%3A03%3A30Z#L165-L192)
[nodejs/node@v20.4.0/lib/internal/test_runner/tests_stream.js#L10](https://github.com/nodejs/node/blob/v20.4.0/lib/internal/test_runner/tests_stream.js?rgh-link-date=2023-07-15T13%3A03%3A30Z#L10)

```js
const stream = run({
  files: files,
  concurrency: true,
  setup: function (root) {
    console.log('setup', root)
  }
})
```
```
setup <ref *1> Test {
  concurrency: 9,
  nesting: 0,
  only: false,
  reporter: TestsStream {
    _readableState: ReadableState {
      objectMode: true,
      highWaterMark: 16,
      buffer: BufferList { head: null, tail: null, length: 0 },
      length: 0,
      pipes: [],
      flowing: null,
      ended: false,
      endEmitted: false,
      reading: false,
 ```
 
 Found in https://github.com/DefinitelyTyped/DefinitelyTyped/pull/66064","closed","Semigradsky",1198848,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/48809",1,"Testes de Regressão",NULL,160,"doc options setup function accept teststream instance fact teststream
","O título da issue ""test_runner: test object is incorrectly passed to setup()"" e o corpo da issue mencionam diretamente testes (""test"", ""teststream"", ""setup()"").  O comentário também menciona 'bug fix', indicando uma correção de erro em código de teste.  Portanto, a issue claramente se relaciona com testes de regressão, sem haver menção explícita de refatoração de código de produção."
209,48778,"2023-07-15 05:18:27","2023-07-17 15:26:17","2023-07-17 15:26:17","Loader preload code never executes","### Version

v20.0.0

### Platform

Linux silica 5.19.0-45-generic #46-Ubuntu SMP PREEMPT_DYNAMIC Wed Jun 7 09:08:58 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

Loader API

### What steps will reproduce the bug?

* Save this code to `loader.mjs`.
    ```js
    export function globalPreload () {
      console.log('PRELOAD')
      return `
    const console = getBuiltin('console')
    console.log('BOOTSTRAP')
    `
    }
    ```
* On any v20 release, run `node --loader=./loader.mjs`.
* `PRELOAD` message is logged. `BOOTSTRAP` message is never logged.

### How often does it reproduce? Is there a required condition?

Consistently on any v20 release.

### What is the expected behavior? Why is that the expected behavior?

The string returned by `globalPreload()` is executed on the main thread. The [API docs](https://nodejs.org/docs/latest-v20.x/api/esm.html#globalpreload) claim it will happen.

### What do you see instead?

The string returned by `globalPreload()` is never executed.

### Additional information

On the latest v19 this code works.

```sh
$ nvm use v19
Now using node v19.9.0 (npm v9.6.7)
$ node --loader=./loader.mjs
(node:509065) ExperimentalWarning: Custom ESM Loaders is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
PRELOAD
BOOTSTRAP
Welcome to Node.js v19.9.0.
```

On the earliest v20 the returned string never executes.

```sh
$ nvm use v20.0.0
Now using node v20.0.0 (npm v9.6.4)
$ node --loader=./loader.mjs
Welcome to Node.js v20.0.0.
Type "".help"" for more information.
> (node:516773) ExperimentalWarning: Custom ESM Loaders is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
PRELOAD

>
```

I tried setting a global property in the bootstrap code to ensure it wasn't just a `console` issue. The property is never set.

```js
export function globalPreload () {
  console.log('PRELOAD')
  return `
globalThis.test = 1
`
}
```

```sh
$ nvm use v19
Now using node v19.9.0 (npm v9.6.7)
$ node --loader=./loader.mjs
(node:523929) ExperimentalWarning: Custom ESM Loaders is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
PRELOAD
Welcome to Node.js v19.9.0.
Type "".help"" for more information.
> test
1
```

```sh
$ nvm use v20.0.0
Now using node v20.0.0 (npm v9.6.4)
$ node --loader=./loader.mjs
Welcome to Node.js v20.0.0.
Type "".help"" for more information.
> (node:521480) ExperimentalWarning: Custom ESM Loaders is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
PRELOAD

> test
Uncaught ReferenceError: test is not defined
```

Could have sworn I saw this working before on v20, but it fails consistently now. I tried it on 2 different machines, one with fresh install of Node.js, with the same result everywhere.

Would really like to use the loader thread. It seems like they should be isolated. But I've got to stick with v19 until I can run a bootstrap at startup.","closed","ghost",10137,"{confirmed-bug,loaders}","https://github.com/nodejs/node/issues/48778",1,"Refatoração",NULL,2,"v20 problema loader api string retornar globalPreload executar thread principal api doc afirmar acontecer string retornar executar v19 codigo funcionar v20 string retornar executar configurar propriedade global codigo garantir problema console propriedade configurar propriedade global definir v19 funcionar v20 propriedade definir jurar ver funcionar v20 falhar consistentemente maquina instalaçao node resultado tentar usar thread loader isolar v19 executar bootstrap inicializaçao
","O texto descreve um problema de compatibilidade entre a versão v19 e v20 de um código relacionado a um 'loader'.  A descrição indica que o código funcionava na v19 e parou de funcionar na v20, devido a mudanças na forma como a string de retorno é executada.  O foco principal é corrigir o comportamento do código para funcionar na nova versão, sem adicionar novos recursos ou testes, o que caracteriza uma atividade de refatoração.  Não há menção explícita à criação ou execução de testes de regressão."
210,48763,"2023-07-14 06:49:28","2023-12-21 10:43:17","2023-12-22 10:12:16","ERR_INTERNAL_ASSERTION in internalConnectMultiple","### Version

v20.4.0

### Platform

Microsoft Windows NT 10.0.19044.0 x64

### Subsystem

_No response_

### What steps will reproduce the bug?

I'm running a worker thread(s) which runs an openWebsocket and passes messages to the main thread via postmessage.
I don't get any messages and after a few minutes, I get this error:


### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior? Why is that the expected behavior?

_No response_

### What do you see instead?


```bash
Error: This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues

    at new NodeError (node:internal/errors:405:5)
    at assert (node:internal/assert:14:11)
    at internalConnectMultiple (node:net:1115:3)
    at Timeout.internalConnectMultipleTimeout (node:net:1683:3)
    at listOnTimeout (node:internal/timers:575:11)
    at processTimers (node:internal/timers:514:7) {
  code: 'ERR_INTERNAL_ASSERTION'
}
```

```bash
Trace:
    at error (C:\Users\_\Desktop\sys\core.ts:3963:25)
    at Worker.<anonymous> (C:\Users\_\Desktop\sys\core.ts:3894:95)
    at Worker.emit (node:events:512:28)
    at Worker.[kOnErrorMessage] (node:internal/worker:326:10)
    at Worker.[kOnMessage] (node:internal/worker:337:37)
    at MessagePort.<anonymous> (node:internal/worker:232:57)
    at MessagePort.[nodejs.internal.kHybridDispatch] (node:internal/event_target:778:20)
    at MessagePort.exports.emitMessage (node:internal/per_context/messageport:23:28)
```

### Additional information

_No response_","closed","hp8wvvvgnj6asjm7",45887282,"{confirmed-bug,net}","https://github.com/nodejs/node/issues/48763",8,"Ambos",NULL,160,"worker thread run openwebsocket pass message main thread postmessage get message minute get error bug node js incorrect usage node js internal open issue stack trace node js internal assertion error worker anonymous worker emit worker konerrormessage worker kmessage messageport anonymous messageport nodejs internal khybriddispatch messageport export emitmessage
","O título da issue indica um erro interno ('ERR_INTERNAL_ASSERTION'), sugerindo um problema de código que precisa ser corrigido (Refatoração).  Os comentários discutem a dificuldade em reproduzir o erro, a necessidade de um código de exemplo e a investigação da causa raiz, o que indica a necessidade de testes de regressão para garantir que a correção não introduza novos problemas.  A menção de 'fix problem' nos comentários confirma a resolução do problema, envolvendo provavelmente refatoração e testes subsequentes."
335,39205,"2021-06-30 09:18:49","2021-07-26 15:49:39","2022-01-05 06:04:40","Using JWK as encoding format for public key in crypto.generateKeyPairSync() throws an error","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


> Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: v16.4.0
* **Platform**: Microsoft Windows NT 10.0.18363.0 x64
* **Subsystem**: Crypto

### What steps will reproduce the bug?
**main.js**
```
const crypto = require(""crypto"");

const keys = crypto.generateKeyPairSync(""ec"", {
	namedCurve: ""P-384"",
	publicKeyEncoding: { type: ""spki"", format: ""jwk"" },
	privateKeyEncoding: { type: ""pkcs8"", format: ""pem"" }
});

console.log(keys.publicKey);
```
then just execute the command `node main.js`

### How often does it reproduce? Is there a required condition?
Everytime. If I change the public key encoding format to ""pem"" or ""der"" it dosen't throw an error. It seems like ""jwk"" is the only broken format.
### What is the expected behavior?
Should probably look something like the output below. I used the keyObject.export() to create this output because as mentioned above, crypto.generateKeyPairSync() dosen't work at all with ""jwk"". 

**Code to produce the expected output:**
```
const crypto = require(""crypto"");

const keys = crypto.generateKeyPairSync(""ec"", {
	namedCurve: ""P-384""
});

console.log(keys.publicKey.export({ format: ""jwk"" }));
```
**Expected output:**
```
{
  crv: 'P-384',
  kty: 'EC',
  x: 'BC-y_ZyH6rYMv_YAREfUainM1c9iwhHc9KEPPRD1u2zGJMuGV1LvEWh2igD3kAS5',
  y: 'LX7TofWICe4_nJZNBkS0rtqDCDoTp9_TuKHqKQHh1wDH3hvgSZjPWZN1TnrvbfR4'
}
```
### What do you see instead?
```
node:internal/crypto/keys:268
  throw new ERR_INVALID_ARG_VALUE(optionName, formatStr);
  ^

TypeError [ERR_INVALID_ARG_VALUE]: The property 'options.publicKeyEncoding.format' is invalid. Received 'jwk'
    at new NodeError (node:internal/errors:363:5)
    at parseKeyFormat (node:internal/crypto/keys:268:9)
    at parseKeyFormatAndType (node:internal/crypto/keys:304:18)
    at parseKeyEncoding (node:internal/crypto/keys:332:7)
    at parsePublicKeyEncoding (node:internal/crypto/keys:371:10)
    at parseKeyEncoding (node:internal/crypto/keygen:125:9)
    at createJob (node:internal/crypto/keygen:161:42)
    at Object.generateKeyPairSync (node:internal/crypto/keygen:95:22)
    at Object.<anonymous> (C:\Users\johannes.nydahl\Desktop\Playground\main.js:3:21)
    at Module._compile (node:internal/modules/cjs/loader:1095:14) {
  code: 'ERR_INVALID_ARG_VALUE'
}
```
### Additional information
Tested on both node version v16.4.0 and v15.9.0 (v15.9.0 was when keyObject.export() first started to support ""jwk"" as format.","closed","johannesnydahl",27621620,"{confirmed-bug,crypto}","https://github.com/nodejs/node/issues/39205",7,"Refatoração",NULL,26,"version v16.4 platform microsoft windows nt 10 x64 subsystem crypto reproduce bug main js code crypto generatekeypairsync ec namedcurve p publicKeyEncoding type spki format jwk privateKeyEncoding type pkcs8 format pem execute command node main js reproduce everytime change public key encoding format pem der dosen throw error seems jwk broken format expected behavior look output used keyobject export create output mentioned crypto generatekeypairsync dosen work jwk code produce expected output code crypto generatekeypairsync ec namedcurve p expected output code crv p kty ec x bc y z y aref uainm c iwh hc kepp rd uz gjmu gv lv ew h igd k as y lx tofw ice n jznb ks rtq dc dotp tu khq kqh hw dh hvg szj pwn tnr vbfr instead node internal crypto keys throw new err invalid arg value optionname formatstr typeerror err invalid arg value property options publickeyencoding format invalid receive jwk additional information test node version v16 v15 keyobject export support jwk format
","A issue descreve um erro em como o `crypto.generateKeyPairSync()` lida com o formato JWK para chaves públicas.  Os comentários discutem a compatibilidade entre diferentes formatos de chave (JWK, SPKI, PEM, DER) e a necessidade de adicionar suporte para JWK.  A solução envolve corrigir o código para suportar corretamente o formato JWK, o que caracteriza uma refatoração do código existente,  não um teste de regressão em si, embora possa ser necessário testar a refatoração posteriormente."
339,38883,"2021-06-01 07:00:00","2021-06-26 14:21:57","2021-06-26 14:21:57","Decrypting a zero-length array with SubtleCrypto triggers Assertion failures","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: v16.2.0
* **Platform**: `Darwin shinji 20.6.0 Darwin Kernel Version 20.6.0: Mon May 10 03:15:35 PDT 2021; root:xnu-7195.140.13.0.1~20/RELEASE_X86_64 x86_64 i386 MacBookPro16,2 Darwin`
* **Subsystem**: webcrypto (specifically SubtleCrypto)

### What steps will reproduce the bug?

Attempting to decrypt a zero-length array crashes node completely. There are two ways to trigger this.

The first encrypts a zero length array and then attempts to decrypt that same data:
```
const crypto = require('crypto').webcrypto;
crypto.subtle.importKey('raw', new Uint8Array(32), {name: 'AES-GCM'}, false, ['encrypt','decrypt'])
  .then(k =>
    crypto.subtle.encrypt({name: 'AES-GCM', iv: new Uint8Array(12)}, k, new Uint8Array(0))
    .then(e =>
      crypto.subtle.decrypt({name: 'AES-GCM', iv: new Uint8Array(12)}, k, e)
    )
  )
  .then(v => console.log(v));
```

The second simply decrypts a zero length data array:
```
const crypto = require('crypto').webcrypto;
crypto.subtle.importKey('raw', new Uint8Array(32), {name: 'AES-GCM'}, false, ['encrypt','decrypt'])
  .then(k => crypto.subtle.decrypt({name: 'AES-GCM', iv: new Uint8Array(12)}, k, new Uint8Array(0)))
  .then(v => console.log(v));
```

### How often does it reproduce? Is there a required condition?

Every time.

### What is the expected behavior?

The `decrypt` call should produce a zero-length array in the first case, and fail in the second (chrome rejects with `The provided data is too small`).

### What do you see instead?

Node crashes. The two snippets trigger different errors.

First:
```
node[51088]: ../src/crypto/crypto_cipher.h:261:virtual v8::Maybe<bool> node::crypto::CipherJob<node::crypto::AESCipherTraits>::ToResult(v8::Local<v8::Value> *, v8::Local<v8::Value> *) [CipherTraits = node::crypto::AESCipherTraits]: Assertion `!errors->Empty()' failed.
 1: 0x105ac3832 node::Abort() [/usr/local/bin/node]
 2: 0x105ac36be node::AppendExceptionLine(node::Environment*, v8::Local<v8::Value>, v8::Local<v8::Message>, node::ErrorHandlingMode) [/usr/local/bin/node]
 3: 0x105b93582 node::crypto::CipherJob<node::crypto::AESCipherTraits>::DoThreadPoolWork() [/usr/local/bin/node]
 4: 0x105b93309 node::crypto::CryptoJob<node::crypto::AESCipherTraits>::AfterThreadPoolWork(int) [/usr/local/bin/node]
 5: 0x106345d74 uv__work_done [/usr/local/bin/node]
 6: 0x106349528 uv__async_io [/usr/local/bin/node]
 7: 0x106359662 uv__io_poll [/usr/local/bin/node]
 8: 0x10634995e uv_run [/usr/local/bin/node]
 9: 0x105a12624 node::SpinEventLoop(node::Environment*) [/usr/local/bin/node]
10: 0x105afbd35 node::NodeMainInstance::Run(node::EnvSerializeInfo const*) [/usr/local/bin/node]
11: 0x105a9ab72 node::Start(int, char**) [/usr/local/bin/node]
12: 0x7fff20348f5d start [/usr/lib/system/libdyld.dylib]
13: 0x1
Abort trap: 6
```

Second:
```
node[51123]: ../src/crypto/crypto_aes.cc:92:node::crypto::WebCryptoCipherStatus node::crypto::(anonymous namespace)::AES_Cipher(node::Environment *, node::crypto::KeyObjectData *, node::crypto::WebCryptoCipherMode, const node::crypto::AESCipherConfig &, const node::crypto::ByteSource &, node::crypto::ByteSource *): Assertion `params.tag' failed.
 1: 0x10d74e832 node::Abort() [/usr/local/bin/node]
 2: 0x10d74e6be node::AppendExceptionLine(node::Environment*, v8::Local<v8::Value>, v8::Local<v8::Message>, node::ErrorHandlingMode) [/usr/local/bin/node]
 3: 0x10d81ccf3 node::crypto::AES::Initialize(node::Environment*, v8::Local<v8::Object>) [/usr/local/bin/node]
 4: 0x10d81e5d6 node::crypto::CipherJob<node::crypto::AESCipherTraits>::DoThreadPoolWork() [/usr/local/bin/node]
 5: 0x10dfd1128 worker [/usr/local/bin/node]
 6: 0x7fff2032d8fc _pthread_start [/usr/lib/system/libsystem_pthread.dylib]
 7: 0x7fff20329443 thread_start [/usr/lib/system/libsystem_pthread.dylib]
Abort trap: 6
```
### Additional information

These inputs are far from normal, but I figure node should never _crash_.

The project I work on has property tests involving webcrypto. We've been using `node-webcrypto-ossl` to run these tests for months; we thought it might be nice to switch to the new built-in webcrypto instead. Our property tests are designed to throw all sorts of invalid values at our own code - but it turns out they throw invalid values at the webcrypto API as well.","closed","TheSpyder",298292,"{confirmed-bug,crypto,webcrypto}","https://github.com/nodejs/node/issues/38883",1,"Testes de Regressão",NULL,25,"version v16 platform darwin subsystem webcrypto decrypt zero length array crash node two way trigger first encrypt zero length array attempt decrypt data second decrypt zero length data array decrypt call produce zero length array first case fail second chrome reject provided data small node crash two snippet trigger different error first assertion failed second assertion failed input far normal node crash project work property test webcrypto use node webcrypto ossl run test month thought might nice switch new built webcrypto property test design throw sort invalid value code turn throw invalid value webcrypto api
","O título e corpo da issue descrevem falhas (crashes e assertion failures) ao decifrar um array de comprimento zero usando SubtleCrypto.  A menção a 'property test', 'webcrypto', 'run test' e 'test month' indica que os problemas foram encontrados durante testes, especificamente testes de regressão que visam verificar se funcionalidades existentes ainda funcionam corretamente após mudanças no código. Não há menção explícita a refatoração de código."
214,48437,"2023-06-12 17:35:54","2024-01-25 08:53:23","2024-01-25 08:53:23","Node 20 recursive file watching is misbehaving on Linux","### Version

20.3.0

### Platform

linux

### Subsystem

fs

### What steps will reproduce the bug?

I put together a repro at https://github.com/cjihrig/recursive-watcher-bug that shows the following passing on Windows and macOS, but [failing on Ubuntu](https://github.com/cjihrig/recursive-watcher-bug/actions/runs/5246535809/jobs/9475494124). I'm not sure if this is specific to GitHub Actions.

```js
'use strict';
const { mkdtempSync, watch, writeFileSync } = require('node:fs');
const { tmpdir } = require('node:os');
const { join } = require('node:path');
const tmpDir = mkdtempSync(join(tmpdir(), 'repro-test-'));
const filename = join(tmpDir, 'test.file');
const keepalive = setTimeout(() => {
  throw new Error('timed out');
}, 60_000);

const watcher = watch(tmpDir, { recursive: true }, (eventType, filename) => {
  clearTimeout(keepalive);
  watcher.close();
  console.log(eventType, filename);
});

writeFileSync(filename, 'foobar');
```

### How often does it reproduce? Is there a required condition?

Always reproduces for me.

### What is the expected behavior? Why is that the expected behavior?

I expect the test to pass.

### What do you see instead?

The test times out.

### Additional information

I noticed this while trying to update Platformatic to support Node 20 and created the minimal reproduction linked above.

I also noticed that Platformatic was passing `recursive: true` to the promisified version of `watch()` on Ubuntu on earlier versions of Node. It should have thrown `ERR_FEATURE_UNAVAILABLE_ON_PLATFORM`, but did not. I did see that error with the callback based `watch()` though, which makes me think there is some missing validation on older versions of Node in addition to this bug.

cc: @anonrig who implemented recursive file watching on Linux.","closed","cjihrig",2512748,"{confirmed-bug,""help wanted"",fs}","https://github.com/nodejs/node/issues/48437",14,"Ambos",NULL,227,"repro show pass windows macos fail ubuntu sure specific github action expect test pass test time out notice update platformatic support node create minimal reproduction link notice platformatic pass recursive promisified version ubuntu earlier version node throw err_feature_unavailable_on_platform see error callback base make think miss validation older version node bug implement recursive file watch linux
","A issue relata um problema de comportamento errático no recurso de monitoramento recursivo de arquivos no Node.js 20 em sistemas Linux (Refatoração).  A solução proposta envolve modificar a função de travessia para torná-la assíncrona e adicionar mecanismos de espera para evitar uma condição de corrida (Refatoração). Além disso, os comentários discutem testes em diferentes sistemas operacionais (Windows, macOS, Ubuntu), indicando a necessidade de testes de regressão para garantir a correção do problema após a refatoração (Testes de Regressão). Portanto, a issue abrange tanto refatoração de código quanto a necessidade subsequente de testes de regressão."
216,48103,"2023-05-21 11:45:43","2023-05-23 21:03:20","2023-05-23 21:03:20","test runner v8 serialization fails ","Not sure if there is a simple reproduction, but seen this in CI (https://ci.nodejs.org/job/node-test-commit-freebsd/49824/nodes=freebsd12-x64/consoleFull):

```
13:32:50         # Subtest: test-runner/output/output_cli.js
13:32:50         not ok 14 - test-runner/output/output_cli.js
13:32:50           ---
13:32:50           duration_ms: 12475.461475
13:32:50           failureType: 'testCodeFailure'
13:32:50           error: |-
13:32:50             Expected values to be strictly equal:
13:32:50             + actual - expected ... Lines skipped
13:32:50             
13:32:50               'TAP version 13\n' +
13:32:50                 '# Subtest: sync pass todo\n' +
13:32:50             ...
13:32:50                 '  ...\n' +
13:32:50                 '# Subtest: functionOnly\n' +
13:32:50             +   '# \x00\x00\x00��\x0Fo""\x04type""\\\\ttest:pass""\x04datao""\x04name""\\\\ffunctionOnly""\x07nestingI\x00""\x04file""v/usr/home/iojs/build/workspace/node-test-commit-freebsd/nodes/freebsd12-x64/test/fixtures/test-runner/output/output.js""\n' +
13:32:50             +   '# testNumberI<""\x07detailso""\\\\vduration_msN4�%\x1B\x0F��?{\x01{\x05{\x02\x00\x00\x00��\x0Fo""\x04type""\n' +
13:32:50             +   '# test:start""\x04datao""\x07nestingI\x00""\x04file""v/usr/home/iojs/build/workspace/node-test-commit-freebsd/nodes/freebsd12-x64/test/fixtures/test-runner/output/output.js""\x04name""\\\\v<anonymous>{\x03{\x02\x00\x00\x00��\x0Fo""\x04type""\\\\ttest:pass""\x04datao""\x04name""\\\\v<anonymous>""\x07nestingI\x00""\x04file""v/usr/home/iojs/build/workspace/node-test-commit-freebsd/nodes/freebsd12-x64/test/fixtures/test-runner/output/output.js""\n' +
13:32:50             +   '# testNumberI>""\x07detailso""\\\\vduration_msN��aNв?{\x01{\x05{\x02\x00\x00\x00��\x0Fo""\x04type""\n' +
13:32:50             +   '# test:start""\x04datao""\x07nestingI\x00""\x04file""v/usr/home/iojs/build/workspace/node-test-commit-freebsd/nodes/freebsd12-x64/test/fixtures/test-runner/output/output.js""\x04name""\x1Etest with only a name provided{\x03{\x02\x00\x00\x00��\x0Fo""\x04type""\\\\ttest:pass""\x04datao""\x04name""\x1Etest with only a name provided""\x07nestingI\x00""\x04file""v/usr/home/iojs/build/workspace/node-test-commit-freebsd/nodes/freebsd12-x64/test/fixtures/test-runner/output/output.js""\n' +
13:32:50             +   '# testNumberI@""\x07detailso""\\\\vduration_msN[z4Փ��?{\x01{\x05{\x02\x00\x00\x00��\x0Fo""\x04type""\n' +
13:32:50             +   '# test:start""\x04datao""\x07nestingI\x00""\x04file""v/usr/home/iojs/build/workspace/node-test-commit-freebsd/nodes/freebsd12-x64/test/fixtures/test-runner/output/output.js""\x04name""\\\\v<anonymous>{\x03{\x02\x00\x00\x00��\x0Fo""\x04type""\\\\ttest:pass""\x04datao""\x04name""\\\\v<anonymous>""\x07nestingI\x00""\x04file""v/usr/home/iojs/build/workspace/node-test-commit-freebsd/nodes/freebsd12-x64/test/fixtures/test-runner/output/output.js""\n' +
13:32:50             +   '# testNumberIB""\x07detailso""\\\\vduration_msN��J\x05\x15�?{\x01{\x05{\x02\x00\x00\x00��\x0Fo""\x04type""\n' +
13:32:50             +   '# test:start""\x04datao""\x07nestingI\x00""\x04file""v/usr/home/iojs/build/workspace/node-test-commit-freebsd/nodes/freebsd12-x64/test/fixtures/test-runner/output/output.js""\x04name""\\\\v<anonymous>{\x03{\x02\x00\x00\x00��\x0Fo""\x04type""\\\\ttest:pass""\x04datao""\x04name""\\\\v<anonymous>""\x07nestingI\x00""\x04file""v/usr/home/iojs/build/workspace/node-test-commit-freebsd/nodes/freebsd12-x64/test/fixtures/test-runner/output/output.js""\n' +
13:32:50             +   '# testNumberID""\x07detailso""\\\\vduration_msN���Z�{�?{\x01""\x04skipT{\x06{\x02\x00\x00\x00��\x0Fo""\x04type""\n' +
13:32:50             +   '# test:start""\x04datao""\x07nestingI\x00""\x04file""v/usr/home/iojs/build/workspace/node-test-commit-freebsd/nodes/freebsd12-x64/test/fixtures/test-runner/output/output.js""\x04name""%test with a name and options provided{\x03{\x02\x00\x00\x01\\\\f�\x0Fo""\x04type""\\\\ttest:pass""\x04datao""\x04name""%test with a name and options provided""\x07nestingI\x00""\x04file""v/usr/home/iojs/build/workspace/node-test-commit-freebsd/nodes/freebsd12-x64/test/fixtures/test-runner/output/output.js""\n' +
13:32:50             +   '# testNumberIF""\x07detailso""\\\\vduration_msN�OU��X�?{\x01""\x04skipT{\x06{\x02\x00\x00\x00��\x0Fo""\x04type""\n' +
13:32:50             +   '# test:start""\x04datao""\x07nestingI\x00""\x04file""v/usr/home/iojs/build/workspace/node-test-commit-freebsd/nodes/freebsd12-x64/test/fixtures/test-runner/output/output.js""\x04name""\x12functionAndOptions{\x03{\x02\x00\x00\x00��\x0Fo""\x04type""\\\\ttest:pass""\x04datao""\x04name""\x12functionAndOptions""\x07nestingI\x00""\x04file""v/usr/home/iojs/build/workspace/node-test-commit-freebsd/nodes/freebsd12-x64/test/fixtures/test-runner/output/output.js""\n' +
13:32:50             +   '# testNumberIH""\x07detailso""\\\\vduration_msN�K���H�?{\x01""\x04skipT{\x06{\x02\x00\x00\x00��\x0Fo""\x04type""\n' +
13:32:50             +   `# test:start""\x04datao""\x07nestingI\x00""\x04file""v/usr/home/iojs/build/workspace/node-test-commit-freebsd/nodes/freebsd12-x64/test/fixtures/test-runner/output/output.js""\x04name""'escaped description \\\\ \\# \\\\\\#\\\\ \n` +
13:32:50             +   `#  \\\\t \\\\f \\\\v \\\\b \\\\r{\x03{\x02\x00\x00\x01\x07�\x0Fo""\x04type""\\\\ttest:pass""\x04datao""\x04name""'escaped description \\\\ \\# \\\\\\#\\\\ \n` +
13:32:50             +   '#  \\\\t \\\\f \\\\v \\\\b \\\\r""\x07nestingI\x00""\x04file""v/usr/home/iojs/build/workspace/node-test-commit-freebsd/nodes/freebsd12-x64/test/fixtures/test-runner/output/output.js""\n' +
13:32:50             +   '# testNumberIJ""\x07detailso""\\\\vduration_msN즔�J�?{\x01{\x05{\x02\x00\x00\x00��\x0Fo""\x04type""\n' +
13:32:50             +   '# test:start""\x04datao""\x07nestingI\x00""\x04file""v/usr/home/iojs/build/workspace/node-test-commit-freebsd/nodes/freebsd12-x64/test/fixtures/test-runner/output/output.js""\x04name""\x14escaped skip message{\x03{\x02\x00\x00\x01\x01�\x0Fo""\x04type""\\\\ttest:pass""\x04datao""\x04name""\x14escaped skip message""\x07nestingI\x00""\x04file""v/usr/home/iojs/build/workspace/node-test-commit-freebsd/nodes/freebsd12-x64/test/fixtures/test-runner/output/output.js""\n' +
13:32:50             +   '# testNumberIL""\x07detailso""\\\\vduration_msNq�����?{\x01""\x04skip""\x05\\#skip{\x06{\x02\x00\x00\x00��\x0Fo""\x04type""\n' +
13:32:50             +   '# test:start""\x04datao""\x07nestingI\x00""\x04file""v/usr/home/iojs/build/workspace/node-test-commit-freebsd/nodes/freebsd12-x64/test/fixtures/test-runner/output/output.js""\x04name""\x14escaped '... 11980 more characters
```

at some point stdout fails to deserialize:
```
13:32:50             # Subtest: <anonymous>
13:32:50             ok 29 - <anonymous>
13:32:50               ---
13:32:50               duration_ms: *
13:32:50               ...
13:32:50             # Subtest: functionOnly
13:32:50             # ��o""type""\\ttest:pass""datao""name""\\ffunctionOnly""nestingI""file""v/usr/home/iojs/build/workspace/node-test-commit-freebsd/nodes/freebsd12-x64/test/fixtures/test-runner/output/output.js""
```
","closed","MoLow",8221854,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/48103",1,"Testes de Regressão",NULL,2,"test runner output output_cli js fail expected value strictly equal line skip tap version subtest sync pass todo subtest functiononly subtest anonymous ok duration_ms stdout fail deserialize subtest anonymous ok duration_ms subtest functiononly test pass


**Explicação do Pré-processamento:**

1. **Remoção de ruídos:** URLs (`https://ci.nodejs.org/job/node-test-commit-freebsd/49824/nodes=freebsd12-x64/consoleFull`),  números de tempo (13:32:50), caracteres especiais (como muitos presentes no bloco de texto com muitos caracteres não imprimíveis), e o código de erro ilegível foram removidos.  

2. **Padronização de palavras:**  Formas flexionadas de verbos e substantivos (como ""failures"" para ""fail"") foram reduzidas à sua forma básica (lemmatization ou stemming). Isso não foi realizado de forma perfeita, pois exige ferramentas de processamento de linguagem natural (NLP) mais avançadas.  A abordagem aqui foi simplificada para atender ao prompt.

3. **Remoção de stop words:** Palavras como ""a"", ""o"", ""em"", ""de"", ""is"", ""this"", etc., que não contribuem significativamente para a classificação de um *issue*, foram removidas. Novamente, uma ferramenta NLP seria ideal para isso, mas uma lista manual foi aplicada.

A saída resultante tenta capturar os termos chave que seriam mais úteis para a classificação do *issue*.  Para um pré-processamento mais completo e preciso, o uso de bibliotecas Python como NLTK ou SpaCy seria altamente recomendado.
","O título da issue ""test runner v8 serialization fails"" e o corpo da issue contêm termos como ""test runner"", ""fail"", ""test pass"", ""subtest"", indicando claramente que o problema está relacionado a testes.  A menção a falhas na serialização sugere um problema de execução de testes e não de código em si, reforçando a classificação como Testes de Regressão."
240,46679,"2023-02-16 10:56:14","2023-02-23 09:47:15","2023-02-23 09:47:15","autoSelectFamily: true breaks TLS","### Version

v19.6.0

### Platform

x64 macOS 13.2.1; x64 Ubuntu 22.04

### Subsystem

tls

### What steps will reproduce the bug?

```js
const socket = tls.connect({ host: 'google.com', port: 443, servername: 'google.com', autoSelectFamily: true }); 
socket.on('secureConnect', () => (console.log('secure connect'), socket.end()))
```

Results in `Error: self-signed certificate` with `autoSelectFamily: true`, works with `autoSelectFamily: false`.

### How often does it reproduce? Is there a required condition?

Consistently.

### What is the expected behavior?

Same as `autoSelectFamily: false` / same as when specifying IP addresses directly (with `servername` set).

### What do you see instead?

TLS certificate validation errors.

### Additional information

_No response_","closed","addaleax",899444,"{confirmed-bug,tls,net}","https://github.com/nodejs/node/issues/46679",5,"Ambos",NULL,7,"erro certificado autocertificado tls conectar google com autoselectfamily impacto plataforma macos ubuntu
","O título da issue (""autoSelectFamily: true breaks TLS"") indica um problema relacionado a TLS (Transport Layer Security), sugerindo a necessidade de correções no código (Refatoração).  Os comentários, por outro lado, discutem a depuração e a busca pela causa raiz do erro, o que inclui testes para verificar se a correção funciona como esperado (Testes de Regressão). A combinação de correção de código e testes indica que a classificação é 'Ambos'."
342,38707,"2021-05-17 11:47:41","2021-05-21 21:17:21","2021-05-21 21:17:21","Unref a socket raise v8 error","* **15.14.0**:
* **Linux**:
* **Debian**:

### What steps will reproduce the bug?
```js
const request = https.get('https://www.google.com', res => {

});

request.on('socket', socket => {
  socket.unref();
})
```

### How often does it reproduce? Is there a required condition?
every time in `Node.js` 15.x and above

### What is the expected behavior?
the process should exit gracefully

### What do you see instead?
```text
FATAL ERROR: v8::HandleScope::CreateHandle() Cannot create a handle without a HandleScope
 1: 0xa89e60 node::Abort() [node]
 2: 0x9ade29 node::FatalError(char const*, char const*) [node]
 3: 0xc7555a v8::Utils::ReportApiFailure(char const*, char const*) [node]
 4: 0xdfdde2 v8::internal::HandleScope::Extend(v8::internal::Isolate*) [node]
 5: 0xe10b7c v8::internal::FactoryBase<v8::internal::Factory>::NewRawOneByteString(int, v8::internal::AllocationType) [node]
 6: 0xe22b8e v8::internal::Factory::NewStringFromOneByte(v8::internal::Vector<unsigned char const> const&, v8::internal::AllocationType) [node]
 7: 0xc8cf72 v8::String::NewFromOneByte(v8::Isolate*, unsigned char const*, v8::NewStringType, int) [node]
 8: 0xc3a317 node::crypto::TLSWrap::InvokeQueued(int, char const*) [node]
 9: 0xc3a422  [node]
10: 0xc3a5e4 node::crypto::TLSWrap::~TLSWrap() [node]
11: 0xc3a751 node::crypto::TLSWrap::~TLSWrap() [node]
12: 0xa20c5b node::Environment::RunCleanup() [node]
13: 0x9d670c node::FreeEnvironment(node::Environment*) [node]
14: 0xacb25f node::NodeMainInstance::Run(node::EnvSerializeInfo const*) [node]
15: 0xa51d7a node::Start(int, char**) [node]
16: 0x7f6d63b5e09b __libc_start_main [/lib/x86_64-linux-gnu/libc.so.6]
17: 0x9d072c  [node]
Aborted (core dumped)
```
","closed","niyan-ly",28030655,"{confirmed-bug,tls}","https://github.com/nodejs/node/issues/38707",3,"Nenhum",NULL,4,"node js fatal error handle scope create handle handle scope process exit gracefully node version linux debian
","O título ""Unref a socket raise v8 error"" e o corpo da issue descrevem um erro fatal no Node.js relacionado a sockets e o gerenciamento de escopo. Os comentários descrevem tentativas de reprodução e possíveis soluções, mas não há menção explícita a refatoração ou testes de regressão.  Não há indicação de que o problema seja resultado de refatoração ou que testes de regressão sejam necessários para solução."
218,47929,"2023-05-09 03:09:15","2023-05-14 05:32:09","2023-05-14 05:32:09","node 20.1.0 --loader seems trigger beforeExit when use await import","### Version

20.1.0

### Platform

macos


### What do you see instead?

My module will close the redis connection at the time of beforeExit, and the await import module (19.9.0) will not trigger beforeExit before.

In addition, the exit event is not triggered when use await import module

","closed","wacdev",127726508,"{confirmed-bug,loaders,v20.x}","https://github.com/nodejs/node/issues/47929",3,"Ambos",NULL,5,"module fechar conexão redis tempo beforeexit await importar modulo disparar beforeexit adição evento exit disparar usar await importar modulo
","A issue menciona refatoração ('refactor internal use public api tamper') e também testes de regressão, pois descreve problemas relacionados à execução do código e ao evento `beforeExit` (ex: 'module fechar conexão redis tempo beforeexit await importar modulo disparar beforeexit', 'reported minimal repro file process beforeexit console log print node experimental loader custom esm loader experimental feature change time console log print beforeexit beforeexit beforeexit').  A busca por soluções e a investigação dos logs apontam para a necessidade de testes para validar as correções após a refatoração."
220,47889,"2023-05-05 22:20:56","2023-05-06 08:11:32","2023-05-08 15:43:05","libc++abi: terminating due to uncaught exception of type std::out_of_range: basic_string Abort trap: 6","### Version

v20.0.0

### Platform

Darwin Flora.local 22.5.0 Darwin Kernel Version 22.5.0: Tue Apr 25 04:06:50 PDT 2023; root:xnu-8796.121.2~8/RELEASE_ARM64_T6020 arm64

### Subsystem

URL

### What steps will reproduce the bug?

When creating a URL object with some invalid url strings, it's straightforward to reproduce:

```JavaScript
new URL('..#', 'a:b');
```

```Bash
libc++abi: terminating due to uncaught exception of type std::out_of_range: basic_string
Abort trap: 6
```

It was initially found in this use case: https://github.com/mozilla/readability/issues/801

### How often does it reproduce? Is there a required condition?

It can be reproduced every time on Linux and macOS as well.

### What is the expected behavior? Why is that the expected behavior?

It should throw an error just like other invalid URLs.

```JavaScript
Uncaught TypeError [ERR_INVALID_URL]: Invalid URL
    at __node_internal_captureLargerStackTrace (node:internal/errors:490:5)
    at new NodeError (node:internal/errors:399:5)
    at new URL (node:internal/url:719:13) {
  input: 'xxxxxxx',
  code: 'ERR_INVALID_URL'
}
```

### What do you see instead?

```Bash
libc++abi: terminating due to uncaught exception of type std::out_of_range: basic_string
Abort trap: 6
```

### Additional information

N/A","closed","Leask",233022,"{confirmed-bug,url}","https://github.com/nodejs/node/issues/47889",9,"Ambos",NULL,0,"criar url objeto string inválido reproduzir facilmente linux macos comportamento esperado erro url semelhante comportamento atual libc++abi terminar exceção tipo std::out_of_range basic_string abort trap
","O título da issue indica um erro de exceção (`std::out_of_range`), sugerindo a necessidade de refatoração para corrigir a manipulação de strings e evitar a exceção.  Os comentários mencionam 'fix' e 'bug', indicando a necessidade de testes de regressão para garantir que a correção não introduza novos problemas. A presença de ambos os aspectos (correção de erro e necessidade de testes) leva à classificação 'Ambos'."
221,47877,"2023-05-05 10:47:21","2023-05-07 10:54:29","2023-07-26 09:29:04","crypto: fix webcrypto private/secret import with empty usages","`private` and `secret` type keys are not allowed to have empty usages

Refs: #47864

cc @tniessen @fhanau

","closed","panva",241506,"{confirmed-bug,crypto,""author ready"",needs-ci,webcrypto,commit-queue-squash}","https://github.com/nodejs/node/pull/47877",8,"Refatoração","https://api.github.com/repos/nodejs/node/pulls/47877",2,"private secret type key allow empty usage
","O título ""crypto: fix webcrypto private/secret import with empty usages"" e o corpo da issue indicam uma correção em um código existente relacionado à importação de chaves privadas/secretas no WebCrypto.  Os comentários discutem a compatibilidade semântica (semver) e potenciais impactos, mas o foco principal é a correção de um problema existente e não a adição de novos testes.  A menção a 'fix' reforça a natureza de refatoração, melhorando o código sem adicionar novos recursos significativos."
222,47864,"2023-05-04 18:40:31","2023-05-07 10:58:33","2023-05-07 10:58:33","Web Crypto API test and key import issues","### Version

v20.1.0

### Platform

_No response_

### Subsystem

crypto.webcrypto

### What steps will reproduce the bug?

_No response_

### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior? Why is that the expected behavior?

_No response_

### What do you see instead?

While looking at Node's crypto API, I found some potential issues in the Web Crypto tests:

- https://github.com/nodejs/node/blob/27467a8698bf263366b937218c2dd94e401dcbea/test/parallel/test-webcrypto-wrap-unwrap.js#L301 In the Wrap-Unwrap tests, the mapping returns the tests instead of adding them to the variations list, this causes the tests in this file to not actually run.
- https://github.com/nodejs/node/blob/27467a8698bf263366b937218c2dd94e401dcbea/test/parallel/test-webcrypto-sign-verify-eddsa.js#L146 Here we import a private EdDsa key with empty usages. Based on the [Web Crypto spec](https://www.w3.org/TR/WebCryptoAPI/#SubtleCrypto-method-importKey) this is not allowed, when importing a private key the usages must not be empty. This also indicates a bug in the implementation as the test cases require non-conforming behavior. Based on a brief search of the code, the test-webcrypto-sign-verify-ecdsa.js and test-webcrypto-sign-verify-rsa.js tests may also be affected.
- https://github.com/nodejs/node/blob/27467a8698bf263366b937218c2dd94e401dcbea/test/parallel/test-webcrypto-export-import-cfrg.js#L311 Less important, but this should be privateUsages.

@jasnell

### Additional information

_No response_","closed","fhanau",12156995,"{confirmed-bug,crypto,test,webcrypto}","https://github.com/nodejs/node/issues/47864",5,"Ambos",NULL,3,"node crypto api potencial issue web crypto test wrap unwrap test map retornar test adicionar variação lista causar test arquivo executar importar privado eddsa key vazio usage base web crypto spec permitir importar privado key usage vazio indicar bug implementação test case requerer comportamento conform base busca código test webcrypto sign verify ecdsa test webcrypto sign verify rsa test afetar menos importante privateusage
","O título menciona ""test"" múltiplas vezes, indicando testes de regressão.  O corpo da issue menciona ""refatoração"" indiretamente ao discutir a correção de um bug na implementação ('indicar bug implementação'),  que pode envolver a modificação do código existente (refatoração).  A menção a testes específicos como 'webcrypto sign verify ecdsa test' e 'webcrypto sign verify rsa test' reforça a presença de testes de regressão. A combinação de correção de bug e testes indica que a issue abrange ambos os aspectos."
345,38641,"2021-05-11 23:29:13","2021-05-14 23:04:53","2021-05-14 23:04:53","doc: syntax-highlighted JSDoc comments in dark mode are low-visibility","# 📗 API Reference Docs Problem

<!--

Thank you for wanting to make nodejs.org better!

This template is for issues with the Node.js API
reference documentation.

For problems with nodejs.org beyond the API
reference documentation, please open an issue
using the issue tracker for our site repository.

  https://github.com/nodejs/nodejs.org

For more general support, please open an issue
using the issue tracker for our help repository.

  https://github.com/nodejs/help

---

For the issue title, please enter a one-line
summary after “doc: ” (preferably 50 characters
or less and no more than 72).

The “✍️” are placeholders signifying requests for
input. Replace them with your responses.

If you are unsure of something, do your best.

-->

<!-- The output of “node --version”. -->

- **Version**: ~16

<!-- The output of “uname -a” (UNIX) or version
and 32-bit or 64-bit (Windows). -->

- **Platform**: n/a

<!-- The name of affected core module. -->

- **Subsystem**: docs

## Location

_Section of the site where the content exists_

Affected URL(s):

- https://nodejs.org/dist/latest-v16.x/docs/api/esm.html#esm_loaders

## Description

_Concise explanation of the problem_

<!-- If applicable, include any screenshots that
may help solve the problem. -->

![image](https://user-images.githubusercontent.com/17770407/117896486-ac416880-b28e-11eb-8ce0-4e1891e4a1cc.png)

---

<!-- Use “[x]” to check the box below if you are
interested in contributing. -->

- [x] I would like to work on this issue and
      submit a pull request.

/cc @nodejs/documentation @aduh95","closed","DerekNonGeneric",17770407,"{confirmed-bug,doc}","https://github.com/nodejs/node/issues/38641",0,"Nenhum",NULL,3,"problema doc api referencia nodejs contribuicao pull request  modulo nucleo afetado doc secao site conteudo url afetado  loader esm html api doc versao plataforma n a  explicacao concisa problema  interessado contribuir
","O título e o corpo da issue não mencionam refatoração ou testes de regressão.  A issue descreve um problema de baixa visibilidade em comentários JSDoc no modo escuro, focando em documentação (doc) e acessibilidade. Não há menção a mudanças de código ou execução de testes."
226,47673,"2023-04-22 18:07:09","2023-09-21 13:37:43","2023-09-21 13:37:43","`.load` accumulates indentation","### Version

v19.9.0

### Platform

Microsoft Windows NT 10.0.22621.0 x64

### Subsystem

repl

### What steps will reproduce the bug?

1. Create a file `example.js` with the following contents:

```js
function f() {
  console.log('hello')
  console.log(`goodbye
world
  !`)
}
f()
```

2. Run the REPL via `node`, and enter the following command:

```
> .load example.js
```



### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

I expect the REPL to repeat code exactly as it appears in `example.js`:

```js
function f() {
  console.log('hello')
  console.log(`goodbye
world
  !`)
}
f()
```

And then for the code to output:

```
hello
goodbye
world
  !
```

(For example, this is the output from `node example.js`.)

### What do you see instead?

The REPL repeats the code with accumulated indentation, where each line includes all of the indentation from all previous lines:

```js
function f() {
  console.log('hello')
    console.log(`goodbye
    world
      !`)
      }
      f()
```

This results in incorrect behavior with the template string. The code outputs:

```
hello
goodbye
    world
      !
```

### Additional information

This issue arose when using the `repl` package to make a REPL for an indentation-based language, Civet. `.load` is then nonfunctional; see https://github.com/DanielXMoore/Civet/issues/509

But it also affects correctness of JavaScript as illustrated above.","closed","edemaine",2218736,"{confirmed-bug,repl}","https://github.com/nodejs/node/issues/47673",2,"Refatoração",NULL,152,"problema repl carregar arquivo javascript indentação incorreta saida incorreta template string  linguagem baseada indentação  pacote repl  funcionalidade load
","O título da issue ""`.load` accumulates indentation"" sugere um problema de formatação ou estruturação do código, indicando a necessidade de refatoração para corrigir a acumulação de indentação incorreta na função `.load`. O corpo da issue menciona ""indentação incorreta"" e  ""saída incorreta"", reforçando a necessidade de ajustes no código sem necessariamente implicar em novos testes, apenas na correção de um problema existente."
241,46670,"2023-02-15 15:47:16","2023-02-17 14:07:54","2023-02-17 14:07:55","`--enable-network-family-autoselection` causes ERR_INTERNAL_ASSERTION with `fetch()` in REPL","### Version

v19.6.0

### Platform

node:latest docker image on Linux 5.15.91-1-MANJARO x86_64 GNU/Linux

### Subsystem

fetch/net/repl?

### What steps will reproduce the bug?

```console
$ docker run --rm -it node:latest --enable-network-family-autoselection
Welcome to Node.js v19.6.0.
Type "".help"" for more information.
> await fetch('http://<redacted>/')
Uncaught TypeError: fetch failed
    at Object.fetch (node:internal/deps/undici/undici:12789:11)
    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)
    at async REPL5:1:33 {
  cause: ConnectTimeoutError: Connect Timeout Error
      at onConnectTimeout (node:internal/deps/undici/undici:8236:28)
      at node:internal/deps/undici/undici:8194:50
      at Immediate._onImmediate (node:internal/deps/undici/undici:8225:13)
      at process.processImmediate (node:internal/timers:475:21)
      at process.topLevelDomainCallback (node:domain:161:15)
      at process.callbackTrampoline (node:internal/async_hooks:128:24) {
    code: 'UND_ERR_CONNECT_TIMEOUT'
  }
}
> Uncaught:
Error [ERR_INTERNAL_ASSERTION]: This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues

    at __node_internal_captureLargerStackTrace (node:internal/errors:490:5)
    at new NodeError (node:internal/errors:399:5)
    at assert (node:internal/assert:14:11)
    at internalConnectMultiple (node:net:1070:3)
    at afterConnectMultiple (node:net:1532:5)
    at TCPConnectWrap.callbackTrampoline (node:internal/async_hooks:130:17) {
  code: 'ERR_INTERNAL_ASSERTION'
}
> Uncaught:
Error [ERR_INTERNAL_ASSERTION]: This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues

    at __node_internal_captureLargerStackTrace (node:internal/errors:490:5)
    at new NodeError (node:internal/errors:399:5)
    at assert (node:internal/assert:14:11)
    at internalConnectMultiple (node:net:1070:3)
    at afterConnectMultiple (node:net:1532:5)
    at TCPConnectWrap.callbackTrampoline (node:internal/async_hooks:130:17) {
  code: 'ERR_INTERNAL_ASSERTION'
}
>
```

### How often does it reproduce? Is there a required condition?

It appears to reproduce every time when none of the target IPs are reachable, but only in the REPL. (It's possible that it also happens without the REPL, but I haven't seen it anywhere else yet.)

### What is the expected behavior?

No `ERR_INTERNAL_ASSERTION`.

### What do you see instead?

`ERR_INTERNAL_ASSERTION`.

### Additional information

The DNS setup within the network appears to be rather complicated, and the error message `fetch failed` is expected when the network node cannot be reached via any of the associated A or AAAA records. However, the `ERR_INTERNAL_ASSERTION` error is unexpected.","closed","tniessen",3109072,"{confirmed-bug,net,fetch}","https://github.com/nodejs/node/issues/46670",1,"Nenhum",NULL,2,"node latest docker image linux x86 gnu linux fetch net repl docker run node enable network family autoselection fetch failed connect timeout error err internal assertion err internal assertion target ip reachable repl err internal assertion dns setup network complicated error message fetch failed expected network node reach associate aaaaa record err internal assertion unexpected
","A issue descreve um erro (`ERR_INTERNAL_ASSERTION`) ao usar `fetch()` com a flag `--enable-network-family-autoselection` no REPL do Node.js dentro de um container Docker.  Não há menção explícita à refatoração de código ou a testes de regressão. O corpo da issue foca na descrição do problema e um comentário sugere que seja fechada como duplicata.  Portanto, não há evidências suficientes para classificá-la como Refatoração, Testes de Regressão ou Ambos."
326,39822,"2021-08-20 16:20:26","2021-08-28 11:59:55","2021-08-28 11:59:55","segmentation fault with rsa-pss when pss params don't match the operation","### Version

v16.7.0

### Platform

Darwin C02CX0K5MD6V 20.6.0 Darwin Kernel Version 20.6.0: Wed Jun 23 00:26:31 PDT 2021; root:xnu-7195.141.2~5/RELEASE_X86_64 x86_64

### Subsystem

crypto

### What steps will reproduce the bug?

```js
const crypto = require('node:crypto')

const pk = `-----BEGIN PRIVATE KEY-----
MIIE7wIBADA9BgkqhkiG9w0BAQowMKANMAsGCWCGSAFlAwQCAaEaMBgGCSqGSIb3
DQEBCDALBglghkgBZQMEAgGiAwIBEASCBKkwggSlAgEAAoIBAQDfqNM4C+QtD73i
ILqOkqfV8ha3O19jpX8UujIk1Z72bbbuwEzh0+sBw0dD0N8CgkXnePOEEd6q7HNm
byCNqRpDK6NDvaCMDWgEaD/PlHkRntvKh81IXSMC5imjRfOcZIE/Gnw7h8tanab0
n75+ODvLJrmEWUG2q79Im1mWMx7Spod+Np6XEY+7I7nAUUWivr35Yx5DeyxY8rxF
GpsLtGsi7JNQO4aHyeBpj8tz0Fhv23uPywE2nGmPHfnkXWbrTcHGbzYBgEbeSH9K
UkRwczqDXNOPhtfaEHEFTm0MoeKCnJe1VOjSywev77dV1KZfpVh3Kh0ZRQIe9YOV
Jhj4lMx3AgMBAAECggEBAIc+IgK5Bg/NfgeXvNdrjPuM+PlxeHvb3h1dfebSGd5v
d3elZpgDug6F07kJO2Db/4M5mx7YY2m9swZU2j1u7MeDQqU6rDMkBCruEu/lmtPx
2Hv+ZD6Gux4MqU7mhKmkCJds34Rr16aCwCsZ0WmnfViZoQKLqnXYIsG31pNBdDjx
gke0HhX1LkA9yTVwlk8xOaHPqI4KfsFAyoiiHzyttGDexzb1PzmM0pybAPDMhpN/
wXp2kLjyzmUmPe2Y2yva69WVWo7qS6joKjY75MQ1t20HYgEL69IApvCPu4CANfi9
j3FAaV/+WrnhKCi6QyUi5PCI/+AJLsjNQmqTXIdBEoECgYEA+XsgFbeZ6+ZzEHa7
HyFH6kiyBLd0q7w+ZLPsoOmEApDaP3yXSC7eJU7M/tPUPj8VQMMSK2D6fgmUDwhb
3mEXFZxf67UlPFsFjweYcBihwy4r8QKBwury6dEbHPSUq4mXFJF5XRQdGqRGkr/F
8OLZ0MwmHLUzczA67PxP/wF8TsECgYEA5YD4RxxJJYfAk1rFbqHRhNB8UeYVL+Wo
wsRET1JeFg+S5grLGUga+KBB8Jn7Ahaip7MVE0Iud1cgaDi4WBEJsbJ6oJTlHJEg
Jq7QAaBafwjeSCSnaEsVBVNvriy2WF7uAomLSKmW6uSUOBBFFt4+G+akG56EfOPc
7YKBfsf5ITcCgYBvjVZzX307tfeNTQmuibsWTxsKcN2CTNG5RZpw+PlGDG8KJDOg
2xQJqoqPBzjH/H0MUC03qE1ZPf8uGZa6gL9JsnpRctYLfselhMfsl5b9JxAO3AgZ
l+S2GAH/mH1BlmwvjjyuGehJmVrVE1r2sviiHCaOf5dZ0h8HCGrco1VqAQKBgQCf
fYkMofOTSUvjG2mpAHuCOQCsSaDfsFIfSBXQqgUIf7ouc8HAyAM2VOh+NAPj56cR
s7opsAxqkvnKc+BoEy8Rdl8RyWeO+qvFNicHelBph9gxeod8SvFIyjsKZ7gwoYf1
63AIBxMCGeeHLodU5Q10hkv1hau8vv2BcPhdCstu8QKBgQDgO4Rr36Pa5rjbNbGN
PsJqALjthTeU0yaU8hdC7Hc7B/T6npEIhw3s1eNq7e0eeDltqz7tDnY8qysazbQZ
p1cV5TJ8+gtwGmDoADBnU1NXqX4Squfml6OhNEucpTdjux7JdLVmmQFraOT2Eu5f
9uuNtA+d8uhBEXhskuvEC552ug==
-----END PRIVATE KEY-----`

crypto.sign('sha256', Buffer.from('hello'), pk) // works
crypto.sign('sha384', Buffer.from('hello'), pk) // segmentation fault
```

### How often does it reproduce? Is there a required condition?

always

### What is the expected behavior?

`crypto.sign` and `crypto.verify` would throw an appropriate error

### What do you see instead?

segmentation fault

### Additional information

The private key is taken directly from `/test/fixtures/keys/rsa_pss_private_2048_sha256_sha256_16.pem`","closed","panva",241506,"{confirmed-bug,crypto,webcrypto}","https://github.com/nodejs/node/issues/39822",4,"Ambos",NULL,8,"version v16.7 platform darwin subsystem crypto step reproduce bug crypto sign sha256 buffer hello pk crypto sign sha384 buffer hello pk often reproduce required condition always expected behavior crypto sign crypto verify throw appropriate error see instead segmentation fault additional information private key taken directly test fixtures keys rsa pss private 2048 sha256 sha256 16 pem
","O título da issue indica um problema de segmentação ('segmentation fault') durante a assinatura RSA-PSS, sugerindo um bug que precisa ser corrigido (Refatoração).  Os comentários discutem a necessidade de mensagens de erro melhores e testes adicionais para o caso de falha ('port rsa pss test'), indicando a necessidade de testes de regressão para verificar a correção do bug e garantir que novas falhas não sejam introduzidas."
347,38499,"2021-05-01 16:18:50","2021-05-06 17:32:37","2021-05-06 17:32:37","`worker_threads.moveMessagePortToContext` results in an abort","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: v17.0.0-pre
* **Platform**: Linux 5.8.0-38-generic #43~20.04.1-Ubuntu SMP Tue Jan 12 16:39:47 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
* **Subsystem**: worker_threads.moveMessagePortToContext

### What steps will reproduce the bug?
Setup a node instance,
```
» node
```
and run the following javascript code line by line.
```
worker_threads = require('worker_threads');msgChannel = new worker_threads.MessageChannel();
msgChannel.port2.close();
worker_threads.moveMessagePortToContext(msgChannel.port2,{});
```
Then an abort occurs. 
Noticed that paste these codes to REPL all at once seems cannot trigger this abort. Run these codes line by line pls.
<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->

### How often does it reproduce? Is there a required condition?
This problem can always be triggered following the steps above.

### What is the expected behavior?
If any error occurs, an exception or other similar error-reporting stuff should be thrown. There is no reason to abort the whole node process.

<!--
If possible please provide textual output instead of screenshots.
-->

### What do you see instead?
```
» node
Welcome to Node.js v17.0.0-pre.
Type "".help"" for more information.
> worker_threads = require('worker_threads');msgChannel = new worker_threads.MessageChannel();
MessageChannel {
  port1: MessagePort [EventTarget] {
    active: true,
    refed: false,
    [Symbol(kEvents)]: SafeMap(2) [Map] {
      'newListener' => [Object],
      'removeListener' => [Object]
    },
    [Symbol(events.maxEventTargetListeners)]: 10,
    [Symbol(events.maxEventTargetListenersWarned)]: false,
    [Symbol(kNewListener)]: [Function (anonymous)],
    [Symbol(kRemoveListener)]: [Function (anonymous)],
    [Symbol(nodejs.internal.kCurrentlyReceivingPorts)]: undefined
  },
  port2: MessagePort [EventTarget] {
    active: true,
    refed: false,
    [Symbol(kEvents)]: SafeMap(2) [Map] {
      'newListener' => [Object],
      'removeListener' => [Object]
    },
    [Symbol(events.maxEventTargetListeners)]: 10,
    [Symbol(events.maxEventTargetListenersWarned)]: false,
    [Symbol(kNewListener)]: [Function (anonymous)],
    [Symbol(kRemoveListener)]: [Function (anonymous)],
    [Symbol(nodejs.internal.kCurrentlyReceivingPorts)]: undefined
  }
}
> msgChannel.port2.close();
undefined
> worker_threads.moveMessagePortToContext(msgChannel.port2,{});
/home/zys/Toolchains/node/node[59534]: ../src/node_messaging.cc:1068:static void node::worker::MessagePort::MoveToContext(const FunctionCallbackInfo<v8::Value> &): Assertion `(port) != nullptr' failed.
 1: 0x3623e04 node::DumpBacktrace(_IO_FILE*) [/home/zys/Toolchains/node/node]
 2: 0x37bb92e node::Abort() [/home/zys/Toolchains/node/node]
 3: 0x37bb3f8  [/home/zys/Toolchains/node/node]
 4: 0x38c8dac node::worker::MessagePort::MoveToContext(v8::FunctionCallbackInfo<v8::Value> const&) [/home/zys/Toolchains/node/node]
 5: 0x3ebd0d8 v8::internal::FunctionCallbackArguments::Call(v8::internal::CallHandlerInfo) [/home/zys/Toolchains/node/node]
 6: 0x3ebadb9  [/home/zys/Toolchains/node/node]
 7: 0x3eb8d1d  [/home/zys/Toolchains/node/node]
 8: 0x5a08759  [/home/zys/Toolchains/node/node]
[1]    59534 abort (core dumped)  /home/zys/Toolchains/node/node
```
<!--
If possible please provide textual output instead of screenshots.
-->

### Additional information

<!--
Tell us anything else you think we should know.
-->
","closed","zyscoder",23655282,"{confirmed-bug,c++,""good first issue"",worker}","https://github.com/nodejs/node/issues/38499",1,"Nenhum",NULL,5,"version v17 pre platform linux x86 subsystem worker threads movemessageporttocontext step reproduce bug setup node instance run javascript code line line worker threads require worker threads msgchannel new worker threads messagechannel msgchannel port close worker threads movemessageporttocontext msgchannel port abort noticed paste code repl once seem cannot trigger abort run code line line problem always trigger step expect behavior error occur exception similar error reporting stuff thrown reason abort whole node process see instead node welcome node v17 pre type help information worker threads require worker threads msgchannel new worker threads messagechannel messagechannel port port port close undefined worker threads movemessageporttocontext msgchannel port home src node messaging assertion port nullptr failed node dumpbacktrace node abort node node node worker messageport movetocontext node internal functioncallbackarguments call node node node node abort core dumped additional information
","A issue descreve um crash no Node.js v17 relacionado à função `worker_threads.moveMessagePortToContext`.  O título e a descrição focam em um problema de funcionamento e não mencionam refatoração de código ou testes de regressão. A informação nos comentários reforça o problema de funcionamento, sem mencionar atividades de desenvolvimento como refatoração ou testes."
229,47566,"2023-04-14 21:59:12","2023-04-21 12:27:56","2023-05-08 11:50:49","Using custom loaders results in a load loop / OOM","### Version

v20.0.0-nightly20230414c94be4125b

### Platform

Linux server 5.15.0-69-generic #76-Ubuntu SMP Fri Mar 17 17:19:29 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

_No response_

### What steps will reproduce the bug?

```sh
touch loader.js
echo ""setInterval(() => {}, 1000);"" > test.cjs
node --loader ./loader.js test.cjs
```

### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior? Why is that the expected behavior?

Node.js starts up without loading the provided loader over and over again.

### What do you see instead?

Node.js spams the console with the following warning while the memory and CPU usage climbs until it's stopped / OOMs.
```
(node:5652) ExperimentalWarning: Custom ESM Loaders is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
```

### Additional information

Possibly relevant https://github.com/nodejs/node/pull/44710","closed","merceyz",3842800,"{confirmed-bug,loaders}","https://github.com/nodejs/node/issues/47566",21,"Ambos",NULL,7,"node js start loader repeatedly memory cpu usage climb oom experimental custom esm loader experimental feature change time
","O título da issue indica um problema de loop de carregamento e estouro de memória (OOM), sugerindo um problema de desempenho que precisa de refatoração.  Porém, vários comentários mencionam testes de reprodução, flags de teste (`require flag`),  atualizações na reprodução do problema e até mesmo a menção de um 'fix ready', indicando que testes de regressão foram realizados para confirmar a correção. A combinação de ambos os aspectos leva à classificação 'Ambos'."
230,47555,"2023-04-14 03:36:18","2023-04-19 17:57:37","2023-04-19 17:57:38","URL parser behaviour change in 18.16.0","18.15.0

`new URL(HTTP://AMAZON.COM).href` gives `http://amazon.com/`

18.16.0
`new URL(HTTP://AMAZON.COM).href` gives `http://amaZon.com/`

It seems the capital letter Z is not lower cased. Is that expected or is it a regression ?","closed","nabinked",7703179,"{confirmed-bug,whatwg-url,v18.x}","https://github.com/nodejs/node/issues/47555",8,"Ambos",NULL,6,"seem capital letter z lower case expect regression
","O título ""URL parser behaviour change in 18.16.0"" sugere uma mudança de comportamento, que pode necessitar de refatoração. Os comentários mencionam problemas de regressão (""regression"", ""expect regression"", ""bug""), indicando a necessidade de testes de regressão para garantir que a mudança não introduziu outros problemas.  A combinação de uma mudança comportamental e a necessidade de testes de regressão leva à classificação 'Ambos'."
232,47457,"2023-04-07 00:06:25","2023-10-10 19:34:34","2023-10-10 19:34:34","Assertion `(expected_utf16_length) == (utf16_length)' failed","### Version

v19.8.1

### Platform

Microsoft Windows NT 10.0.22621.0 x64

### Subsystem

_No response_

### What steps will reproduce the bug?

1. node
2. // start typing new Date()
3. new Date
4. throw error and close cli



### How often does it reproduce? Is there a required condition?

Every time I try this in cli.

### What is the expected behavior? Why is that the expected behavior?

Display current date.
Date Thu Apr 06 2023 21:06:02 GMT-0300

### What do you see instead?

```
new DateWindows PowerShell[5012]: c:\ws\src\inspector\node_string.cc:39: Assertion `(expected_utf16_length) == (utf16_length)' failed.
 1: 00007FF7DD50234F node_api_throw_syntax_error+179983
 2: 00007FF7DD486986 v8::internal::MicrotaskQueue::GetMicrotasksScopeDepth+61942
 3: 00007FF7DD486D62 v8::internal::MicrotaskQueue::GetMicrotasksScopeDepth+62930
 4: 00007FF7DD34EB55 std::basic_ios<char,std::char_traits<char> >::init+597
 5: 00007FF7DD367E8A v8::internal::IncrementalMarking::IsMarking+29514
 6: 00007FF7DD365796 v8::internal::IncrementalMarking::IsMarking+19542
 7: 00007FF7DD359CA7 std::basic_ostream<char,std::char_traits<char> >::put+45383
 8: 00007FF7DDF7E81E v8::internal::Builtins::name+314382
 9: 00007FF7DDF7E418 v8::internal::Builtins::name+313352
10: 00007FF7DDF7E6F9 v8::internal::Builtins::name+314089
11: 00007FF7DDF7E550 v8::internal::Builtins::name+313664
12: 00007FF7DE06FB61 v8::internal::SetupIsolateDelegate::SetupHeap+606961
13: 00007FF75E1D7EF7
```

### Additional information

_No response_","closed","danpeixoto",29102315,"{confirmed-bug,windows}","https://github.com/nodejs/node/issues/47457",47,"Ambos",NULL,187,"erro data cli exibir data atual asserção falha
","A issue relata um erro de asserção (`Assertion '(expected_utf16_length) == (utf16_length)' failed`) relacionado à manipulação de strings UTF-16, sugerindo um problema de refatoração no código de tratamento de strings.  Porém, os diversos comentários descrevem tentativas de reprodução em diferentes plataformas (Windows, macOS, Ubuntu), versões do Node.js, e shells (cmd, PowerShell, Git Bash, WSL), indicando a necessidade de testes de regressão para garantir a correção do problema em vários contextos e plataformas.  A combinação de um possível erro de codificação (refatoração) e a necessidade de testes extensivos em diferentes ambientes justifica a classificação como 'Ambos'."
233,47096,"2023-03-14 20:13:01","2023-03-15 14:35:09","2023-03-25 04:21:49","[v19.8.0] `module_wrap.cc:599: Assertion (it) != (env->id_to_function_map.end())' failed.`","edit @bnoordhuis: fixed in v19.8.1

### Version

v19.8.0

### Platform

all

### Subsystem

_No response_

### What steps will reproduce the bug?

<del>Sorry haven't found a minimal repro.
I'll update here if I do.
Currently, it can be reproduced through the following steps.
git clone https://github.com/babel/babel
make bootstrap
yarn jest
</del>

This is still not minimal, but I can't find where it crashes.
https://github.com/liuxingbaoyu/node-bug

### How often does it reproduce? Is there a required condition?

always

### What is the expected behavior? Why is that the expected behavior?

_No response_

### What do you see instead?


```
2023-03-14T19:29:13.0710897Z Administrator:  C:\Windows\system32\cmd.exe [5240]: c:\ws\src\module_wrap.cc:599: Assertion `(it) != (env->id_to_function_map.end())' failed.
2023-03-14T19:29:13.3555749Z  1: 00007FF66C7722FF node_api_throw_syntax_error+180191
2023-03-14T19:29:13.3556967Z  2: 00007FF66C6F69D6 v8::internal::MicrotaskQueue::GetMicrotasksScopeDepth+61942
2023-03-14T19:29:13.3558529Z  3: 00007FF66C6F6DB2 v8::internal::MicrotaskQueue::GetMicrotasksScopeDepth+62930
2023-03-14T19:29:13.3559858Z  4: 00007FF66C737520 v8::internal::ReusableUnoptimizedCompileState::ast_raw_string_zone+9696
2023-03-14T19:29:13.3561012Z  5: 00007FF66D0F53AD v8::internal::Isolate::RunHostImportModuleDynamicallyCallback+605
2023-03-14T19:29:13.3562005Z  6: 00007FF66CD5AFD4 v8::internal::Runtime::SetObjectProperty+2548
2023-03-14T19:29:13.3562926Z  7: 00007FF66D2DFC0C v8::internal::SetupIsolateDelegate::SetupHeap+607212
2023-03-14T19:29:13.3563798Z  8: 00007FF66D38D0A5 v8::internal::SetupIsolateDelegate::SetupHeap+1316997
2023-03-14T19:29:13.3564699Z  9: 00007FF66D257330 v8::internal::SetupIsolateDelegate::SetupHeap+47888
2023-03-14T19:29:13.3565674Z 10: 00007FF66D257330 v8::internal::SetupIsolateDelegate::SetupHeap+47888
2023-03-14T19:29:13.3566794Z 11: 00007FF66D257330 v8::internal::SetupIsolateDelegate::SetupHeap+47888
2023-03-14T19:29:13.3588911Z 12: 00007FF66D28EE58 v8::internal::SetupIsolateDelegate::SetupHeap+276024
2023-03-14T19:29:13.3594449Z 13: 00007FF66D338985 v8::internal::SetupIsolateDelegate::SetupHeap+971109
2023-03-14T19:29:13.3595158Z 14: 00007FF66D27ECE0 v8::internal::SetupIsolateDelegate::SetupHeap+210112
2023-03-14T19:29:13.3595968Z 15: 00007FF66D2559AB v8::internal::SetupIsolateDelegate::SetupHeap+41355
2023-03-14T19:29:13.3603881Z 16: 00007FF66D105CA0 v8::internal::Execution::CallWasm+1664
2023-03-14T19:29:13.3608875Z 17: 00007FF66D105DBB v8::internal::Execution::CallWasm+1947
2023-03-14T19:29:13.3611841Z 18: 00007FF66D106B6A v8::internal::Execution::TryCallScript+346
2023-03-14T19:29:13.3612868Z 19: 00007FF66D0DE6E2 v8::internal::MicrotaskQueue::RunMicrotasks+370
2023-03-14T19:29:13.3613780Z 20: 00007FF66D0DE4AA v8::internal::MicrotaskQueue::PerformCheckpointInternal+74
2023-03-14T19:29:13.3614380Z 21: 00007FF66C7A680E node::CallbackScope::~CallbackScope+414
2023-03-14T19:29:13.3614959Z 22: 00007FF66C7A6CB0 node::CallbackScope::~CallbackScope+1600
2023-03-14T19:29:13.3615592Z 23: 00007FF66C79E378 v8::internal::compiler::Operator::EffectOutputCount+248
2023-03-14T19:29:13.3616279Z 24: 00007FF66C6EFCAB v8::internal::MicrotaskQueue::GetMicrotasksScopeDepth+33995
2023-03-14T19:29:13.3616899Z 25: 00007FF66C6E241F v8::base::CPU::has_fpu+50495
2023-03-14T19:29:13.3617533Z 26: 00007FF66C6F1775 v8::internal::MicrotaskQueue::GetMicrotasksScopeDepth+40853
2023-03-14T19:29:13.3618080Z 27: 00007FF66C7D79E7 uv_timer_stop+1207
2023-03-14T19:29:13.3618550Z 28: 00007FF66C7D3E5B uv_update_time+491
2023-03-14T19:29:13.3619020Z 29: 00007FF66C7D39A2 uv_run+1266
2023-03-14T19:29:13.3619472Z 30: 00007FF66C7A5F95 node::SpinEventLoop+389
2023-03-14T19:29:13.3620296Z 31: 00007FF66C6AD3C8 cppgc::internal::Marker::conservative_visitor+51768
2023-03-14T19:29:13.3621201Z 32: 00007FF66C732A4E node::InitializeOncePerProcess+2990
2023-03-14T19:29:13.3621804Z 33: 00007FF66C734D0E node::Start+3566
2023-03-14T19:29:13.3622418Z 34: 00007FF66C733F50 node::Start+48
2023-03-14T19:29:13.3622911Z 35: 00007FF66C53E44C AES_cbc_encrypt+150140
2023-03-14T19:29:13.3623418Z 36: 00007FF66D8A13D4 inflateValidate+19028
2023-03-14T19:29:13.3623974Z 37: 00007FF8CC524DE0 BaseThreadInitThunk+16
2023-03-14T19:29:13.3624501Z 38: 00007FF8CD89E40B RtlUserThreadStart+43
2023-03-14T19:29:14.5277623Z ##[error]Process completed with exit code 1.
```

### Additional information
This is a regression bug.
Might be related to https://github.com/nodejs/node/pull/46785.","closed","liuxingbaoyu",30521560,"{confirmed-bug,module}","https://github.com/nodejs/node/issues/47096",26,"Ambos",NULL,1,"assertion  node  crash  regression  bug  relate  pull  request
","O título da issue indica um problema de regressão (""regression bug""),  enquanto o corpo e os comentários descrevem tentativas de solução envolvendo a atualização e a regressão da versão do Node.js.  A solução envolve, portanto, tanto a correção do bug (refatoração implicita na correção) quanto testes de regressão para verificar a estabilidade após a correção da versão. Palavras como 'downgrade', 'upgrade', 'fix', 'assertion failed', e 'crash' reforçam a presença de ambos os aspectos."
356,37794,"2021-03-18 09:40:23","2021-03-18 19:11:05","2021-03-18 19:11:05","crypto: verify with callback crashes when private key is used","Introduced in #37500 (released with v15.12.0) the function call crashes node when a private key object is passed to verify when using the callback argument.

```js
const crypto = require('crypto');
const assert = require('assert');

const data = Buffer.from('hello');
const { privateKey } = crypto.generateKeyPairSync('ed25519');
const signature = crypto.sign(null, data, privateKey);

assert(crypto.verify(null, data, privateKey, signature)); // OK

crypto.verify(null, data, privateKey, signature, (err, verified) => { // 💥
  assert(!err);
  assert(verified);
});
```

```
node[49326]: ../src/crypto/crypto_sig.cc:850:static bool node::crypto::SignTraits::DeriveBits(node::Environment *, const node::crypto::SignConfiguration &, node::crypto::ByteSource *): Assertion `(params.key->GetKeyType()) == (kKeyTypePublic)' failed.
```

This can never happen in webcrypto where this implementation was first used but it is a valid input for one shot verify.

I'm looking into a fix and expanding the test suite.

cc @jasnell ","closed","panva",241506,"{confirmed-bug,crypto}","https://github.com/nodejs/node/issues/37794",0,"Ambos",NULL,0,"introduc function call crash node private key object pass verify use callback argument look fix expand test suite
","O título indica um problema de crash ('crashes') relacionado à verificação com chave privada. O corpo menciona a necessidade de corrigir ('fix') e expandir a suíte de testes ('expand test suite').  A menção à correção implica em refatoração do código para resolver o crash, enquanto a expansão da suíte de testes indica a necessidade de testes de regressão para garantir que a correção não introduza novos problemas."
235,46959,"2023-03-05 05:41:13","2023-03-16 20:39:38","2023-03-16 20:39:38","test runner breaks with ERR_TAP_LEXER_ERROR while trying a console.dir with colors flag set ( {colors: true} )","### Version

v19.7.0

### Platform

Linux lnv 5.15.0-56-generic #62-Ubuntu SMP Tue Nov 22 19:54:14 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

test_runner

### What steps will reproduce the bug?

```js 
// test-console_colors.js

import { it } from 'node:test'
const obj = { a: 1, b: 2}
it('test-console-no-colors', () => {
    console.dir(obj, { colors: false })
}); 

it('test-console-with-colors', () => {
    console.dir(obj, { colors: true })
}); 
````
node --test test-console_colors.js 



### How often does it reproduce? Is there a required condition?

always

### What is the expected behavior?

should be same as when I run:  node del/test-console_colours.js 
````
{ a: 1, b: 2 }
{ a: 1, b: 2 }
TAP version 13
# Subtest: test-console-no-colours
ok 1 - test-console-no-colours
  ---
  duration_ms: 5.98973
  ...
# Subtest: test-console-with-colours
ok 2 - test-console-with-colours
  ---
  duration_ms: 0.511385
  ...
1..2
# tests 2
# pass 2
# fail 0
# cancelled 0
# skipped 0
# todo 0
# duration_ms 13.586095
````

### What do you see instead?

````
TAP version 13
# Subtest: /_nm/prgs/node/acropolis-ch/del/test-console_colours.js
    # { a: 1, b: 2 }
not ok 1 - /_nm/prgs/node/acropolis-ch/del/test-console_colours.js
  ---
  duration_ms: 52.299434
  failureType: 'uncaughtException'
  error: 'Unexpected character: \x1B at line 1, column 0'
  code: 'ERR_TAP_LEXER_ERROR'
  stack: |-
    Socket.emit (node:events:512:28)
    Socket.read (node:net:742:39)
    async Promise.all (index 1)
  ...
1..1
# tests 1
# pass 0
# fail 1
# cancelled 0
# skipped 0
# todo 0
# duration_ms 66.556183
````

### Additional information

1. Looks like similar/related to  [this issue 45706](https://github.com/nodejs/node/issues/45706)
2. same error happens even if I run console.dir outside subtest (it) ","closed","nickmilon",416678,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/46959",3,"Testes de Regressão",NULL,12,"test runner console dir color issue unexpected character line column error tap lexer error node test subtest  run console dir outside subtest similar related issue
","O título da issue menciona 'test runner', indicando um problema com a ferramenta de execução de testes.  O corpo da issue descreve um erro ('ERR_TAP_LEXER_ERROR') ocorrido durante a execução de testes, com detalhes sobre a utilização de cores no console. Os comentários também se referem a problemas relacionados à execução dos testes.  Não há menção a refatoração de código."
237,46765,"2023-02-22 08:59:50","2023-02-26 15:56:22","2023-02-26 15:56:22","stream.Transform changing order of items","### Version

v18.14.1

### Platform

Linux 703748a51615 5.18.8-051808-generic #202206290850 SMP PREEMPT_DYNAMIC Wed Jun 29 08:59:08 UTC 2022 x86_64 Linux

### Subsystem

stream

### What steps will reproduce the bug?

```js
const stream = require(""node:stream"");
const consumers = require(""node:stream/consumers"");
const createInnerTransfrom = () => new stream.Transform({
    objectMode: true,
    construct(callback) {
        this.push('header from constructor\n');
        callback();
    },
    transform: (row, encoding, callback) => {
        callback(null, JSON.stringify(row) + '\n');
    },
});
const createOuterTransfrom = () => {
    let innerTranfrorm;
    return new stream.Transform({
        objectMode: true,
        transform(row, encoding, callback) {
            if (!innerTranfrorm) {
                innerTranfrorm = createInnerTransfrom();
                innerTranfrorm.on('data', (data) => this.push(data));
                callback();
            }
            else if (innerTranfrorm.write(row)) {
                process.nextTick(callback);
            }
            else {
                innerTranfrorm.once('drain', callback);
            }
        },
    });
};
consumers.text(stream.Readable.from([
    'create InnerTransform',
    'firstLine',
    'secondLine',
]).pipe(createOuterTransfrom())).then((text) => console.log('output:\n', text));
```

### How often does it reproduce? Is there a required condition?

always

### What is the expected behavior?

```
output:
 header from constructor
""firstLine""
""secondLine""

```

### What do you see instead?

```
output:
 header from constructor
""secondLine""
""firstLine""

```

### Additional information

I expect `Transform` to **always** process incoming items in order, even with reckless code like in the example.","closed","zuozp8",1228107,"{confirmed-bug,stream}","https://github.com/nodejs/node/issues/46765",14,"Ambos",NULL,4,"process incoming item order reckless code example stream transform always process incoming item order
","O título e o corpo da issue indicam um problema com a ordem de processamento de itens em um `stream.Transform`, sugerindo uma necessidade de refatoração do código para corrigir o comportamento inesperado.  Os comentários, no entanto, mostram um processo de depuração, testes (ex: ""test simplify version"") e finalmente a solução do problema (""bug fix""), indicando que testes de regressão foram realizados ou eram necessários para validar a correção."
238,46755,"2023-02-21 19:39:36","2023-02-24 19:28:47","2023-02-24 19:28:47","URL issues","### Version

19.7

### Platform

All

### Subsystem

URL

### What steps will reproduce the bug?

It seems after https://github.com/nodejs/node/pull/46410:
```js
const url = new URL('file:///var/log/system.log');
url.href = 'http://0300.168.0xF0';
url.href; // => 'file://192.168.0.240/', should be 'http://0300.168.0xF0'

new URL('', 'about:blank'); // should be an error, now it's not
```

### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior?

_No response_

### What do you see instead?

^

### Additional information

_No response_","closed","zloirock",2213682,"{confirmed-bug,url,whatwg-url}","https://github.com/nodejs/node/issues/46755",7,"Ambos",NULL,3,"version 19.7 platform subsystem url step reproduce bug seem pull const url new url file var log system log url href http 0300 168 0xf0 url href file 192 168 0 240 http 0300 168 0xf0 new url about blank error
","O título ""URL issues"" e o corpo da issue descrevem um bug relacionado a URLs.  Os comentários discutem a conformidade com o padrão WHATWG URL e a implementação em diferentes navegadores (Safari, Node.js),  indicando a necessidade de refatoração do código para corrigir o bug (o comentário menciona 'fix bug'). A menção a testes em 'web platform test' sugere a necessidade de testes de regressão para garantir que a correção não introduza novos problemas. Portanto, a issue envolve tanto refatoração quanto testes de regressão."
239,46731,"2023-02-19 16:25:21","2023-03-01 14:18:07","2023-03-01 14:18:07","`.load` infinite loop in REPL","### Version

v19.6.0

### Platform

Darwin <hostname> 22.3.0 Darwin Kernel Version 22.3.0: Mon Jan 30 20:38:43 PST 2023; root:xnu-8792.81.3~2/RELEASE_ARM64_T8112 arm64

### Subsystem

repl

### What steps will reproduce the bug?

```
$ cat foo.js
function a(b) {
  return b }
a(1)
$ node
Welcome to Node.js v19.6.0.
Type "".help"" for more information.
> .load foo.js
  function a(b) {
  function a(b) {
  function a(b) {
  ...
```

This prints `function a(b) {` forever until killing the process (it doesn't respond to `Ctrl-c`)

### How often does it reproduce? Is there a required condition?

Every time, with the correct file.

### What is the expected behavior?

```
$ cat foo.js
function a(b) {
  return b }
a(1)
$ node
Welcome to Node.js v19.6.0.
Type "".help"" for more information.
> .load foo.js
function a(b) {
  return b }
a(1)

1
>
```

### What do you see instead?

```
  function a(b) {
  function a(b) {
  function a(b) {
  ...
```

### Additional information

I'm struggling to figure out what's happening here. If the file contents don't include a new line after the first `{`, i.e.

```
function a(b) { return b }
a(1)
```

everything works fine. This lead me to believe it was somehow a parsing issue, but there are a number of iterations of the file that either do or do not work that don't seem to line up. The following files _do_ work (separated by lines only containing //):

```
// same as above
function a(b) { return b }
a(1)

// not calling a
function a(b) {
  return b }

// using arrow function
a = b => { return b }

// random example that works fine
a = 1 + 1

console.log(a)
```

The following _do not_ work:

```
// same as above
function a(b) {
  return b }
a(1)

// using arrow function (not calling a)
a = b => {
  return b }

// using arrow function (calling a)
a = b => {
  return b }
a(1)
```

I believe there were a few other weird things that worked and didn't work.

The odd thing is that reverting 6874aa1, lines 1554-1559 (https://github.com/nodejs/node/commit/6874aa1fb15e815bacf0b0f7e18a434d72de0b4d#diff-392b628f0a5eb047b1117351e6eedcefb8ec70a48933479e0e9bdc711a04f047L1554-L1559), seems to fix this. I tried a few other things, such as loading the file into a buffer before writing it out, `toString()`ing it after `Buffer.from()`ing it), changing the encoding, and changing the line endings. None of these worked.

Also, the tests run fine, even when modifying them to include the text that breaks outside of the tests.","closed","harrisi",14868079,"{confirmed-bug,repl}","https://github.com/nodejs/node/issues/46731",6,"Ambos",NULL,10,"problema repl imprimir função infinitamente processo interromper ctrl c arquivo conter linha nova primeira chave arquivo funcionar linha nova funcionar problema parse iteração arquivo funcionar aparentemente linha nova primeiro bloco código problema reverter commit github parece resolver problema tentar varias solução buffer encoding linha fim solução funcionar teste funcionar mesmo modificar incluir texto problema fora teste
","A issue descreve um loop infinito na função `.load` do REPL do Node.js, que parece estar relacionado a um problema de parsing de novas linhas no final do arquivo carregado.  Os comentários fornecem informações sobre testes de regressão (comparando versões diferentes do Node.js, testes com arquivos com e sem novas linhas), bem como a necessidade de refatoração do código que lida com a leitura e escrita de arquivos no REPL, em especial o uso do regex `lineEnding` e como ele está impactando o loop. A análise detalhada de um usuário no comentário descreve exatamente onde está o problema e sugere refatoração do código para resolver o loop infinito, sugerindo que ambos os aspectos, testes e refatoração, são necessários para resolver o problema. "
360,37685,"2021-03-10 01:47:36","2022-10-06 17:51:49","2022-10-06 17:51:49","Error handling for HPE_HEADER_OVERFLOW in HTTP server does not take into account socket re-use","* **Version**: 12.19.0 and above
* **Platform**: Darwin <redacted> 19.6.0 Darwin Kernel Version 19.6.0: Tue Jan 12 22:13:05 PST 2021; root:xnu-6153.141.16~1/RELEASE_X86_64 x86_64

### What steps will reproduce the bug?

Create a HTTP agent with keep-alive set to `true`, max sockets and max free sockets to 1 (for simplicity).  
Send a request to a NodeJS HTTP server, resulting in a successful response.
Send a 2nd request, this time with a payload that will trigger `HPE_HEADER_OVERFLOW` (send a large header value, larger than `max-header-size-limit`).
Observe that the 2nd request has the socket destroyed, instead of receiving a HTTP 431.

The above steps are implemented in this gist: https://gist.github.com/ramesius/6d9fbd79d76ca36e555855275cf158c0 which is able to reproduce between node 12.18.4 and 12.19.0. For later versions it might require the example header to be increased in size.

### How often does it reproduce? Is there a required condition?

Any socket that is re-used will not be able to respond with a HTTP 431.

### What is the expected behavior?

A request that results in `HPE_HEADER_OVERFLOW` regardless of a one-use socket or a re-used socket should be able to return HTTP 431.

### What do you see instead?

Any subsequent request over a re-used socket that triggers `HPE_HEADER_OVERFLOW` results in the socket being destroyed.
This is particularly troublesome when an application is behind any other service that keeps connections alive (for example a load balancer) for performance, the connections are unexpectedly closed which results in the service incorrectly interpreting what would have been a HTTP 431 as HTTP 503.


### Additional information

The expected behavior was present in versions `12.18.4` and below.
Suspected buggy code: https://github.com/nodejs/node/blob/master/lib/_http_server.js#L658
When listening for `clientError` on the server we can also see that `bytesWritten` is > 0

This is the commit that introduced the changes
 - https://github.com/nodejs/node/commit/e52cc24e31","closed","ramesius",4499825,"{confirmed-bug,http}","https://github.com/nodejs/node/issues/37685",2,"Refatoração",NULL,576,"request trigger hpe_header_overflow socket destroy return http 431 re use socket http 431 subsequent request re use socket trigger hpe_header_overflow result socket destroy application service keep connection alive load balancer connection unexpectedly close service incorrectly interpret http 431 http 503 expected behavior version below suspect buggy code commit introduce change
","O título e o corpo da issue descrevem um problema no tratamento de erros ('Error handling') relacionado ao uso de sockets e conexões HTTP.  A menção a um comportamento esperado em versões anteriores ('expected behavior version below') e a suspeita de código com defeito introduzido por um commit ('suspect buggy code commit introduce change') indica a necessidade de refatoração do código para corrigir o erro e melhorar o tratamento de erros. Não há menção direta a testes de regressão, embora eles sejam recomendados após a refatoração."
243,46602,"2023-02-10 08:38:10","2023-02-13 09:48:03","2023-02-13 09:48:04","strict content length does not apply if content length header is set after body","If the content length is set after data has been written to the `OutgoingMessage,` but before headers have been flushed, then the strict content length check is bypassed.","closed","ronag",3065230,"{confirmed-bug,""help wanted"",http}","https://github.com/nodejs/node/issues/46602",4,"Nenhum",NULL,3,"content length set data write OutgoingMessage header flush strict content length check bypass
","A issue descreve um problema com o cabeçalho 'content-length' e sua interação com o envio do corpo da requisição.  Não há menção explícita a refatoração de código ou testes de regressão. O foco é na correção de um comportamento inesperado relacionado a um cabeçalho HTTP. Os comentários também se concentram em clarificar o problema e oferecer soluções, sem mencionar atividades de refatoração ou testes."
244,46453,"2023-01-31 23:44:03","2023-02-23 09:54:35","2023-06-05 13:28:31","Overzealous link header validation in `writeEarlyHints`","### Version

v19.5.0

### Platform

Darwin Kernel Version 22.2.0: Fri Nov 11 02:03:51 PST 2022; root:xnu-8792.61.2~4/RELEASE_ARM64_T6000 arm64

### Subsystem

http

### What steps will reproduce the bug?

```js
import { createServer } from ""node:http"";

const server = createServer((req, res) => {
  res.writeEarlyHints({
    link: ""<https://fonts.gstatic.com/>; rel=preconnect; crossorigin"",
  });
  res.end();
});

server.listen(3000);
```

### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior?

_No response_

### What do you see instead?

```console
node:internal/validators:473
    throw new ERR_INVALID_ARG_VALUE(
    ^

TypeError [ERR_INVALID_ARG_VALUE]: The argument 'hints' must be an array or string of format ""</styles.css>; rel=preload; as=style"". Received '<https://fonts.gstatic.com/>; rel=preconnect; crossorigin'
    at new NodeError (node:internal/errors:399:5)
    at validateLinkHeaderFormat (node:internal/validators:473:11)
    at validateLinkHeaderValue (node:internal/validators:493:5)
    at ServerResponse.writeEarlyHints (node:_http_server:310:16)
    at Server.<anonymous> (file:///Users/hargo/Code/wyyerd/i7n/test.mjs:4:7)
    at Server.emit (node:events:512:28)
    at parserOnIncoming (node:_http_server:1067:12)
    at HTTPParser.parserOnHeadersComplete (node:_http_common:119:17) {
  code: 'ERR_INVALID_ARG_VALUE'
}

Node.js v19.5.0
```

### Additional information

This appears to be an overzelous validation that requires all link parameters to be followed by an `=`.

Per the ABNF in RFC8288 https://www.rfc-editor.org/rfc/rfc8288.html#section-3 the `=` is optional along with the parameter value.

Additionally it seems that the validation restricts parameters to a preset list of those headers currently defined by the HTML spec. This seems in conflict with RFC8288 which doesn't appear to place any restrictions on parameters, which seems more relevant that the parameters that happen to be specified in the current HTML specification.","closed","khalsah",4380,"{confirmed-bug,http,""good first issue""}","https://github.com/nodejs/node/issues/46453",5,"Refatoração",NULL,22,"version v19 error invalid argument value link header parameter equal sign optional rfc rfc html specification
","O título da issue ""Overzealous link header validation in `writeEarlyHints`"" sugere uma melhoria na validação do cabeçalho link, sem mencionar explicitamente a adição ou execução de testes. O corpo da issue descreve um problema com a validação atual, indicando a necessidade de refatoração para torná-la menos rigorosa. Os comentários discutem soluções e a implementação da correção, mas não mencionam testes de regressão explicitamente. A ênfase está na correção de um comportamento existente, o que caracteriza refatoração."
245,46347,"2023-01-25 11:30:30","2024-05-12 17:24:44","2024-09-25 05:06:26","`Readable.toWeb` seems to load file contents to memory","### Version

v19.5.0

### Platform

Darwin dzieni 21.6.0 Darwin Kernel Version 21.6.0: Wed Aug 10 14:28:35 PDT 2022; root:xnu-8020.141.5~2/RELEASE_ARM64_T8101 arm64

### Subsystem

stream

### What steps will reproduce the bug?

- run REPL
- create a file stream: `const nodeStream = fs.createReadStream('/some/large/file')`
- check `process.memoryUsage()`
- convert it to a web stream: `const webStream = (require('stream').Readable).toWeb(nodeStream)`
- check `process.memoryUsage()`

### How often does it reproduce? Is there a required condition?

At all times

### What is the expected behavior?

Memory usage does not grow significantly.

### What do you see instead?

Memory usage (precisely `arrayBuffers` section) grows by a few orders of magnitude. It seems to be correlated with the file size.

### Additional information

_No response_","closed","Dzieni",5893812,"{confirmed-bug,stream}","https://github.com/nodejs/node/issues/46347",22,"Ambos",NULL,473,"versão plataforma subsystem fluxo reproduzir erro executar repl criar fluxo arquivo verificar conversão fluxo web verificar comportamento esperado uso memória crescer significativamente ver uso memória arraybuffers crescer ordem magnitude correlacionar tamanho arquivo informação adicional
","O título da issue sugere um problema de performance relacionado ao uso de memória (`Readable.toWeb` seems to load file contents to memory).  O corpo e os comentários discutem a utilização de memória,  fluxo de dados,  *backpressure*,  e a necessidade de refatoração para corrigir um vazamento de memória (memory leak).  Além disso, há menções a testes, estratégias de teste e a sugestão de um 'good first issue' que envolve testes e documentação. A combinação de problemas de performance/memória (refatoração) e a necessidade de testes para validar a solução apontam para a classificação 'Ambos'."
246,46223,"2023-01-15 21:19:24","2023-01-22 10:39:18","2023-01-22 10:39:18","worker_threads emergency aborted (std::invalid_argument exception from std::stoull)","### Version

node-v19.3.0

### Platform

5.15.78-2.el7.3.x86_64 (RED OS release MUROM 7.3.2 - Centos based system)

### Subsystem

Worker threads

### What steps will reproduce the bug?

thread_minimize.js:
```js
const { Worker } = require('worker_threads');
const path = require('path');
new Worker(path.join(__dirname), {
// new Worker(path.join(__dirname, 'test.js'), {
execArgv: [ '--cpu-prof-interval', process.TEST ] });
```

### How often does it reproduce? Is there a required condition?

Standart build compiled with: ```gcc (version 8.3.1 2019112) ```
Configure params: ```--prefix=""/target/dir""```
Builded binary info: ```node: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=1bf428404ef62dd8b5c3f952c02e1d1e8da610a9, for GNU/Linux 3.2.0```

### What is the expected behavior?

_No response_

### What do you see instead?

Reproduce an error with the following options: ```ASAN_OPTIONS=verbosity=1:detect_leaks=1:symbolize=1 LD_PRELOAD=/usr/lib64/libasan.so.5.0.0 /home/user/target/node-v19.0.1/node-v19.0.1/builded/bin/node ./thread_minimize.js```

Asan log:
```bash
MemToShadow(shadow): 0x00008fff7000 0x000091ff6dff 0x004091ff6e00 0x02008fff6fff
redzone=16
max_redzone=2048
quarantine_size_mb=256M
thread_local_quarantine_size_kb=1024K
malloc_context_size=30
SHADOW_SCALE: 3
SHADOW_GRANULARITY: 8
SHADOW_OFFSET: 0x7fff8000
==1664269==Installed the sigaction for signal 11
==1664269==Installed the sigaction for signal 7
==1664269==Installed the sigaction for signal 8
==1664269==T0: stack [0x7fff1476b000,0x7fff14f6b000) size 0x800000; local=0x7fff14f68584
==1664269==AddressSanitizer Init done
==1664269==T1: stack [0x7faa62000000,0x7faa627fef00) size 0x7fef00; local=0x7faa627fee04
==1664269==T2: stack [0x7faa617ff000,0x7faa61ffdf00) size 0x7fef00; local=0x7faa61ffde04
==1664269==T3: stack [0x7faa60ffe000,0x7faa617fcf00) size 0x7fef00; local=0x7faa617fce04
==1664269==T4: stack [0x7faa607fd000,0x7faa60ffbf00) size 0x7fef00; local=0x7faa60ffbe04
==1664269==T5: stack [0x7faa5fffc000,0x7faa607faf00) size 0x7fef00; local=0x7faa607fae04
==1664269==T6: stack [0x7faa63026000,0x7faa6302cf00) size 0x6f00; local=0x7faa6302ce04
terminate called after throwing an instance of 'std::invalid_argument'
  what():  stoull
Aborted
```

### Additional information

_No response_","closed","sigdevel",60114847,"{confirmed-bug,c++}","https://github.com/nodejs/node/issues/46223",4,"Refatoração",NULL,7,"worker thread reproduce error use asan detect memory leak standar build gcc version configure param build binary info node elf bit lsb executable x bit version dynamically link interpreter lib ld linux x so buildid sha for gnu linux terminate call throw instance std invalid argument what stoull abort
","A issue descreve um erro em um worker thread ('worker_threads emergency aborted') relacionado a conversão de string para inteiro ('std::invalid_argument exception from std::stoull'). Os comentários sugerem uma solução envolvendo a substituição de `stoull` por `strtoull` e o tratamento de entradas inválidas.  Isso indica uma correção de código existente sem a adição de novos testes,  caracterizando uma refatoração para melhorar a robustez do código."
247,46141,"2023-01-09 14:27:18","2023-01-20 12:37:54","2023-01-20 12:37:54","stream: using an async iterator on a pipeline works on v18 but in v19 needs Readable.from(asyncItFn)","### Version

19.3

### Platform

darwin

### Subsystem

_No response_

### What steps will reproduce the bug?

The code below works on `v18.13.0` but crashes on `v19.3.0`
```mjs
import { pipeline } from 'node:stream/promises'
async function* myCustomReadable() {
    yield Buffer.from(`tick: ${new Date().toISOString()}`)
}

async function* myCustomWritable(stream) {
  for await (const chunk of stream) {
    console.log(chunk.toString())
  }
}

await pipeline(
  myCustomReadable,
  myCustomWritable,
)
```
```sh
node:internal/streams/readable:192
  const isDuplex = this instanceof Stream.Duplex;
                        ^

TypeError: Right-hand side of 'instanceof' is not an object
    at PassThrough.Readable (node:internal/streams/readable:192:25)
    at PassThrough.Duplex (node:internal/streams/duplex:58:12)
    at PassThrough.Transform (node:internal/streams/transform:106:10)
    at new PassThrough (node:internal/streams/passthrough:42:13)
    at pipelineImpl (node:internal/streams/pipeline:280:20)
    at node:stream/promises:28:5
    at new Promise (<anonymous>)
    at pipeline (node:stream/promises:17:10)
    at file:///Users/erickwendel/Downloads/projetos/cursos/mastering-streams/mastering-streams-code/example.mjs:12:7
    at ModuleJob.run (node:internal/modules/esm/module_job:194:25)

Node.js v19.3.0
```
but it works if explicitly convert it to a Readable

```mjs
await pipeline(
  Readable.from(myCustomReadable()),
  myCustomWritable,
)
```

### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior?

_No response_

### What do you see instead?

```sh
TypeError: Right-hand side of 'instanceof' is not an object
```

### Additional information

@nodejs/streams @nodejs/tooling ","closed","ErickWendel",8060102,"{confirmed-bug,stream}","https://github.com/nodejs/node/issues/46141",6,"Refatoração",NULL,11,"versão 19.3 plataforma darwin subsistema sem resposta código funcionar v18.13.0 crash v19.3.0 tipoerro lado direito instanceof objeto node v19.3.0 funcionar explicitamente converter readable informação adicional nodejs streams nodejs tooling
","O título da issue indica um problema de compatibilidade entre versões do Node.js (v18 e v19) relacionado ao uso de iteradores assíncronos em pipelines de streams.  O corpo da issue menciona a necessidade de converter explicitamente para `Readable` na versão 19, sugerindo uma mudança na forma como o código lida com streams. Os comentários sugerem soluções como adicionar imports e alterações em como os streams são importados e utilizados.  Essas modificações apontam para a necessidade de refatoração do código para funcionar corretamente na versão mais recente do Node.js, sem necessariamente envolver a adição ou alteração de testes."
363,37299,"2021-02-09 21:14:25","2021-02-12 16:45:43","2021-02-12 16:45:43","ModuleWrap::SyntheticModuleEvaluationStepsCallback should return a Promise","Top-level await expects that all module script evaluation returns a Promise.  As such, [ModuleWrap::SyntheticModuleEvaluationStepsCallback](https://github.com/nodejs/node/blob/51249a11c09c7ec23eda17327f650fa59a72cba5/src/module_wrap.cc#L644) should be updated to return a resolved Promise now that V8 has enabled top-level await by default.

Unfortunately I don't have a spec reference that I can point to here because the Stage 1 [Built-in modules proposal](https://github.com/tc39/proposal-built-in-modules) isn't yet updated for top-level await.

For reference, the corresponding change for Blink is https://chromium-review.googlesource.com/c/chromium/src/+/2568823.

I discovered this issue when working on this V8 bugfix: https://chromium-review.googlesource.com/c/v8/v8/+/2673794. My first attempt at a fix failed the Node integration tests because it assumed that the Synthetic Module callback steps return a Promise.  For now, I'm adding a workaround for this in V8 but if Node can make this update then we'd like to eventually remove that workaround.
","closed","dandclark",1688716,"{confirmed-bug,experimental,esm}","https://github.com/nodejs/node/issues/37299",0,"Ambos",NULL,3,"top level await expect module script evaluation return promise modulewrap syntheticsmoduleevaluationcallback update return resolve promise v8 enable top level await default unfortunately spec reference point stage built module proposal yet update top level await reference correspond change blink discover issue work v8 bugfix first attempt fix fail node integration test assume synthetic module callback step return promise add workaround v8 node make update like eventually remove workaround
","O título da issue sugere uma refatoração ('ModuleWrap::SyntheticModuleEvaluationStepsCallback should return a Promise'),  enquanto o corpo menciona a necessidade de atualização para lidar com o 'top level await' e a correção de um bug em testes de integração ('node integration test assume synthetic module callback step return promise'). A combinação de melhoria de código e correção de testes indica que a issue abrange ambos os aspectos."
365,37236,"2021-02-05 08:40:01","2021-03-19 03:42:39","2022-03-17 09:57:25","Crash on node api add-on finalization","* **Version**: v10.23.2, v12.20.1, v14.15.4, v15.8.0 (all latest lts and current version)
* **Platform**: all
* **Subsystem**: node-api

### What steps will reproduce the bug?

Repo to re-produce: https://github.com/legendecas/repro-napi-v8impl-refbase-double-free

```
$ make
v14.15.4
force gc
fish: 'node --expose_gc index.js' terminated by signal SIGSEGV (Address boundary error)
```

### How often does it reproduce? Is there a required condition?

Always.

### What is the expected behavior?

No segment faults.

### What do you see instead?

Segment faults on double free of `v8impl::<anonymous>::RefBase`. The `RefBase`s were deleted once one module's napi_env was going to destroy, and the installed weak `v8impl::Persistent`s of `v8impl::<anonymous>Reference` was not destroyed and these `RefBase` will be deleted again on finalization callbacks.
","closed","legendecas",8500303,"{confirmed-bug,node-api}","https://github.com/nodejs/node/issues/37236",20,"Ambos",NULL,42,"version lts current platform subsystem node api step reproduce bug repo reproduce make force gc node expose gc index js terminate signal sigsegv address boundary error reproduce often require condition always expect behavior segment fault see instead segment fault double free refbase refbase delete module napi env destroy install weak persistent refbase delete finalization callback
","A issue descreve um crash (segmento de falha, double free) em um add-on do Node.js API relacionado a gerenciamento de memória e finalização. Os comentários discutem a reprodução do erro,  a investigação das causas (envolvendo GC, referências fracas e fortes, e o ciclo de vida do `napi`), testes para isolar e corrigir o problema, e a  busca por uma solução que evite a quebra dos testes existentes.  A combinação de refatoração do código para corrigir o problema de memória e a necessidade de testes de regressão para garantir que a correção não introduz novos problemas indica que ambas as categorias são relevantes."
249,45859,"2022-12-14 14:33:11","2023-01-01 18:49:01","2023-01-01 18:49:01","WebCryptoAPI EC key SPKI export does not always use uncompressed point format","Our WebCryptoAPI implementation supports import of compressed point format EC keys in both `raw`, and `spki` forms. That is an optional to implement part of the API.

The specification however requires that when keys are exported they unconditionally use the uncompressed point format. This is currently not the case in Node.js when compressed point `spki` was used to import the CryptoKey.

The following script demonstrates the issue.

<details>
<summary>Script</summary>

```js
import * as assert from 'assert';

const { subtle } = globalThis.crypto;

const keyData = {
  'P-256': {
    uncompressed: Buffer.from([
      48, 89, 48, 19, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 8, 42, 134, 72, 206, 61, 3, 1, 7, 3, 66, 0, 4, 210, 16, 176, 166, 249, 217, 240, 18, 134, 128, 88, 180, 63, 164, 244, 113, 1, 133, 67, 187, 160, 12, 146, 80, 223, 146, 87, 194, 172, 174, 93, 209, 206, 3, 117, 82, 212, 129, 69, 12, 227, 155, 77, 16, 149, 112, 27, 23, 91, 250, 179, 75, 142, 108, 9, 158, 24, 241, 193, 152, 53, 131, 97, 232,
    ]),
    compressed: Buffer.from([
      48, 57, 48, 19, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 8, 42, 134, 72, 206, 61, 3, 1, 7, 3, 34, 0, 2, 210, 16, 176, 166, 249, 217, 240, 18, 134, 128, 88, 180, 63, 164, 244, 113, 1, 133, 67, 187, 160, 12, 146, 80, 223, 146, 87, 194, 172, 174, 93, 209,
    ]),
  },

  'P-384': {
    uncompressed: Buffer.from([
      48, 118, 48, 16, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 5, 43, 129, 4, 0, 34, 3, 98, 0, 4, 33, 156, 20, 214, 102, 23, 179, 110, 198, 216, 133, 107, 56, 91, 115, 167, 77, 52, 79, 216, 174, 117, 239, 4, 100, 53, 221, 165, 78, 59, 68, 189, 95, 189, 235, 209, 208, 141, 214, 158, 45, 125, 193, 220, 33, 140, 180, 53, 189, 40, 19, 140, 199, 120, 51, 122, 132, 47, 107, 214, 27, 36, 14, 116, 36, 159, 36, 102, 124, 42, 88, 16, 167, 107, 252, 40, 224, 51, 95, 136, 166, 80, 29, 236, 1, 151, 109, 168, 90, 251, 0, 134, 156, 182, 172, 232,
    ]),
    compressed: Buffer.from([
      48, 70, 48, 16, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 5, 43, 129, 4, 0, 34, 3, 50, 0, 2, 33, 156, 20, 214, 102, 23, 179, 110, 198, 216, 133, 107, 56, 91, 115, 167, 77, 52, 79, 216, 174, 117, 239, 4, 100, 53, 221, 165, 78, 59, 68, 189, 95, 189, 235, 209, 208, 141, 214, 158, 45, 125, 193, 220, 33, 140, 180, 53,
    ]),
  },
  'P-521': {
    uncompressed: Buffer.from([
      48, 129, 155, 48, 16, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 5, 43, 129, 4, 0, 35, 3, 129, 134, 0, 4, 1, 86, 244, 121, 248, 223, 30, 32, 167, 255, 192, 76, 228, 32, 195, 225, 84, 174, 37, 25, 150, 190, 228, 47, 3, 75, 132, 212, 27, 116, 63, 52, 228, 95, 49, 27, 129, 58, 156, 222, 200, 205, 165, 155, 187, 189, 49, 212, 96, 179, 41, 37, 33, 231, 193, 183, 34, 229, 102, 124, 3, 219, 47, 174, 117, 63, 1, 80, 23, 54, 207, 226, 71, 57, 67, 32, 216, 228, 175, 194, 253, 57, 181, 169, 51, 16, 97, 184, 30, 34, 65, 40, 43, 158, 23, 137, 24, 34, 181, 183, 158, 5, 47, 69, 151, 181, 150, 67, 253, 57, 55, 156, 81, 189, 81, 37, 196, 244, 139, 195, 240, 37, 206, 60, 211, 105, 83, 40, 108, 203, 56, 251,
    ]),
    compressed: Buffer.from([
      48, 88, 48, 16, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 5, 43, 129, 4, 0, 35, 3, 68, 0, 3, 1, 86, 244, 121, 248, 223, 30, 32, 167, 255, 192, 76, 228, 32, 195, 225, 84, 174, 37, 25, 150, 190, 228, 47, 3, 75, 132, 212, 27, 116, 63, 52, 228, 95, 49, 27, 129, 58, 156, 222, 200, 205, 165, 155, 187, 189, 49, 212, 96, 179, 41, 37, 33, 231, 193, 183, 34, 229, 102, 124, 3, 219, 47, 174, 117, 63,
    ]),
  },
};

const curves = Object.keys(keyData);
const testVectors = [
  {
    name: 'ECDSA',
    privateUsages: ['sign'],
    publicUsages: ['verify'],
  },
  {
    name: 'ECDH',
    privateUsages: ['deriveKey', 'deriveBits'],
    publicUsages: [],
  },
];

async function testRoundTripSpki({ name, publicUsages }, namedCurve) {
  const { compressed, uncompressed } = keyData[namedCurve];

  const key = await subtle.importKey(
    'spki',
    compressed,
    { name, namedCurve },
    true,
    publicUsages
  );

  const spki = await subtle.exportKey('spki', key);
  assert.deepStrictEqual(
    Buffer.from(spki).toString('hex'),
    uncompressed.toString('hex')
  );
}

async function testRoundTripRaw({ name, publicUsages }, namedCurve) {
  let { compressed, uncompressed } = keyData[namedCurve];
  let i = uncompressed.indexOf(Buffer.from([0x00, 0x04])) + 1;
  uncompressed = uncompressed.subarray(i);

  i =
    compressed.indexOf(Buffer.from([0x00, 0x02])) + 1 ||
    compressed.indexOf(Buffer.from([0x00, 0x03])) + 1;

  compressed = compressed.subarray(i);

  const key = await subtle.importKey(
    'raw',
    compressed,
    { name, namedCurve },
    true,
    publicUsages
  );

  const raw = await subtle.exportKey('raw', key);

  assert.strictEqual(
    Buffer.from(raw).toString('hex'),
    uncompressed.toString('hex')
  );
}

for (const namedCurve of curves) {
  for (const vector of testVectors) {
    await testRoundTripSpki(vector, namedCurve).then(
      () =>
        console.log(namedCurve, 'spki'.padEnd(4), vector.name.padEnd(5), '✅'),
      () =>
        console.log(namedCurve, 'spki'.padEnd(4), vector.name.padEnd(5), '❌')
    );
    await testRoundTripRaw(vector, namedCurve).then(
      () =>
        console.log(namedCurve, 'raw'.padEnd(4), vector.name.padEnd(5), '✅'),
      () =>
        console.log(namedCurve, 'raw'.padEnd(4), vector.name.padEnd(5), '❌')
    );
    console.log('\n');
  }
}
```

```
P-256 spki ECDSA ❌
P-256 raw  ECDSA ✅


P-256 spki ECDH  ❌
P-256 raw  ECDH  ✅


P-384 spki ECDSA ❌
P-384 raw  ECDSA ✅


P-384 spki ECDH  ❌
P-384 raw  ECDH  ✅


P-521 spki ECDSA ❌
P-521 raw  ECDSA ✅


P-521 spki ECDH  ❌
P-521 raw  ECDH  ✅
```

</details>

I'm opening this issue so that I have an issue tracker link to add to the WPT status file once it gets updated.","closed","panva",241506,"{confirmed-bug,crypto,webcrypto}","https://github.com/nodejs/node/issues/45859",9,"Ambos",NULL,18,"webcryptoapi implement support import compress point format ec key raw spki form optional implement part api specification require key export unconditionally use uncompress point format currently case node compress point spki use import cryptokey following script demonstrate issue script import assert const subtle globalthis crypto keydata p uncompress buffer from p compress buffer from p uncompress buffer from p compress buffer from p uncompress buffer from p compress buffer from curve keydata testvector name ecdsa privateusage sign publicusage name ecdh privateusage derivekey derivebits publicusage async function testroundtripspki name publicusage namedcurve compress uncompress keydata namedcurve key await subtle importkey spki compress name namedcurve true publicusage spki await subtle exportkey spki key assert deepstrictequal buffer from spki tostring hex uncompress tostring hex async function testroundtripraw name publicusage namedcurve compress uncompress keydata namedcurve uncompress uncompress indexof buffer from add uncompress subarray i compress compress indexof buffer from add compress indexof buffer from add compress subarray i key await subtle importkey raw compress name namedcurve true publicusage raw await subtle exportkey raw key assert strictequal buffer from raw tostring hex uncompress tostring hex namedcurve vector await testroundtripspki vector namedcurve console log namedcurve spki vector name console log namedcurve spki vector name await testroundtripraw vector namedcurve console log namedcurve raw vector name console log namedcurve raw vector name console log namedcurve spki ecdsa p raw ecdsa p spki ecdh p raw ecdh p spki ecdsa p raw ecdsa p spki ecdh p raw ecdh p spki ecdsa p raw ecdsa p spki ecdh p raw ecdh p open issue issue tracker link add wpt status file update
","A issue descreve um problema na exportação de chaves EC SPKI no WebCryptoAPI, onde a chave não está sempre usando o formato de ponto descompactado.  O corpo da issue menciona testes com scripts para demonstrar o problema (Testes de Regressão), e as soluções propostas envolvem refatoração do código interno para lidar com o KeyObjectData e o wrapper de compressão/descompressão (Refatoração).  Os comentários também discutem abordagens para resolver o problema, incluindo modificações no código. Portanto, a issue envolve tanto refatoração quanto testes de regressão."
251,45485,"2022-11-16 17:24:23","2022-11-19 14:55:29","2022-11-19 14:55:29","Crypto: X509Certificate.checkPrivateKey() used with a non-matching key makes the next call to createPrivateKey() fail.","### Version

18.12.1

### Platform

Microsoft Windows NT 10.0.19044.0 x64

### Subsystem

crypto

### What steps will reproduce the bug?

Run the following script using node
I have tested with node 16, 17 and 18 with the same behaviour.

The script contain a certificate and a private key that does NOT match.
I'm using `X509Certificate.checkPrivateKey()` to verify the combination.

The validation returns false (as expected).
Then the next line creates a new private key again using `createPrivateKey`

This should work as the key itself is OK (and it is the same indata that was used the first time `createPrivateKey` was used)

Instead an exception is thrown.

```js
const { X509Certificate, createPrivateKey } = require('node:crypto');

const certificate = `-----BEGIN CERTIFICATE-----
MIICGjCCAb+gAwIBAgIQPBumDEVNCS1HVGGqmK2K5TAKBggqhkjOPQQDAjAfMR0w
GwYDVQQDExRTdGVwIENBIGludGVybWVkaWF0ZTAeFw0yMjExMTYxMjA3MDhaFw0y
MzExMTYxODA4MDhaMBgxFjAUBgNVBAMTDW15LmRvbWFpbi5leHQwWTATBgcqhkjO
PQIBBggqhkjOPQMBBwNCAAQx3ReMlvFMR6CvXth5cgdyvH5K1PVBLL6077wgn3KH
oZngq2Qdegx/uOiKv6zU2NWUyGQzq5aBZQAhgKYT3eaio4HjMIHgMA4GA1UdDwEB
/wQEAwIHgDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwHQYDVR0OBBYE
FLg8zUDxW06swsdeZ/WNpK7bWMysMB8GA1UdIwQYMBaAFE0eDYW1uSFCr8tbOgbr
UpCwapXYMBgGA1UdEQQRMA+CDW15LmRvbWFpbi5leHQwVQYMKwYBBAGCpGTGKEAB
BEUwQwIBAQQRc3VwcG9ydEBwYW5lZGEuc2UEKzRZOUpvR1RfWWNiVlhfR09UX2Fk
Nmk1cGZ6S2hpVDdVckE4ZU05TFZuVXMwCgYIKoZIzj0EAwIDSQAwRgIhAO3U+GsY
fKbRZKIWypOaWcOjREg9xD3KnsTwS5TGfMprAiEArEZowGfEzr2v6VjWJTh1+UUi
M54YrQa7Vdvp0DblvCo=
-----END CERTIFICATE-----`;

const key = `-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIKeq1Bx1/6rRuHbNze/UQV1JchO5QasI17Abf+Tb8QqeoAoGCCqGSM49
AwEHoUQDQgAEsCYBL0B7tjzdx0unix2qKy+Mv3/RCmelFY91pR3EGdQGDmBYpAGN
p9WxWgJIIkdLlEVju/kD1Q55+dYWOlR/Wg==
-----END EC PRIVATE KEY-----`;

const cryptoCrt = new X509Certificate(certificate);
const cryptoKey = createPrivateKey(key);

const isMatching = cryptoCrt.checkPrivateKey(cryptoKey);
console.log(isMatching);

createPrivateKey(key);
console.log('done');

```

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior?

Console output should be:

```
false
done
```


### What do you see instead?

console output is:

```
false
node:internal/crypto/keys:620
    handle.init(kKeyTypePrivate, data, format, type, passphrase);
           ^

Error: error:05800074:x509 certificate routines::key values mismatch
    at createPrivateKey (node:internal/crypto/keys:620:12)
    at Object.<anonymous> (C:\work\gitwork\monorepo\applications\orchestration_service\src\orchestrationHandlers\cryptotest.js:30:1)
    at Module._compile (node:internal/modules/cjs/loader:1159:14)
    at Module._extensions..js (node:internal/modules/cjs/loader:1213:10)
    at Module.load (node:internal/modules/cjs/loader:1037:32)
    at Module._load (node:internal/modules/cjs/loader:878:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)
    at node:internal/main/run_main_module:23:47 {
  library: 'x509 certificate routines',
  reason: 'key values mismatch',
  code: 'ERR_OSSL_X509_KEY_VALUES_MISMATCH'
}

Node.js v18.12.1
```

### Additional information

It looks to me, that the exception thrown on the second createPrivateKey is the actual error that occured in the `checkPrivateKey` function, causing it to return false.
In fact receiving that info instead as a plain `false` would have been nice.

But now it looks like the error is ""queued"" and then thrown when using `createPrivateKey` again.
","closed","tkarls",5672845,"{confirmed-bug,crypto}","https://github.com/nodejs/node/issues/45485",5,"Ambos",NULL,3,"version platform microsoft windows nt subsystem crypto step reproduce bug run script use node test node behaviour script contain certificate private key match use x certificate check private key validation return false expect next line create new private key use create private key work key ok same indata use create private key exception throw often reproduce require condition always expect behaviour console output false done see instead console output false node internal crypto key handle init k key type private data format type passphrase error error ossl x certificate key value mismatch create private key node internal crypto key module compile node internal module cjs loader module extension node internal module cjs loader module load node internal module cjs loader function execute user entry point node internal module run main node internal main run main module library x certificate routine reason key value mismatch code err ossl x certificate key value mismatch node version additional information look exception throw second create private key actual error occur check private key function cause return false fact receive info instead plain false nice look error queue throw use create private key
","O título da issue indica um problema na verificação de chaves privadas em certificados X509, sugerindo a necessidade de refatoração do código para corrigir a falha na validação. Os comentários incluem menções a testes de reprodução ('test reproduce linux node version') e a uma solução que envolve corrigir uma falha na biblioteca crypto e limpar a fila de erros do OpenSSL, indicando que testes de regressão são necessários para garantir que a correção não introduza novos problemas.  A combinação da necessidade de correção de código e testes subsequentes justifica a classificação 'Ambos'."
252,45449,"2022-11-13 15:42:39","2023-09-19 16:12:20","2023-09-19 16:12:20","Import of data url leads to crash","### Version

v19.0.1

### Platform

Linux instance-1 5.19.0-0.deb11.2-cloud-arm64 #1 SMP Debian 5.19.11-1~bpo11+1 (2022-10-03) aarch64 GNU/Linux

### Subsystem

_No response_

### What steps will reproduce the bug?

```
> m=()=>import(`data:text/javascript,`)
[Function: m]
> await m()
Segmentation fault (core dumped)
```

### How often does it reproduce? Is there a required condition?

Sometimes happens on the first call, sometimes takes a few repeated calls of the statement above.

### What is the expected behavior?

_No response_

### What do you see instead?

Crashes here:

```
Thread 1 ""node"" received signal SIGSEGV, Segmentation fault.
0x0000000000b6da2c in node::loader::ImportModuleDynamically(v8::Local<v8::Context>, v8::Local<v8::Data>, v8::Local<v8::Value>, v8::Local<v8::String>, v8::Local<v8::FixedArray>) ()
(gdb) where
```

Specifically on this line where the value is not found in the map:

https://github.com/nodejs/node/blob/6ac3a22f89ae43402d41166baf44266e60595fcb/src/module_wrap.cc#L594

### Additional information

_No response_","closed","jleedev",23022,"{confirmed-bug,module,repl}","https://github.com/nodejs/node/issues/45449",7,"Nenhum",NULL,310,"node segfault crash import module dynamically map value found line
","A issue descreve um crash ('segfault') ao importar um módulo dinamicamente.  Não há menção a refatoração de código ou a execução de testes de regressão. Os comentários focam na reprodução do erro, depuração e solução, sem indicar atividades de refatoração ou testes."
86,56263,"2024-12-15 17:52:06","2024-12-19 17:20:49","2025-01-20 22:45:45","[EventEmitter] TypeError when calling .listeners() without arguments","### Version

22.12.0

### Platform

```text
Darwin X.local 24.1.0 Darwin Kernel Version 24.1.0: Thu Oct 10 21:02:45 PDT 2024; root:xnu-11215.41.3~2/RELEASE_ARM64_T8112 arm64
```


### Subsystem

_No response_

### What steps will reproduce the bug?

```
const EventEmitter = require('node:events');

const myEmitter = new EventEmitter();

try {
    myEmitter.listeners()
} catch (error) {
    console.error(""Error: "", error.message);
    //Error: TypeError: Cannot read properties of undefined (reading 'length')
}
```

### How often does it reproduce? Is there a required condition?

The issue reproduces 100% of the time when .listeners() is called without any arguments. There are no special conditions required - it happens consistently on any EventEmitter instance.

This issue could have a widespread impact. Many applications and libraries that extend or use a custom EventEmitter might be affected when they upgrade to the latest Node.js version.

### What is the expected behavior? Why is that the expected behavior?

The expected behaviour is to return an empty array.

### What do you see instead?

```
Error: TypeError: Cannot read properties of undefined (reading 'length')
    at arrayClone (node:events:894:15)
    at unwrapListeners (node:events:905:15)
    at _listeners (node:events:803:5)
    at EventEmitter.listeners (node:events:813:10)
    at Object.<anonymous> (/Users/ori.granot/Git/events-node-22/main.js:6:15)
    at Module._compile (node:internal/modules/cjs/loader:1562:14)
    at Object..js (node:internal/modules/cjs/loader:1708:10)
    at Module.load (node:internal/modules/cjs/loader:1318:32)
    at Function._load (node:internal/modules/cjs/loader:1128:12)
    at TracingChannel.traceSync (node:diagnostics_channel:322:14)```
```

### Additional information

It looks like it was changed in the latest release:
https://github.com/nodejs/node/commit/bdb6d12e7a#diff-330bdd22a188135540523f69deb4f9563e03b00a913cd369e1ee84d899f178a9L785

I created a PR to fix the issue: https://github.com/nodejs/node/pull/56264","closed","origranot",48911144,"{confirmed-bug,events}","https://github.com/nodejs/node/issues/56263",5,"Ambos",NULL,4,"erro tipo TypeError propriedade indefinida leitura length chamar listeners argumento especial condição impacto amplo aplicação biblioteca estender usar custom EventEmitter afetar atualizar versão Node.js esperado retorno array vazio ver mensagem erro pilha rastreio arrayClone unwrapListeners listeners EventEmitter main js modulo compile js modulo load TracingChannel traceSync mudança ultima versão PR corrigir issue
","O título da issue menciona um erro de tipo ('TypeError'), indicando um problema de funcionamento.  O corpo da issue descreve um problema com o método `.listeners()` do EventEmitter,  sugerindo a necessidade de refatoração para corrigir o erro.  Os comentários mencionam 'regression' (regressão), indicando que o erro afeta funcionalidades existentes, requerendo testes de regressão para garantir que a correção não introduza novos problemas.  A combinação de correção de erro e impacto em funcionalidades existentes justifica a classificação 'Ambos'."
255,45171,"2022-10-25 15:22:09","2022-11-24 10:41:03","2022-12-29 12:30:18","Error Date.toLocaleString() in node 19.0.0","### Version

19.0.0

### Platform

Linux 6.0.2-zen1-1-zen #1 ZEN SMP PREEMPT_DYNAMIC Sat, 15 Oct 2022 14:00:51 +0000 x86_64 GNU/Linux

### Subsystem

_No response_

### What steps will reproduce the bug?

```
node

> new Date(new Date().toLocaleString('en-US'))
Invalid Date
> const s = new Date().toLocaleString('en-US')
undefined
> s.at(-3)
' '
> s.at(-3).charCodeAt()
8239
> ' '.charCodeAt()
32
> 
```

### How often does it reproduce? Is there a required condition?

Stability

### What is the expected behavior?

_No response_

### What do you see instead?

Error Date.toLocaleString():  NARROW NO-BREAK SPACE (U+202f) without last whitespace

### Additional information

Thanks for node) It`s cool)","closed","dmitriym09",17482915,"{confirmed-bug,""v8 engine"",i18n-api}","https://github.com/nodejs/node/issues/45171",14,"Ambos",NULL,30,"version 19.0 platform linux subsystem response step reproduce bug node date tolocalestring invalid date constant date tolocalestring undefined at charactercode charactercode space often reproduce required condition stability expected behavior response instead error date tolocalestring narrow no break space whitespace additional information thanks node cool
","A issue relata um erro na função `toLocaleString()` do Node.js, que afeta a conversão de datas.  Os comentários discutem a possibilidade de ser um bug no V8 (motor JavaScript do Chrome) ou uma mudança na biblioteca ICU (International Components for Unicode) usada pelo Node.js.  A natureza do problema sugere tanto a necessidade de refatoração do código afetado (para lidar com a mudança ou bug) quanto a execução de testes de regressão para garantir que a funcionalidade esteja correta em diferentes versões do Node.js e cenários de uso.  A menção de versões específicas do Node.js (19.0, 19.1) e a discussão sobre as possíveis causas e soluções reforçam a necessidade de ambas as ações (refatoração e testes de regressão)."
256,45052,"2022-10-18 09:52:43","2023-04-29 11:09:09","2023-04-29 11:09:09","crash when trace ic stats","### Version

v19.0.0-pre

### Platform

20.3.0 Darwin Kernel Version 20.3.0

### Subsystem

trace_events

### What steps will reproduce the bug?

```

const trace_events = require('node:trace_events');
// it works if comment out this line
require('v8');

const tracing = trace_events.createTracing({ categories: ['disabled-by-default-v8.ic_stats'] });

tracing.enable();

function access(obj) {
    obj.a;
}
for (let i = 0; i < 100; i++) {
    access({a: i});
    access({a: String(i)});
}

function f(upperLimit) {
    let sum = 0;
    for (let i = 0; i < upperLimit; i++) {
      sum += i;
    }
    if (sum < 0) throw ""argh"";
}
  
function measure(f) {
    const start = new Date().valueOf();
    for (let i = 0; i < 10000; i++) {
      f(i * 10);
    }
    const end = new Date().valueOf();
    console.log(end - start);
}
  
measure(f);
```
### How often does it reproduce? Is there a required condition?

always.

### What is the expected behavior?

The process exits normally.

### What do you see instead?
```
node was compiled with optimization - stepping may behave oddly; variables may not be available.
* thread #1, stop reason = signal SIGSTOP
  * frame #0: 0x0000000101fb6d82 node`v8::internal::SafepointTable::SafepointTable(v8::internal::Isolate*, unsigned long, v8::internal::Code) [inlined] int std::__1::__cxx_atomic_load<int>(__a=<unavailable>, __order=memory_order_relaxed) at atomic:997:12 [opt]
    frame #1: 0x0000000101fb6d82 node`v8::internal::SafepointTable::SafepointTable(v8::internal::Isolate*, unsigned long, v8::internal::Code) [inlined] std::__1::__atomic_base<int, false>::load(this=<unavailable>, __m=memory_order_relaxed) const volatile at atomic:1603 [opt]
    frame #2: 0x0000000101fb6d82 node`v8::internal::SafepointTable::SafepointTable(v8::internal::Isolate*, unsigned long, v8::internal::Code) [inlined] int std::__1::atomic_load_explicit<int>(__o=<unavailable>, __m=memory_order_relaxed) at atomic:1959 [opt]
    frame #3: 0x0000000101fb6d82 node`v8::internal::SafepointTable::SafepointTable(v8::internal::Isolate*, unsigned long, v8::internal::Code) [inlined] v8::base::Relaxed_Load(ptr=<unavailable>) at atomicops.h:237 [opt]
    frame #4: 0x0000000101fb6d82 node`v8::internal::SafepointTable::SafepointTable(v8::internal::Isolate*, unsigned long, v8::internal::Code) [inlined] v8::internal::Code::is_off_heap_trampoline(this=<unavailable>) const at code-inl.h:1101 [opt]
    frame #5: 0x0000000101fb6d82 node`v8::internal::SafepointTable::SafepointTable(v8::internal::Isolate*, unsigned long, v8::internal::Code) [inlined] v8::internal::Code::InstructionStart(this=<unavailable>, isolate=<unavailable>, pc=<unavailable>) const at code-inl.h:652 [opt]
    frame #6: 0x0000000101fb6d82 node`v8::internal::SafepointTable::SafepointTable(this=0x00007ffeedf6ef88, isolate=0x00007f823654d000, pc=4461753840, code=Code @ 0x00007ffeedf6ef58) at safepoint-table.cc:24 [opt]
    frame #7: 0x000000010202de87 node`v8::internal::TurbofanFrame::FindReturnPCForTrampoline(this=<unavailable>, code=<unavailable>, trampoline_pc=2817) const at frames.cc:2278:18 [opt]
    frame #8: 0x000000010217b920 node`v8::internal::IC::TraceIC(this=<unavailable>, type=<unavailable>, name=<unavailable>, old_state=UNINITIALIZED, new_state=<unavailable>) at ic.cc:165:35 [opt]
    frame #9: 0x000000010217d2f6 node`v8::internal::LoadIC::UpdateCaches(this=0x00007ffeedf6f960, lookup=<unavailable>) at ic.cc:0 [opt]
    frame #10: 0x000000010217cdb0 node`v8::internal::LoadIC::Load(this=0x00007ffeedf6f960, object=<unavailable>, name=<unavailable>, update_feedback=<unavailable>, receiver=<unavailable>) at ic.cc:494:7 [opt]
    frame #11: 0x000000010217d45e node`v8::internal::LoadGlobalIC::Load(this=0x00007ffeedf6f960, name=<unavailable>, update_feedback=<unavailable>) at ic.cc:572:18 [opt]
    frame #12: 0x000000010218563a node`v8::internal::Runtime_LoadGlobalIC_Miss(int, unsigned long*, v8::internal::Isolate*) at ic.cc:2780:3 [opt]
    frame #13: 0x0000000102185487 node`v8::internal::Runtime_LoadGlobalIC_Miss(args_length=<unavailable>, args_object=0x00007ffeedf6faa0, isolate=0x00007f823654d000) at ic.cc:2755 [opt]
    frame #14: 0x0000000102932b79 node`Builtins_CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit + 57
    frame #15: 0x0000000109f0f5f0
    frame #16: 0x0000000109f0ceeb
    frame #17: 0x00000001028b1bdc node`Builtins_InterpreterEntryTrampoline + 220
    frame #18: 0x00000001028b1bdc node`Builtins_InterpreterEntryTrampoline + 220
    frame #19: 0x00000001028b1bdc node`Builtins_InterpreterEntryTrampoline + 220
    frame #20: 0x00000001028b1bdc node`Builtins_InterpreterEntryTrampoline + 220
    frame #21: 0x00000001028b1bdc node`Builtins_InterpreterEntryTrampoline + 220
    frame #22: 0x00000001028b1bdc node`Builtins_InterpreterEntryTrampoline + 220
    frame #23: 0x00000001028b035c node`Builtins_JSEntryTrampoline + 92
    frame #24: 0x00000001028b0083 node`Builtins_JSEntry + 131
    frame #25: 0x0000000102024308 node`v8::internal::(anonymous namespace)::Invoke(v8::internal::Isolate*, v8::internal::(anonymous namespace)::InvokeParams const&) [inlined] v8::internal::GeneratedCode<unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, long, unsigned long**>::Call(this=<unavailable>, args=<unavailable>, args=<unavailable>, args=<unavailable>, args=<unavailable>, args=<unavailable>, args=<unavailable>) at simulator.h:155:12 [opt]
    frame #26: 0x0000000102024306 node`v8::internal::(anonymous namespace)::Invoke(isolate=0x00007f823654d000, params=<unavailable>)::InvokeParams const&) at execution.cc:427 [opt]
    frame #27: 0x0000000102023695 node`v8::internal::Execution::Call(isolate=0x00007f823654d000, callable=<unavailable>, receiver=<unavailable>, argc=4, argv=0x00007f82366292d0) at execution.cc:527:10 [opt]
    frame #28: 0x0000000101ef6cfd node`v8::Function::Call(this=0x00007f823716a048, context=<unavailable>, recv=<unavailable>, argc=<unavailable>, argv=0x00007f82366292d0) at api.cc:5317:7 [opt]
    frame #29: 0x0000000101d42ca2 node`node::builtins::BuiltinLoader::CompileAndCall(v8::Local<v8::Context>, char const*, node::Realm*) [inlined] node::builtins::BuiltinLoader::CompileAndCall(context=(val_ = 0x00007f823719ac80), id=<unavailable>, argc=4, argv=0x00007f82366292d0, optional_env=<unavailable>) at node_builtins.cc:502:14 [opt]
    frame #30: 0x0000000101d42c83 node`node::builtins::BuiltinLoader::CompileAndCall(context=(val_ = 0x00007f823719ac80), id=<unavailable>, realm=0x00007f8236627120) at node_builtins.cc:485 [opt]
    frame #31: 0x0000000101dd81ff node`node::Realm::ExecuteBootstrapper(this=0x00007f8236627120, id=<unavailable>) at node_realm.cc:168:30 [opt]
    frame #32: 0x0000000101d25176 node`node::StartExecution(env=0x00007f823780ec00, cb=<unavailable>)>) at node.cc:0 [opt]
    frame #33: 0x0000000101c9697d node`node::LoadEnvironment(env=0x00007f823780ec00, cb=<unavailable>)>) at environment.cc:437:10 [opt]
    frame #34: 0x0000000101da2752 node`node::NodeMainInstance::Run() [inlined] node::NodeMainInstance::Run(this=<unavailable>, exit_code=<unavailable>, env=0x00007f823780ec00) at node_main_instance.cc:138:5 [opt]
    frame #35: 0x0000000101da2734 node`node::NodeMainInstance::Run(this=<unavailable>) at node_main_instance.cc:132 [opt]
    frame #36: 0x0000000101d27c64 node`node::LoadSnapshotDataAndRun(snapshot_data_ptr=<unavailable>, result=<unavailable>) at node.cc:1169:29 [opt]
    frame #37: 0x0000000101d27ee4 node`node::Start(int, char**) [inlined] node::StartInternal(argc=<unavailable>, argv=0x00007f82364266a0) at node.cc:1215:10 [opt]
    frame #38: 0x0000000101d27cb4 node`node::Start(argc=<unavailable>, argv=<unavailable>) at node.cc:1219 [opt]
    frame #39: 0x00007fff2050d621 libdyld.dylib`start + 1
```
### Additional information

_No response_","closed","theanarkh",21155906,"{confirmed-bug,trace_events}","https://github.com/nodejs/node/issues/45052",5,"Ambos",NULL,193,NULL,"O título e o corpo da issue descrevem um crash no Node.js ao usar o módulo `trace_events` com a categoria `v8.ic_stats`.  A stack trace indica um problema dentro do V8 (motor JavaScript do Node.js). Os comentários confirmam que o problema está relacionado ao V8, sugerindo que a solução envolveria tanto refatoração do código do Node.js que interage com o V8 (para evitar o cenário de erro) quanto testes de regressão no Node.js e/ou no V8 para garantir que a correção não introduza novos problemas.  Portanto, a classificação é 'Ambos' pois envolve tanto aspectos de refatoração quanto de testes de regressão."
257,45048,"2022-10-18 06:34:55","2025-01-21 17:16:18","2025-01-21 17:16:18","Wrong example","This example from the documentation (https://nodejs.org/api/process.html#when-to-use-queuemicrotask-vs-processnexttick)
```js
import { nextTick } from 'node:process';
Promise.resolve().then(() => console.log(2));
queueMicrotask(() => console.log(3));
nextTick(() => console.log(1));
// Output:
// 1
// 2
// 3
```
doesn't work in Windows (node 16.13 and 18.11) and Ubuntu (node 18.11). Actual output is always
```console
2
3
1
```
This looks like a documentation bug, but any explanation for this behavior in the main module would be appreciated.","closed","vyatkin0",28710757,"{confirmed-bug,doc}","https://github.com/nodejs/node/issues/45048",6,"Ambos",NULL,826,NULL,"A issue reporta um problema na documentação de um exemplo de código (Refatoração), que não funciona como esperado em diferentes sistemas operacionais e versões do Node.js.  Os comentários sugerem que o problema se deve a diferenças de comportamento entre módulos CommonJS e ES modules, e que a solução envolve atualizar a documentação para refletir a ordem correta de execução (Refatoração) e possivelmente realizar testes adicionais para garantir que o exemplo funcione corretamente em todas as plataformas (Testes de Regressão). A necessidade de atualizar a documentação e a sugestão de adicionar testes de regressão indicam que ambos os aspectos estão envolvidos na solução da issue."
258,44925,"2022-10-08 16:37:11","2022-10-27 22:50:24","2022-10-27 22:50:24","Duplex.from({ writable, readable }) breaks on backpressure","### Version

v18.10.0

### Platform

Microsoft Windows NT 10.0.19044.0 x64

### Subsystem

_No response_

### What steps will reproduce the bug?

I have created repository with failing test case - https://github.com/pavelhoral/node-duplexify-issue that can be cloned and run:

```js
import { Duplex, PassThrough, Readable, Transform } from 'node:stream';

describe('Duplex.from({ writable, readable })', () => {

  it('flushes stream after filling buffer', async () => {
    // Simple pass-through as a placeholder for more complex setup
    const through = new PassThrough({ objectMode: true });

    // Stream prepared values, pipe through simple duplex and async transformer for backpressure
    const stream = Readable.from(['foo', 'bar'], { objectMode: true })
      .pipe(Duplex.from({
        writable: through,
        readable: through
      }))
      .pipe(new Transform({
        objectMode: true,
        highWaterMark: 1, // Setting 1 to force backpressure after a single item
        transform(chunk, encoding, callback) {
          setTimeout(() => callback(null, chunk), 0);
        }
      }));

    // This never finishes when high water mark is reached
    const result = await stream.toArray();

    expect(result).toEqual(['foo', 'bar']);
  });

});
```


### How often does it reproduce? Is there a required condition?

The issue happens every time in my test case when the internal buffers are full and read must be paused (I guess this condition must happen - https://github.com/nodejs/node/blob/v18.10.0/lib/internal/streams/duplexify.js#L350).

### What is the expected behavior?

Stream should correctly finish processing after read buffers are free again.

### What do you see instead?

Duplex stream never correctly resumes its operation after the read has to pause.

### Additional information

_No response_","closed","pavelhoral",2012726,"{confirmed-bug,stream}","https://github.com/nodejs/node/issues/44925",20,"Ambos",NULL,19,NULL,"A issue descreve um problema com o método `Duplex.from({ writable, readable })` que não retoma a operação corretamente após a pausa de leitura devido à pressão de retorno.  O problema está relacionado tanto à refatoração do código do `Duplex.from` (como sugerido pela investigação profunda nos comentários, buscando entender a incompatibilidade com `setTimeout` e o comportamento com `Duplex` implementado manualmente) quanto a testes de regressão, pois o teste falha sob certas condições (uso de `setTimeout`, `highWaterMark`,  `toArray`, etc.).  A necessidade de adicionar testes para reproduzir o erro, e a investigação em profundidade no funcionamento interno das streams do Node.js, reforçam a natureza dupla da issue, envolvendo tanto a necessidade de ajustes no código quanto a garantia de que esses ajustes não causem novos problemas (regressão)."
262,44332,"2022-08-21 17:39:16","2022-08-21 21:29:43","2022-08-21 21:29:43","process.resourceUsage().maxRSS reports in different units between Linux and macOS","### Version

18.7.0

### Platform

  * `macOS 12.5.1` (Darwin Kernel Version 21.6.0: Wed Aug 10 14:25:27 PDT 2022; root:xnu-8020.141.5~2/RELEASE_X86_64)
  * `Debian GNU/Linux 11 (bullseye)`

### Subsystem

_No response_

### What steps will reproduce the bug?

Simply run the following command on both platform.

```bash
$ node -e ""console.log('rss', process.memoryUsage.rss(), '; max rss', process.resourceUsage().maxRSS)""
```

### How often does it reproduce? Is there a required condition?

Always. No required condition.

### What is the expected behavior?

According to the [`process.resourceUsage()` document][1], `maxRSS` should have ""maximum resident set size used in kilobytes"".

[1]: https://nodejs.org/api/process.html#processresourceusage

### What do you see instead?

On Linux (tag: `18.7.0-slim`):

```bash
$ docker run --rm node:18.7.0-slim node -e ""console.log('rss', process.memoryUsage.rss(), '; max rss', process.resourceUsage().maxRSS)""
rss 40235008 ; max rss 39292
```

On the other hand, macOS host:

```bash
$ node -v
v18.7.0
$ node -e ""console.log('rss', process.memoryUsage.rss(), '; max rss', process.resourceUsage().maxRSS)""
rss 32104448 ; max rss 32108544
```

It looks like on Linux it reports correctly in kilobytes; but on macOS, it seems to be just bytes.

### Additional information

N/A","closed","wtchangdm",1546333,"{confirmed-bug,libuv}","https://github.com/nodejs/node/issues/44332",1,"Ambos",NULL,0,NULL,"A issue relata um bug em `process.resourceUsage().maxRSS` que retorna valores diferentes em Linux e macOS.  O comentário indica que é um bug no libuv relacionado à unidade de medida (bytes vs kilobytes). Isso requer tanto refatoração do código para garantir consistência entre plataformas (refatoração) quanto testes de regressão para verificar se a correção funciona corretamente em ambas as plataformas após a implementação (testes de regressão)."
260,44471,"2022-09-01 06:39:48","2022-09-03 12:36:47","2022-09-03 12:36:47","createPublicKey and createPrivateKey lacks robustness with JWK","### Version

v18.7.0

### Platform

Darwin xxx 21.6.0 Darwin Kernel Version 21.6.0: Wed Aug 10 14:25:27 PDT 2022; root:xnu-8020.141.5~2/RELEASE_X86_64 x86_64

### Subsystem

crypto

### What steps will reproduce the bug?

```js
// called jwk format but non-object (string) as a parameter

require('crypto').createPrivateKey({ key: ""foo"", format: 'jwk' });

// core dump follows

require('crypto').createPublicKey({ key: """", format: 'jwk' });

// core dump follows
```

### How often does it reproduce? Is there a required condition?

always

### What is the expected behavior?

Exception with an appropriate error object should be thrown.
It should be possible to catch the exception.

### What do you see instead?

```console
node[88386]: ../src/crypto/crypto_keys.cc:68:void node::crypto::(anonymous namespace)::GetKeyFormatAndTypeFromJs(node::crypto::AsymmetricKeyEncodingConfig *, const FunctionCallbackInfo<v8::Value> &, unsigned int *, node::crypto::KeyEncodingContext): Assertion `(context == kKeyContextInput && config->format_ == kKeyFormatPEM) || (context == kKeyContextGenerate && config->format_ == kKeyFormatJWK)' failed.
 1: 0x103037252 node::Abort() [/opt/local/bin/node]
 2: 0x103037085 node::AppendExceptionLine(node::Environment*, v8::Local<v8::Value>, v8::Local<v8::Message>, node::ErrorHandlingMode) [/opt/local/bin/node]
 3: 0x103138e07 node::crypto::(anonymous namespace)::GetKeyFormatAndTypeFromJs(node::crypto::AsymmetricKeyEncodingConfig*, v8::FunctionCallbackInfo<v8::Value> const&, unsigned int*, node::crypto::KeyEncodingContext) [/opt/local/bin/node]
 4: 0x103138693 node::crypto::ManagedEVPPKey::GetPrivateKeyEncodingFromJs(v8::FunctionCallbackInfo<v8::Value> const&, unsigned int*, node::crypto::KeyEncodingContext) [/opt/local/bin/node]
 5: 0x103139575 node::crypto::ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(v8::FunctionCallbackInfo<v8::Value> const&, unsigned int*) [/opt/local/bin/node]
 6: 0x10313a3ba node::crypto::KeyObjectHandle::Init(v8::FunctionCallbackInfo<v8::Value> const&) [/opt/local/bin/node]
 7: 0x1031b491b v8::internal::FunctionCallbackArguments::Call(v8::internal::CallHandlerInfo) [/opt/local/bin/node]
 8: 0x1031b44ab v8::internal::MaybeHandle<v8::internal::Object> v8::internal::(anonymous namespace)::HandleApiCallHelper<false>(v8::internal::Isolate*, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::FunctionTemplateInfo>, v8::internal::Handle<v8::internal::Object>, v8::internal::BuiltinArguments) [/opt/local/bin/node]
 9: 0x1031b3c28 v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) [/opt/local/bin/node]
10: 0x1038710f9 Builtins_CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit [/opt/local/bin/node]
```

### Additional information

This has been the case with JWK import for all versions so far.","closed","rinne",1642944,"{confirmed-bug,crypto}","https://github.com/nodejs/node/issues/44471",2,"Refatoração",NULL,2,NULL,"A issue descreve um problema de robustez nas funções `createPublicKey` e `createPrivateKey` ao lidar com o formato JWK.  A solução requer aprimoramentos no tratamento de erros e na validação de entrada, o que caracteriza uma tarefa de refatoração para melhorar a qualidade e a estabilidade do código, sem necessariamente adicionar novos recursos ou testes de regressão imediatos. A menção a um core dump indica um problema interno, que precisa ser resolvido através de ajustes no código. Não há menção explícita à necessidade de novos testes de regressão, embora seja altamente recomendado que sejam adicionados após a refatoração para garantir que a correção não introduza novos problemas."
261,44417,"2022-08-27 08:06:36","2022-11-11 07:20:19","2022-11-11 07:20:19","Array<RegExp>.toString() doesn't work properly on Node.js CLI","### Version

v16.13.1

### Platform

Microsoft Windows NT 10.0.19044.0 x64

### Subsystem

_No response_

### What steps will reproduce the bug?

Hello, I've found interesting bug on Node.js CLI on Windows Console and also on WSL.

These code will work as intended when being run inside a file (`node index.js`) or copy to CLI simultaneously, but won't work if we run it line by line.
```js
const arr = [/asd/,/cvb/];

first=`${arr.toString()}`;
console.log({first});

arr.toString();

second=`${arr.toString()}`;
console.log({second});
```

After running `arr.toString();` without assigning to a variable, the `arr` variable will broke and failed to return correct string.

### Output
**Scenario: `node index.js`**
```js
{ first: '/asd/,/cvb/' }
{ second: '/asd/,/cvb/' }
```

**Scenario: Copy to Node.js CLI simultaneously**
```js
Welcome to Node.js v16.13.1.
Type "".help"" for more information.
> const arr = [/asd/,/cvb/];
undefined
>
> first=`${arr.toString()}`;
'/asd/,/cvb/'
> console.log({first});
{ first: '/asd/,/cvb/' }
undefined
>
> arr.toString();
'/asd/,/cvb/'
>
> second=`${arr.toString()}`;
'/asd/,/cvb/'
> console.log({second});
{ second: '/asd/,/cvb/' }
undefined
>
```

**Bugged Scenario: Run Line by Line on Node.js CLI**
```js
Welcome to Node.js v16.13.1.
Type "".help"" for more information.
> const arr = [/asd/,/cvb/];
undefined
> first=`${arr.toString()}`;
'/asd/,/cvb/'
> console.log({first});
{ first: '/asd/,/cvb/' }
undefined
>
> arr.toString();
''
>
> second=`${arr.toString()}`;
''
> console.log({second});
{ second: '' }
undefined
>
```

### How often does it reproduce? Is there a required condition?

On right condition, it happens all the time.

### What is the expected behavior?

`arr` variable does not change internally and able to return correct string using `.toString()` method.

### What do you see instead?

`arr.toString()` returns blank string and becomes broken.

### Additional information

_No response_","closed","yukha-dw",91457362,"{confirmed-bug,repl,""v8 engine""}","https://github.com/nodejs/node/issues/44417",7,"Nenhum",NULL,76,NULL,"A issue descreve um bug no comportamento do método toString() para arrays de expressões regulares no Node.js CLI quando executado linha a linha.  Não há menção a refatoração de código ou testes de regressão. O problema parece ser um bug no interpretador JavaScript (V8), não necessitando de refatoração ou testes adicionais no próprio Node.js."
267,43894,"2022-07-18 17:08:49","2022-08-04 16:35:24","2022-08-04 16:35:24","Debug build failed to compile on Apple Silicon","Debug build failed to compile on Apple M1 Max (arm64) with https://github.com/nodejs/node/pull/39775. Example error messages:

```
FAILED: obj/deps/base64/base64/lib/arch/neon64/base64_neon64.codec.o
cc -MMD -MF obj/deps/base64/base64/lib/arch/neon64/base64_neon64.codec.o.d -DV8_DEPRECATION_WARNINGS -DV8_IMMINENT_DEPRECATION_WARNINGS -D_GLIBCXX_USE_CXX11_ABI=1 -DNODE_OPENSSL_CONF_NAME=nodejs_conf -DNODE_OPENSSL_HAS_QUIC -D_DARWIN_USE_64_BIT_INODE=1 -DOPENSSL_NO_PINSHARED -DOPENSSL_THREADS -DBASE64_STATIC_DEFINE -DHAVE_NEON64=1 -DDEBUG -D_DEBUG -DV8_ENABLE_CHECKS -I../../deps/base64/base64/include -I../../deps/base64/base64/lib -O0 -gdwarf-2 -mmacosx-version-min=10.15 -arch arm64 -Wall -Wendif-labels -W -Wno-unused-parameter -fno-strict-aliasing  -c ../../deps/base64/base64/lib/arch/neon64/codec.c -o obj/deps/base64/base64/lib/arch/neon64/base64_neon64.codec.o
In file included from ../../deps/base64/base64/lib/arch/neon64/codec.c:62:
../../deps/base64/base64/lib/arch/neon64/enc_loop.c:32:44: error: registers must be sequential
                ""and  %[t3].16b, v14.16b,   %[n63].16b \n\t""
                                                         ^
<inline asm>:10:40: note: instantiated into assembly here
        tbl v12.16b, {v5.16b, v6.16b, v7.16b, v16.16b}, v3.16b
                                              ^
In file included from ../../deps/base64/base64/lib/arch/neon64/codec.c:62:
../../deps/base64/base64/lib/arch/neon64/enc_loop.c:32:44: error: unknown token in expression
                ""and  %[t3].16b, v14.16b,   %[n63].16b \n\t""
                                                         ^
<inline asm>:10:48: note: instantiated into assembly here
        tbl v12.16b, {v5.16b, v6.16b, v7.16b, v16.16b}, v3.16b
                                                      ^
In file included from ../../deps/base64/base64/lib/arch/neon64/codec.c:62:
../../deps/base64/base64/lib/arch/neon64/enc_loop.c:32:44: error: invalid operand
                ""and  %[t3].16b, v14.16b,   %[n63].16b \n\t""
                                                         ^
<inline asm>:10:48: note: instantiated into assembly here
        tbl v12.16b, {v5.16b, v6.16b, v7.16b, v16.16b}, v3.16b
                                                      ^
In file included from ../../deps/base64/base64/lib/arch/neon64/codec.c:62:
../../deps/base64/base64/lib/arch/neon64/enc_loop.c:35:75: error: registers must be sequential
                ""tbl v12.16b, {%[l0].16b, %[l1].16b, %[l2].16b, %[l3].16b}, %[t0].16b \n\t""
                                                                                        ^
<inline asm>:11:40: note: instantiated into assembly here
        tbl v13.16b, {v5.16b, v6.16b, v7.16b, v16.16b}, v2.16b
                                              ^
In file included from ../../deps/base64/base64/lib/arch/neon64/codec.c:62:
../../deps/base64/base64/lib/arch/neon64/enc_loop.c:35:75: error: unknown token in expression
                ""tbl v12.16b, {%[l0].16b, %[l1].16b, %[l2].16b, %[l3].16b}, %[t0].16b \n\t""
                                                                                        ^
<inline asm>:11:48: note: instantiated into assembly here
        tbl v13.16b, {v5.16b, v6.16b, v7.16b, v16.16b}, v2.16b
                                                      ^
In file included from ../../deps/base64/base64/lib/arch/neon64/codec.c:62:
../../deps/base64/base64/lib/arch/neon64/enc_loop.c:35:75: error: invalid operand
                ""tbl v12.16b, {%[l0].16b, %[l1].16b, %[l2].16b, %[l3].16b}, %[t0].16b \n\t""
                                                                                        ^
<inline asm>:11:48: note: instantiated into assembly here
        tbl v13.16b, {v5.16b, v6.16b, v7.16b, v16.16b}, v2.16b
                                                      ^
In file included from ../../deps/base64/base64/lib/arch/neon64/codec.c:62:
../../deps/base64/base64/lib/arch/neon64/enc_loop.c:36:75: error: registers must be sequential
                ""tbl v13.16b, {%[l0].16b, %[l1].16b, %[l2].16b, %[l3].16b}, %[t1].16b \n\t""
                                                                                        ^
<inline asm>:12:40: note: instantiated into assembly here
        tbl v14.16b, {v5.16b, v6.16b, v7.16b, v16.16b}, v1.16b
                                              ^
In file included from ../../deps/base64/base64/lib/arch/neon64/codec.c:62:
../../deps/base64/base64/lib/arch/neon64/enc_loop.c:36:75: error: unknown token in expression
                ""tbl v13.16b, {%[l0].16b, %[l1].16b, %[l2].16b, %[l3].16b}, %[t1].16b \n\t""
                                                                                        ^
<inline asm>:12:48: note: instantiated into assembly here
        tbl v14.16b, {v5.16b, v6.16b, v7.16b, v16.16b}, v1.16b
                                                      ^
In file included from ../../deps/base64/base64/lib/arch/neon64/codec.c:62:
../../deps/base64/base64/lib/arch/neon64/enc_loop.c:36:75: error: invalid operand
                ""tbl v13.16b, {%[l0].16b, %[l1].16b, %[l2].16b, %[l3].16b}, %[t1].16b \n\t""
                                                                                        ^
<inline asm>:12:48: note: instantiated into assembly here
        tbl v14.16b, {v5.16b, v6.16b, v7.16b, v16.16b}, v1.16b
                                                      ^
In file included from ../../deps/base64/base64/lib/arch/neon64/codec.c:62:
../../deps/base64/base64/lib/arch/neon64/enc_loop.c:37:75: error: registers must be sequential
                ""tbl v14.16b, {%[l0].16b, %[l1].16b, %[l2].16b, %[l3].16b}, %[t2].16b \n\t""
                                                                                        ^
<inline asm>:13:40: note: instantiated into assembly here
        tbl v15.16b, {v5.16b, v6.16b, v7.16b, v16.16b}, v0.16b
                                              ^
In file included from ../../deps/base64/base64/lib/arch/neon64/codec.c:62:
../../deps/base64/base64/lib/arch/neon64/enc_loop.c:37:75: error: unknown token in expression
                ""tbl v14.16b, {%[l0].16b, %[l1].16b, %[l2].16b, %[l3].16b}, %[t2].16b \n\t""
                                                                                        ^
<inline asm>:13:48: note: instantiated into assembly here
        tbl v15.16b, {v5.16b, v6.16b, v7.16b, v16.16b}, v0.16b
                                                      ^
In file included from ../../deps/base64/base64/lib/arch/neon64/codec.c:62:
../../deps/base64/base64/lib/arch/neon64/enc_loop.c:37:75: error: invalid operand
                ""tbl v14.16b, {%[l0].16b, %[l1].16b, %[l2].16b, %[l3].16b}, %[t2].16b \n\t""
                                                                                        ^
<inline asm>:13:48: note: instantiated into assembly here
        tbl v15.16b, {v5.16b, v6.16b, v7.16b, v16.16b}, v0.16b
                                                      ^
12 errors generated.
```

A clean build can reproduce the problem locally.

_Originally posted by @legendecas in https://github.com/nodejs/node/issues/39775#issuecomment-1186420256_","closed","legendecas",8500303,"{confirmed-bug,build,macos,arm}","https://github.com/nodejs/node/issues/43894",10,"Ambos",NULL,17,NULL,"A issue relata um erro de compilação em builds de debug no Apple Silicon (arm64). O erro está relacionado a um problema no código assembly da biblioteca base64, especificamente em funções de codificação com NEON64.  Os comentários indicam que o problema ocorre apenas no modo debug (-O0), sugerindo um problema de otimização.  A solução proposta envolve um patch no repositório upstream da biblioteca base64 (refatoração), mas também a necessidade de testes de regressão para garantir que a correção não introduz novos problemas após a implementação do patch.  A confirmação da solução envolve testes adicionais com builds de debug e em diferentes compiladores (testes de regressão). Portanto, a issue envolve tanto refatoração quanto testes de regressão."
110,55060,"2024-09-22 08:29:46","2024-10-22 11:38:10","2024-10-22 11:38:11","The `parentPath` returned by `fsPromises.glob` is incorrect in some cases.","### Version

v22.8.0

### Platform

```text
Darwin xxxMBP.lan 23.5.0 Darwin Kernel Version 23.5.0: Wed May  1 20:12:58 PDT 2024; root:xnu-10063.121.3~5/RELEASE_ARM64_T6000 arm64
```


### Subsystem

_No response_

### What steps will reproduce the bug?

`fsPromises.glob` has inconsistent `parentPath` behavior when passed `withFileTypes` option.

According to the [documentation](https://nodejs.org/api/fs.html#direntparentpath), `dirent.parentPath` should return path to the parent directory, but in some cases it doesn't.




### How often does it reproduce? Is there a required condition?

This occurs when a path is passed that does not contain a wildcard(`*`) in the filename portion.
For example, passing `./path/*/file.txt` will result in different behavior than passing `./path/to/*.txt`.

```ts
import { glob } from ""fs/promises"";
import path from ""path"";

// If the file name is a wildcard: OK
for await (const dirent of glob(""./path/to/*.txt"", { withFileTypes: true })) {
  console.log(dirent.parentPath);
  //=> /Users/me/work/test/path/to

  console.log(path.join(dirent.parentPath, dirent.name));
  //=> /Users/me/work/test/path/to/file.txt ✅
}

// If the file name is not a wildcard: 💣
for await (const dirent of glob(""./path/*/file.txt"", { withFileTypes: true })) {
  console.log(dirent.parentPath);
  //=> /Users/me/work/test/path/to/file.txt

  console.log(path.join(dirent.parentPath, dirent.name));
  //=> /Users/me/work/test/path/to/file.txt/file.txt 💣
}
```


### What is the expected behavior? Why is that the expected behavior?

`parentPath` contains the path to a file, not the path to a directory.

### What do you see instead?

The path to the file, not the path to the directory

### Additional information

As far as I can see, something similar is happening with `fs.globSync`.","closed","ayame113",40050810,"{confirmed-bug,fs}","https://github.com/nodejs/node/issues/55060",3,"Refatoração",NULL,30,"fsPromises glob inconsistente parentPath comportamento withFileTypes opcao documentacao dirent parentPath retornar caminho diretorio caso nao acontece caminho passado nao conter wildcard filename porcao exemplo passar path file txt resultar comportamento diferente passar path to txt arquivo nome wildcard ok arquivo nome nao wildcard path diretorio caminho arquivo caminho arquivo informacao similar acontecer fs globSync
","O título e o corpo da issue indicam um problema na função `fsPromises.glob` que retorna um `parentPath` incorreto em alguns casos.  A descrição foca em inconsistências no comportamento e sugere que a solução envolveria corrigir o código da função para garantir que o `parentPath` seja retornado corretamente em todas as situações.  Não há menção direta a testes de regressão, embora a correção necessite de testes para garantir que o problema foi resolvido. O foco principal é na correção de um comportamento incorreto no código existente, caracterizando uma refatoração."
264,44164,"2022-08-07 10:41:35","2022-08-07 11:39:24","2022-08-07 11:39:52","Node silent crash when using web streams","### Version

18.7.0

### Platform

Darwin MacBook-Pro-4.local 21.6.0 Darwin Kernel Version 21.6.0: Sat Jun 18 17:07:25 PDT 2022; root:xnu-8020.140.41~1/RELEASE_X86_64 x86_64

### Subsystem

_No response_

### What steps will reproduce the bug?

Run the following snippet:
```js
class StringLengthQueuingStrategy {
  /**
   * @type {number}
   */
  highWaterMark;
  /**
   * @param {number} highWaterMark
   */
  constructor(highWaterMark) {
    this.highWaterMark = highWaterMark;
  }

  /**
   * @param {string} str
   */
  size(str) {
    return str.length;
  }
}

function createTransformStream() {
  return new TransformStream(
    {
      transform(chunk, controller) {
        console.info(""transform"");
        for (const char of chunk.slice()) {
          console.info('enqueue char:' + char);
          controller.enqueue(char);
          console.info('after enqueue char:' + char);
        }
      },
      flush(controller) {
        console.info(""flush"");
        controller.terminate();
      },
    },
    new StringLengthQueuingStrategy(1),
    new StringLengthQueuingStrategy(1)
  );
}

async function main() {
  const transformStream = createTransformStream();
  const writer = transformStream.writable.getWriter();
  const reader = transformStream.readable.getReader();

  await writer.write(""1"")
  console.log('Node will crash on the next line')
  await writer.write(""2"")
  console.log('Node was suppose to crash before this log')

  const [toBeVoid, output] = await Promise.all([
    writer.write(""abc""),
    reader.read(),
  ]);

  console.log(1, output);

  await writer.close();

  console.log(2, await reader.read());
}

main().catch((error) => {
  console.error(error);
})
```

Node will silently crash on the line `await writer.write(""2"")`

### How often does it reproduce? Is there a required condition?

Always when running the given snippet

### What is the expected behavior?

_No response_

### What do you see instead?

Node silently crash

### Additional information

_No response_","closed","Bnaya",1304862,"{confirmed-bug,""web streams""}","https://github.com/nodejs/node/issues/44164",5,"Nenhum",NULL,0,NULL,"A issue descreve um crash silencioso do Node.js ao usar web streams.  O código fornecido mostra um problema de concorrência ou gerenciamento de recursos, onde a escrita assíncrona não é adequadamente tratada.  Não há menção a refatoração de código existente ou a testes de regressão.  A solução proposta nos comentários sugere ajustes no código para evitar o crash, mas não implica diretamente em refatoração ou testes adicionais."
265,44124,"2022-08-03 23:21:28","2022-08-07 19:17:16","2022-08-07 19:17:16","Node.js inspector crashes when evaluating member in `<instance_members_initializer>`","### Version

v18.7.0

### Platform

Darwin MacBook-Pro-2.guest.corp.microsoft.com 21.6.0 Darwin Kernel Version 21.6.0: Sat Jun 18 17:07:25 PDT 2022; root:xnu-8020.140.41~1/RELEASE_X86_64 x86_64

### Subsystem

inspector

### What steps will reproduce the bug?

1. Run the following program under the inspector (native inspector or VS Code debugger both work)

```js
function identity(v) {
  return v;
}

debugger;

new class {
  #thisWorks = this.constructor.name;
  #thisFails = identity(this.constructor.name);
}
```

2. After hitting the `debugger;` statement, step in twice
3. Hover over `this.constructor.name` or evaluate it in the console -- to the same effect

### How often does it reproduce? Is there a required condition?

100% reproduction

### What is the expected behavior?

The program should not crash

### What do you see instead?

The program immediately crashes with something like.

```
[1]    93633 trace trap  node --inspect-brk hello.js
```

### Additional information

This does not reproduce on Chrome/Edge, though they are ahead a few minor V8 versions and they make downloading quite difficult, so I cannot confirm that this _isn't_ a bug in V8...

It also does not reproduce if you delete the line `#thisFails = identity(this.constructor.name);`

This was originally reported on https://github.com/microsoft/vscode/issues/155708","closed","connor4312",2230985,"{confirmed-bug,inspector}","https://github.com/nodejs/node/issues/44124",5,"Refatoração",NULL,4,NULL,"A issue descreve um crash no Node.js inspector ao avaliar um membro em um inicializador de membros de instância.  O problema parece ser um bug no próprio Node.js ou em uma dependência (V8), requerendo correção no código-fonte do Node.js.  Não há menção a testes automatizados ou a falhas em testes existentes, focando-se na correção de um comportamento incorreto. Os comentários discutem a reprodução do erro em outros navegadores e a possibilidade de reportar o problema ao repositório do V8, reforçando o foco na correção de código e não em testes."
266,43962,"2022-07-23 17:07:40","2022-07-29 05:47:58","2022-07-29 05:47:58","The behavior for unassigned codepoint of Shift_JIS is incompatible with WHATWG spec","### Version

v18.5.0

### Platform

_No response_

### Subsystem

_No response_

### What steps will reproduce the bug?

```js
const decoder = new TextDecoder('Shift_JIS');
const s = decoder.decode(new Uint8Array([255]));
```

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior?

```js
const decoder = new TextDecoder('Shift_JIS');
const s = decoder.decode(new Uint8Array([255]));
console.log(s) // '�' === '\ufffd'
```

According to [WHATWG spec](https://encoding.spec.whatwg.org/#:~:text=the%0A%20%20associated%20steps%3A-,%22replacement%22,-Push%20U%2BFFFD), any decoder should use `�(U+FFFD)` when an unassigned codepoint is found during decoding.

### What do you see instead?

```js
const decoder = new TextDecoder('Shift_JIS');
const s = decoder.decode(new Uint8Array([255]));
console.log(s) // '\x1A'
```

From my investigation, ICU intentionally uses `\x1A` for unassigned codepoint on Shift_JIS encoding, and Node.js uses it as it is.
[Conversion Data - ICU Documentation](https://unicode-org.github.io/icu/userguide/conversion/data.html#:~:text=conversion%20from%20a%20codepage%20to%20unicode%20occurs%20and%20an%20unassigned%20codepoint%20is%20found)
[Which substitution character is used if a character cannot be converted?](https://documentation.softwareag.com/natural/nat914unx/unicode/uni-faq.htm#:~:text=This%20depends%20on,page%20is%20used.)

### Additional information

ICU provides the utility `ucnv_setSubstChars` to specify substitution characters for any encoding, and Node.js  already has it in library. I'm working on this.","closed","cola119",22386678,"{confirmed-bug,encoding}","https://github.com/nodejs/node/issues/43962",2,"Refatoração",NULL,6,NULL,"A issue descreve um comportamento incompatível com a especificação WHATWG para o tratamento de pontos de código não atribuídos no Shift_JIS.  A solução proposta envolve a modificação do código existente (uso de `ucnv_setSubstChars` ou alteração em `ConverterObject`) para corrigir o comportamento.  Não há menção a novos testes ou a uma suite de testes de regressão, focando-se na alteração do código para atender à especificação correta. A discussão nos comentários também se concentra na implementação da correção no código (`ucnv.cpp`, `ConverterObject`)."
269,43777,"2022-07-11 14:01:46","2022-07-15 19:30:50","2022-07-15 19:30:50","Top-level await incorrectly awaits promise continuation in REPL","### Version

18.5.0

### Platform

Linux 5.13.0-Ubuntu x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

repl

### What steps will reproduce the bug?

In REPL:

```js
const foo = async () => 123;

foo();

await foo();

typeof (await Promise.resolve(foo))();

(await Promise.resolve(foo))();
```

### How often does it reproduce? Is there a required condition?

Always.

### What is the expected behavior?

```js
> const foo = async () => 123;
undefined
> foo();
Promise {
  123,
  [Symbol(async_id_symbol)]: 33,
  [Symbol(trigger_async_id_symbol)]: 5
}
> await foo();
123
> typeof (await Promise.resolve(foo))();
'object'
> (await Promise.resolve(foo))();
Promise {
  123,
  [Symbol(async_id_symbol)]: 108,
  [Symbol(trigger_async_id_symbol)]: 5
}
```

Note that `typeof` prints `'object'`, which is correct and matches `Promise { ... }`.

### What do you see instead?

```js
> const foo = async () => 123;
undefined
> foo();
Promise {
  123,
  [Symbol(async_id_symbol)]: 33,
  [Symbol(trigger_async_id_symbol)]: 5
}
> await foo();
123
> typeof (await Promise.resolve(foo))();
'object'
> (await Promise.resolve(foo))();
123
```

Note that `typeof` prints `'object'`, which is correct, but the value of the expression is shown to be `123` in the REPL, which is a `'number'`.

### Additional information

Chrome and Edge seem to handle this as I'd expect. Firefox seems to handle this like Node.js (so I'm assuming it's a bug).","closed","tniessen",3109072,"{confirmed-bug,repl,promises}","https://github.com/nodejs/node/issues/43777",5,"Refatoração",NULL,4,NULL,"Os comentários da issue discutem a necessidade de refatorar o código da camada de emulação do REPL (`await.js`) responsável pelo `top-level await`.  A sugestão de solução envolve reescrever partes do código para corrigir o comportamento incorreto, sem mencionar explicitamente a adição ou alteração de testes.  Embora os testes sejam mencionados como um meio de depuração, a ênfase principal está na modificação do código existente para alcançar a funcionalidade correta. A menção a testes de regressão não indica a criação de novos testes, mas sim o uso de testes existentes para depurar o código refatorado."
270,43707,"2022-07-07 03:10:44","2022-07-18 15:35:14","2022-07-18 16:27:22","fs.statSync, fs.stat and fs.promises.stat returns 'Invalid Date' for atime/ctime/mtime with negative epoch time","### Version

v16.15.1

### Platform

Linux localhost.localdomain 4.18.0-394.el8.x86_64 #1 SMP Tue May 31 16:19:11 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

File system

### What steps will reproduce the bug?

1. create a file with minus epoch time.

```console
$ touch --date=@-1 hogehoge
$ ls --full-time hogehoge
-rw-rw-r--. 1 kusanagi kusanagi 0 1969-12-31 23:59:59.000000000 +0000 hogehoge
```

2. run the following code to test `fs.statSync` and `fs.promises.stat` for file hogehoge.

```js
import { stat } from 'fs/promises';
import { statSync } from 'fs';

async function test() {
        const stats = await stat('hogehoge');
        console.log({stats});
        console.log(stats.mtime);
        console.log(stats.mtime.getTime());
}

function testSync() {
        const stats = statSync('hogehoge');
        console.log({stats});
        console.log(stats.mtime);
        console.log(stats.mtime.getTime());
}

await test();
testSync();
```

```js
{
  stats: Stats {
    dev: 64768,
    mode: 33204,
    nlink: 1,
    uid: 1000,
    gid: 1000,
    rdev: 0,
    blksize: 4096,
    ino: 56395369,
    size: 0,
    blocks: 0,
    atimeMs: 1.8446744073709552e+22,
    mtimeMs: 1.8446744073709552e+22,
    ctimeMs: 1657161984281.557,
    birthtimeMs: 1657161921560.5312,
    atime: Invalid Date,
    mtime: Invalid Date,
    ctime: 2022-07-07T02:46:24.282Z,
    birthtime: 2022-07-07T02:45:21.561Z
  }
}
Invalid Date
NaN
{
  stats: Stats {
    dev: 64768,
    mode: 33204,
    nlink: 1,
    uid: 1000,
    gid: 1000,
    rdev: 0,
    blksize: 4096,
    ino: 56395369,
    size: 0,
    blocks: 0,
    atimeMs: 1.8446744073709552e+22,
    mtimeMs: 1.8446744073709552e+22,
    ctimeMs: 1657161984281.557,
    birthtimeMs: 1657161921560.5312,
    atime: Invalid Date,
    mtime: Invalid Date,
    ctime: 2022-07-07T02:46:24.282Z,
    birthtime: 2022-07-07T02:45:21.561Z
  }
}
Invalid Date
NaN
```

### How often does it reproduce? Is there a required condition?

Always.

### What is the expected behavior?

ctime/mtime/atime with negative epoch time shall be treated as it is.
In other words, if -1 then it shall be 1 second before epoch.

Actually, `Date()` supports negative epoch time.

```console
$ node
Welcome to Node.js v16.15.1.
Type "".help"" for more information.
> new Date(-1)
1969-12-31T23:59:59.999Z
>
```

As `stat(2)` supports negative epoch time, which can be observed via ls command, I don't see why `fs.stat`/`fs.statSync`/`fs.promises.stat` treats negative epoch as `NaN`.


### What do you see instead?

```console
$ touch --date=@-1 hogehoge
$ ls --full-time hogehoge
-rw-rw-r--. 1 kusanagi kusanagi 0 1969-12-31 23:59:59.000000000 +0000 hogehoge

$ cat > test.mjs
import { stat } from 'fs/promises';
import { statSync } from 'fs';

async function test() {
        const stats = await stat('hogehoge');
        console.log({stats});
        console.log(stats.mtime);
        console.log(stats.mtime.getTime());
}

function testSync() {
        const stats = statSync('hogehoge');
        console.log({stats});
        console.log(stats.mtime);
        console.log(stats.mtime.getTime());
}

await test();
testSync();

$ node test.mjs
{
  stats: Stats {
    dev: 64768,
    mode: 33204,
    nlink: 1,
    uid: 1000,
    gid: 1000,
    rdev: 0,
    blksize: 4096,
    ino: 56395369,
    size: 0,
    blocks: 0,
    atimeMs: 1.8446744073709552e+22,
    mtimeMs: 1.8446744073709552e+22,
    ctimeMs: 1657161984281.557,
    birthtimeMs: 1657161921560.5312,
    atime: Invalid Date,
    mtime: Invalid Date,
    ctime: 2022-07-07T02:46:24.282Z,
    birthtime: 2022-07-07T02:45:21.561Z
  }
}
Invalid Date
NaN
{
  stats: Stats {
    dev: 64768,
    mode: 33204,
    nlink: 1,
    uid: 1000,
    gid: 1000,
    rdev: 0,
    blksize: 4096,
    ino: 56395369,
    size: 0,
    blocks: 0,
    atimeMs: 1.8446744073709552e+22,
    mtimeMs: 1.8446744073709552e+22,
    ctimeMs: 1657161984281.557,
    birthtimeMs: 1657161921560.5312,
    atime: Invalid Date,
    mtime: Invalid Date,
    ctime: 2022-07-07T02:46:24.282Z,
    birthtime: 2022-07-07T02:45:21.561Z
  }
}
Invalid Date
NaN
```

### Additional information

_No response_","closed","hideishi-m",92977868,"{confirmed-bug,fs}","https://github.com/nodejs/node/issues/43707",5,"Refatoração",NULL,12,NULL,"A issue descreve um bug em como o Node.js lida com datas de época negativas em `fs.statSync`, `fs.stat` e `fs.promises.stat`.  O problema é identificado como um bug de conversão de valores com sinal para sem sinal em um `BigUint64Array`, resultando em um wrap-around de valores negativos.  A solução proposta envolve a mudança para um `BigInt64Array`.  A correção não envolve novos testes, mas sim a refatoração do código para corrigir o manuseio incorreto de tipos de dados,  sendo portanto classificada como Refatoração."
271,43681,"2022-07-04 18:20:23","2023-10-23 07:58:33","2023-10-23 07:58:43","`await Promise.resolve(""import('./mod.mjs')"").then(eval)` rejects/segfaults in REPL","### Version

v18.4.0

### Platform

Linux nic-XPS-15-9570 5.15.0-40-generic #43-Ubuntu SMP Wed Jun 15 12:54:21 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

modules

### What steps will reproduce the bug?

Have an empty `mod.mjs` file, and a `main.mjs` file with the following contents:
```js
console.log(1, await import(""./mod.mjs""));
console.log(2, await eval(`import(""./mod.mjs"")`));
console.log(3, await (0, eval)(`import(""./mod.mjs"")`));
console.log(4, await Promise.resolve(`import(""./mod.mjs"")`).then(s => eval(s)));
console.log(5, await Promise.resolve(`import(""./mod.mjs"")`).then(s => (0,eval)(s)));
console.log(6, await Promise.resolve(`import(""./mod.mjs"")`).then(eval));
```

If you run `node main.mjs`, it works.

However, if you open the REPL and copy-paste-run the first five lines one by one. Now kill the REPL, restart it, and run the sixth line: it throws
```
Uncaught TypeError: Invalid host defined options
    at eval (eval at processTicksAndRejections (node:internal/process/task_queues:95:5), <anonymous>:1:1)
    at eval (<anonymous>)
    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)
    at async REPL2:1:39
```

If you don't restart the REPL before running the sixth line, it _almost always_ crashes with a segfault:
```
[1]    85373 segmentation fault (core dumped)  node
```

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior?

I _assume_ that the last line should work in the REPL, because it works in a file and because all the other lines work in the REPL.
Even if the error is expected for some reason, it shouldn't segfault.

### What do you see instead?

/

### Additional information

_No response_","closed","nicolo-ribaudo",7000710,"{confirmed-bug,repl}","https://github.com/nodejs/node/issues/43681",6,"Ambos",NULL,476,NULL,"A issue relata um erro (segfault) que ocorre no REPL ao executar um código específico envolvendo `Promise.resolve().then(eval)`.  Os comentários indicam que o problema é causado por um erro de gerenciamento de memória (crash corrigido pelo PR #48510) e um comportamento inesperado na escolha do script referenciador que leva à rejeição da Promise (issue #49726). O problema envolve tanto a refatoração do código para corrigir o crash (Testes de Regressão implicitamente envolvidos) quanto investigação de um comportamento inesperado que precisa de testes de regressão para garantir que não regrida novamente."
327,39776,"2021-08-15 22:54:31","2024-07-03 20:14:26","2024-07-03 20:14:26","doc: hash navigation seems broken","# 📗 API Reference Docs Problem

- **Version**: 16.6.2
- **Platform**: Windows 10 x64

## Location

Many API sections

## Description

If you open an API page and then go to some hash part of the same page in the same tab, it seems OK:

[current.gif](https://user-images.githubusercontent.com/10393198/129494763-cb9ae8b5-6e40-4334-8e9b-87c10bf4fd67.gif)

If you open an API page and then click on some hash link to open it in a new tab, the page in the new tab shifts (scrolls) further after a while by a significant amount (delayed loading of some dynamic content may be the culprit):

[new.gif](https://user-images.githubusercontent.com/10393198/129495035-297feadb-6882-4755-9345-f435948aabfd.gif)

Tested with the last Google Chrome version (95.0.4608.0).
","closed","vsemozhetbyt",10393198,"{confirmed-bug,doc}","https://github.com/nodejs/node/issues/39776",13,"Ambos",NULL,1053,"api referência doc problema versão plataforma janela localização seção api descrição abrir página api ir parte hash página aba parecer ok abrir página api clicar link hash abrir aba nova página aba nova deslocar rolar tempo significativo quantidade carregar atrasado conteúdo dinâmico culpado testar último google chrome versão
","O título ""doc: hash navigation seems broken"" sugere um problema na documentação (Refatoração), enquanto comentários como ""test safari work expect"" e ""reproduce problem firefox click link toc often send completely different part page believe browser issue"" indicam a necessidade de testes de regressão para verificar o funcionamento em diferentes navegadores e versões.  A discussão sobre  'lazy load content' e  possíveis soluções também sugere  aspectos de refatoração para otimizar a experiência do usuário. Portanto, a issue abrange tanto refatoração quanto testes de regressão."
273,43556,"2022-06-24 04:40:05","2022-07-14 11:05:50","2022-07-14 11:05:52","domain: fix vm promise tracking while keeping isolation","So the prior fix I did to prevent domain fields from leaking into vm contexts through promises had a bug in that _not_ attaching the field meant the domain no longer had the lifetime connection, so when the before/after events to track domains through into chained promises back in the parent context try to resume the domain it crashes. By stuffing the domain into a weak map pinned to the promise lifetime, the reference is held long enough for it to resume.

I'm not sure if this is the _best_ way to fix it, but it is _a_ fix. 😅 

Fixes #40999 ","closed","Qard",205482,"{confirmed-bug,domain,needs-ci}","https://github.com/nodejs/node/pull/43556",5,"Refatoração","https://api.github.com/repos/nodejs/node/pulls/43556",20,NULL,"O título da issue ""domain: fix vm promise tracking while keeping isolation"" e o corpo da issue indicam uma correção de um bug existente (Fixes #40999)  focada em melhorar o código  e o rastreamento de promessas, sem adicionar novos testes ou funcionalidades. A menção a  'I'm not sure if this is the _best_ way to fix it, but it is _a_ fix' reforça a natureza de refatoração, buscando uma solução melhor para um problema existente."
275,43491,"2022-06-19 12:38:34","2022-06-29 11:26:19","2022-06-29 12:05:40","events: improve `EventListener` validation","This fixes validating `EventListener` given to `addEventListener` to improve the compatibility.

According to [the WPT test](https://github.com/web-platform-tests/wpt/blob/6cef1d2087d6a07d7cc6cee8cf207eec92e27c5f/dom/events/EventTarget-this-of-listener.html#L95-L120) result failed with the current validation, `addEventListener` 
should not require `handleEvent` to be defined on an `EventListener`.  IIUC, the same can 
be applied to `removeEventListener` also.

Signed-off-by: Daeyeon Jeong daeyeon.dev@gmail.com

<!--
Before submitting a pull request, please read
https://github.com/nodejs/node/blob/HEAD/CONTRIBUTING.md.

Commit message formatting guidelines:
https://github.com/nodejs/node/blob/HEAD/doc/contributing/pull-requests.md#commit-message-guidelines

For code changes:
1. Include tests for any bug fixes or new features.
2. Update documentation if relevant.
3. Ensure that `make -j4 test` (UNIX), or `vcbuild test` (Windows) passes.

Developer's Certificate of Origin 1.1

By making a contribution to this project, I certify that:

(a) The contribution was created in whole or in part by me and I
    have the right to submit it under the open source license
    indicated in the file; or

(b) The contribution is based upon previous work that, to the best
    of my knowledge, is covered under an appropriate open source
    license and I have the right under that license to submit that
    work with modifications, whether created in whole or in part
    by me, under the same open source license (unless I am
    permitted to submit under a different license), as indicated
    in the file; or

(c) The contribution was provided directly to me by some other
    person who certified (a), (b) or (c) and I have not modified
    it.

(d) I understand and agree that this project and the contribution
    are public and that a record of the contribution (including all
    personal information I submit with it, including my sign-off) is
    maintained indefinitely and may be redistributed consistent with
    this project or the open source license(s) involved.
-->
","closed","daeyeon",6630703,"{confirmed-bug,""author ready"",needs-ci}","https://github.com/nodejs/node/pull/43491",8,"Refatoração","https://api.github.com/repos/nodejs/node/pulls/43491",10,NULL,"O título da issue (""events: improve `EventListener` validation"") e o corpo indicam uma melhoria na validação do `EventListener`, sem menção explícita a novos testes ou funcionalidades.  A descrição foca em melhorar a compatibilidade com base em um teste WPT existente, sugerindo uma alteração na lógica interna do código sem adicionar novos casos de teste. Os comentários não fornecem evidências contrárias."
276,43468,"2022-06-18 08:47:40","2022-06-27 16:31:44","2022-07-24 08:23:56","CJS/ESM toggle broken on mobile","### What is the problem this feature will solve?

this feature will remove the logo from above the code for better visibility, oof this is giving me eye strain.

![Screenshot_2022-06-18-14-13-48-554_com android chrome](https://user-images.githubusercontent.com/94877880/174430200-7df8f190-36c5-4310-ac92-69c3fccdc782.jpg)


### What is the feature you are proposing to solve the problem?

you can make your site better with some little changes in ui/ux

### What alternatives have you considered?

turning on desktop site","closed","Nit-nit",94877880,"{confirmed-bug,doc}","https://github.com/nodejs/node/issues/43468",10,"Ambos",NULL,9,NULL,"A issue relata problemas de interface do usuário (UI) em dispositivos móveis, especificamente relacionados ao recurso de alternância CJS/ESM.  Os comentários sugerem que o problema não é específico de um dispositivo ou navegador, e sim um problema na implementação do recurso.  A necessidade de correção indica um aspecto de refatoração (melhoria do código para melhor funcionamento e usabilidade), enquanto a verificação em diferentes navegadores e dispositivos e a menção de testes em modo responsivo sugerem a necessidade de testes de regressão para garantir que a correção não introduza novos problemas."
362,37430,"2021-02-18 11:54:44","2021-03-01 17:48:15","2021-03-01 17:48:15","Crash when mode is to big in fs.createWriteStream","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v` 
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: `v14.15.4`, `v15.9.0`
* **Platform**:  Ubuntu, Mac OS
* **Subsystem**: fs

### What steps will reproduce the bug?

Node.js crashes on such code:
```js
const {createWriteStream} = require('fs');

createWriteStream('./1.txt', {
    mode: 2176057344,
});
```
<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior?
Expected to throw, like it happen when mode is `111111111111111`:

```js
node:internal/validators:102
      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      ^

RangeError [ERR_OUT_OF_RANGE]: The value of ""mode"" is out of range. It must be >= 0 && <= 4294967295. Received 111_111_111_111_111
    at parseFileMode (node:internal/validators:68:5)
    at Object.open (node:fs:473:12)
    at WriteStream._construct (node:internal/fs/streams:64:17)
    at constructNT (node:internal/streams/destroy:288:25)
    at processTicksAndRejections (node:internal/process/task_queues:80:21) {
  code: 'ERR_OUT_OF_RANGE'
}
```
<!--
If possible please provide textual output instead of screenshots.
-->

### What do you see instead?
I see a crash:

```
node[70201]: ../src/node_file.cc:1715:void node::fs::Open(const FunctionCallbackInfo<v8::Value> &): Assertion `args[2]->IsInt32()' failed.
 1: 0x1012e4da5 node::Abort() (.cold.1) [/Users/coderaiser/.nvm/versions/node/v14.15.4/bin/node]
 2: 0x1000a6239 node::Abort() [/Users/coderaiser/.nvm/versions/node/v14.15.4/bin/node]
 3: 0x1000a60a1 node::Assert(node::AssertionInfo const&) [/Users/coderaiser/.nvm/versions/node/v14.15.4/bin/node]
 4: 0x1000ae8d2 node::fs::Open(v8::FunctionCallbackInfo<v8::Value> const&) [/Users/coderaiser/.nvm/versions/node/v14.15.4/bin/node]
 5: 0x10025a4e8 v8::internal::FunctionCallbackArguments::Call(v8::internal::CallHandlerInfo) [/Users/coderaiser/.nvm/versions/node/v14.15.4/bin/node]
 6: 0x100259a7c v8::internal::MaybeHandle<v8::internal::Object> v8::internal::(anonymous namespace)::HandleApiCallHelper<false>(v8::internal::Isolate*, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::FunctionTemplateInfo>, v8::internal::Handle<v8::internal::Object>, v8::internal::BuiltinArguments) [/Users/coderaiser/.nvm/versions/node/v14.15.4/bin/node]
 7: 0x1002591a2 v8::internal::Builtin_Impl_HandleApiCall(v8::internal::BuiltinArguments, v8::internal::Isolate*) [/Users/coderaiser/.nvm/versions/node/v14.15.4/bin/node]
 8: 0x100a7a359 Builtins_CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit [/Users/coderaiser/.nvm/versions/node/v14.15.4/bin/node]
Abort trap: 6
```
<!--
If possible please provide textual output instead of screenshots.
-->

### Additional information

<!--
Tell us anything else you think we should know.
-->
","closed","coderaiser",1573141,"{confirmed-bug,fs}","https://github.com/nodejs/node/issues/37430",1,"Refatoração",NULL,11,"nodejs crash fs module rangeerror mode parameter outofrange assertion failed  v14.15.4 v15.9.0 ubuntu macos createwritestream  filemode  crash report stacktrace  internalvalidators
","O título ""Crash when mode is to big in fs.createWriteStream"" e o corpo da issue descrevem um erro de crash em um módulo Node.js devido a um parâmetro inválido.  A menção a  `assertion failed` sugere um problema interno no código. A solução provável envolveria refatorar o código do módulo `fs.createWriteStream` para lidar corretamente com entradas inválidas, em vez de causar um crash. O comentário ""PR"" pode indicar que uma Pull Request com uma solução de refatoração foi criada, reforçando a classificação."
278,43337,"2022-06-07 05:34:34","2022-06-14 19:30:52","2022-06-14 19:30:52","`events.once` leaks signal listener","### Version

v18.3.0

### Platform

Linux

### Subsystem

events

### What steps will reproduce the bug?

```javascript
const { EventEmitter, once } = require(""events"");

(async () => {
  const controller = new AbortController();
  const ee = new EventEmitter();

  setTimeout(() => {
    controller.abort();
  }, 500);

  while (true) {
    setTimeout(() => ee.emit(""test""), 100);
    await once(ee, ""test"", { signal: controller.signal });

    console.dir(controller.signal);
  }
})();
```


### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior?

_No response_

### What do you see instead?

The signal abort listeners do not get removed.

```
AbortSignal {
  [Symbol(kEvents)]: SafeMap(1) [Map] { 'abort' => { size: 1, next: [Listener] } },
  [Symbol(events.maxEventTargetListeners)]: 10,
  [Symbol(events.maxEventTargetListenersWarned)]: false,
  [Symbol(kAborted)]: false,
  [Symbol(kReason)]: undefined
}
AbortSignal {
  [Symbol(kEvents)]: SafeMap(1) [Map] { 'abort' => { size: 2, next: [Listener] } },
  [Symbol(events.maxEventTargetListeners)]: 10,
  [Symbol(events.maxEventTargetListenersWarned)]: false,
  [Symbol(kAborted)]: false,
  [Symbol(kReason)]: undefined
}
AbortSignal {
  [Symbol(kEvents)]: SafeMap(1) [Map] { 'abort' => { size: 3, next: [Listener] } },
  [Symbol(events.maxEventTargetListeners)]: 10,
  [Symbol(events.maxEventTargetListenersWarned)]: false,
  [Symbol(kAborted)]: false,
  [Symbol(kReason)]: undefined
}
AbortSignal {
  [Symbol(kEvents)]: SafeMap(1) [Map] { 'abort' => { size: 4, next: [Listener] } },
  [Symbol(events.maxEventTargetListeners)]: 10,
  [Symbol(events.maxEventTargetListenersWarned)]: false,
  [Symbol(kAborted)]: false,
  [Symbol(kReason)]: undefined
}
```


### Additional information

When listeners are added to `EventTarget`'s in `events.on` and `events.once`, the listener gets wrapped. As `AbortSignal` is an `EventTarget`, this means the abort listener can never be removed.

https://github.com/nodejs/node/blob/b631086208ef5654a8f12fc8241db7dd46201eef/lib/events.js#L1011-L1013

I confirmed that the listeners do get removed correctly when simply passing the listener in directly, however, I'm unsure if this will have any other consequences hinted at by the comment.","closed","breavyn",29270083,"{confirmed-bug,events}","https://github.com/nodejs/node/issues/43337",1,"Refatoração",NULL,8,NULL,"A issue descreve um bug onde ouvintes de sinal de aborto não são removidos corretamente em `events.once`.  A solução proposta envolve passar o ouvinte diretamente,  uma alteração no código existente (refatoração) para corrigir o comportamento. Um PR (Pull Request) foi enviado para essa correção, reforçando a natureza de refatoração da solução."
279,43333,"2022-06-06 21:49:50","2022-07-18 09:20:58","2022-07-18 09:20:58","Child process' `execFile` and `execFileSync` handle arguments different when shell is not falsy","### Version

v18.3.0

### Platform

Linux *** 5.13.0-44-generic #49~20.04.1-Ubuntu SMP *** x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

node:child_process

### What steps will reproduce the bug?

1. Create an ESM file with the following content:
   ```js
   import { execFile, execFileSync } from ""node:child_process"";

   const stdout = execFileSync(
     ""echo"",
     [""foo"", ""bar""],
     { shell: ""/bin/bash"" },
   );
   console.log(`execFileSync: ${stdout}`); // Outputs: ""execFileSync: \n""

   execFile(
     ""echo"",
     [""foo"", ""bar""],
     { shell: ""/bin/bash"" },
     (_, stdout) => {
       console.log(`execFile: ${stdout}`); // Output: ""execFile: foo bar\n""
     },
   );
   ```
1. Note that the `options` object includes a non-falsy value for the `shell` option. (for reference, see [the `child_process.execFile` documentation](https://nodejs.org/api/child_process.html#child_processexecfilefile-args-options-callback)).
1. Run the file using the following command to be able to view the `args` argument to `execFile(Sync)` after normalization:
   ```sh
   $ env NODE_DEBUG=child_process node t.js 2>&1 | grep -w args
   ```
1. Observe the different behaviour:
   ```log
   args: [ '/bin/bash', '-c', '/bin/bash -c echo foo bar' ],
   args: [ '/bin/bash', '-c', 'echo foo bar' ],
   ```

### How often does it reproduce? Is there a required condition?

It always reproduces.

### What is the expected behavior?

`child_process.execFileSync` and `child_process.execFile` invoke commands in the same way given the same arguments. In particular, I believe the behaviour of `execFileSync` is expected.

### What do you see instead?

`child_process.execFileSync` and `child_process.execFile` invoke commands in different ways given the same arguments.

### Additional information

This bug reports follows from a discussion in #29466 - in particular the discussion starting with [this comment of mine](https://github.com/nodejs/node/issues/29466#issuecomment-1146839772). This bug report is based on @bnoordhuis' [comment in that thread](https://github.com/nodejs/node/issues/29466#issuecomment-1147393264).

I tested and was able to reproduce this bug on Node v16.15.0 *and* v18.3.0.","closed","ericcornelissen",3742559,"{confirmed-bug,child_process}","https://github.com/nodejs/node/issues/43333",6,"Refatoração",NULL,41,NULL,"A issue descreve uma inconsistência no tratamento de argumentos entre as funções `execFile` e `execFileSync` do módulo `child_process` quando a opção `shell` não é falsy.  A solução proposta envolve evitar o uso da função de normalização de argumentos para `spawn` dentro de `execFile`, indicando uma necessidade de alteração no código existente para corrigir um comportamento inesperado, sem adicionar novos testes ou funcionalidades, caracterizando uma refatoração."
281,43205,"2022-05-25 13:13:13","2023-09-14 15:47:57","2023-09-14 15:47:58","`Segmentation fault` when executing worker with `eval: true` containing dynamic import after `await`","### Version

v16.15.0

### Platform

Microsoft Windows NT 10.0.19044.0 x64 / WSL: Linux PC 4.4.0-19041-Microsoft #1237-Microsoft Sat Sep 11 14:32:00 PST 2021 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

_No response_

### What steps will reproduce the bug?

1. Download https://gist.github.com/sapphi-red/a0179b52ebd3b6a19f51743594810ecf
1. Run `node eval_cjs.mjs`. It exits with non-0 exit code.
    a. On windows, it does not show any error messages. The output of `echo $LASTEXITCODE` is `-1073741819`.
    b. On WSL (Ubuntu), it shows `Segmentation fault (core dumped)`. The output of `echo $?` is `139`.
1. Run `node eval_cjs_cjs.cjs`. It exits with non-0 exit code same with `eval_cjs.mjs`.
1. Run `noneval_cjs.mjs`. It finishes without any errors.
1. Run `noneval_mjs.mjs`. It finishes without any errors.

The difference between the files are:
|filename|parent script|worker script|is eval|result|
|----|-----|-----|----|----|
|`eval_cjs.mjs`|ESM|CJS|O|fail|
|`eval_cjs_cjs.cjs`|CJS|CJS|O|fail|
|`noneval_cjs.mjs`|ESM|CJS|X|success|
|`noneval_mjs.mjs`|ESM|ESM|X|success|


### How often does it reproduce? Is there a required condition?

It reproduces every time on my machine. `const startAt = Date.now() + 10 * 1000` might differ between machines.

I suppose at least it needs to meet the following condition:
- `worker` is created with `eval: true`
- dynamic import is called after `await`

I am not sure why it requires 10 seconds delay.


### What is the expected behavior?

Segmentation fault not happening.

### What do you see instead?

Segmentation fault is happening.

### Additional information

context: I was tring to fix https://github.com/vitejs/vite/pull/8049#issuecomment-1135919637. (`FailureMessage` one is not related to this.)","closed","sapphi-red",49056869,"{confirmed-bug,module}","https://github.com/nodejs/node/issues/43205",11,"Refatoração",NULL,477,NULL,"A issue descreve um erro de segmentação (`Segmentation fault`) que ocorre em diferentes versões do Node.js ao executar um worker com `eval: true` e um `import` dinâmico após um `await`.  Os comentários mostram que o problema se origina em um erro de ponteiro nulo em código interno do Node.js (no arquivo `module_wrap.cc`).  A solução foi encontrada através de uma refatoração do código para adicionar verificações de nulidade, como demonstrado em um pull request que corrige o problema. Não há menção direta a testes de regressão, apesar de a correção ter sido validada posteriormente."
283,43128,"2022-05-17 17:55:09","2022-12-29 10:36:34","2022-12-29 19:50:33","High cpu usage for outbound ssl requests after upgrading from v16.15.0 to v18.1.0","### Version

v18.1.0

### Platform

Linux 5.17.4-arch1-1 #1 SMP PREEMPT Wed, 20 Apr 2022 18:29:28 +0000 x86_64 GNU/Linux

### Subsystem

crypto

### What steps will reproduce the bug?

I have observed this problem in few http clients: axios, got. But looks like a problem is in node.js itself. 

1. Create a basic http server which produces outbound ssl requests and returns in response result of outbound request. Here is a sample
```js
const http = require(""http"");
const https = require(""https"");

const port = 3000;

const handler = (req, res) => {
  https.get(""https://server.local"", (response) => {
    let body = """";

    response.on('data', chunk => {
      body += chunk;
    });

    response.on(""end"", () => {
      res.statusCode = response.statusCode;
      res.setHeader('Content-Type', 'text/plain');
      res.end(body);
    });
  });
};

const server = http.createServer(handler);

server.listen(port);
```
2. Start to produce load to server. I'm using `hey`
```
hey -z 1m -c 10 -disable-keepalive ""http://client.local:3000""
```
3. Observe in CPU profiler for node.js server constantly increasing cpu usage for `SecureContext.init()`. It starts from ~50% and going up to 80%. Amount of requests processed by server, which sends outbound https requests is constantly decreasing.

### How often does it reproduce? Is there a required condition?

Always reproduces if present outbound ssl requests and node version 18.1.0

### What is the expected behavior?

Constant CPU usage, amount of processed requests is at the same level during time. In node.js v16.15.0 same code in CPU profiler have `SecureContext.init()` with usage of 5-8%. And during load there is no performance degradation.

### What do you see instead?

CPU usage is keeping increasing during time, `SecureContext.init()` starts from ~50% cpu time in profiler and keep growing during time to 80-85%. Amount of requests processed by server is constantly decreasing.


### Additional information

v18.1.0
Benchmark result - 186 req/s
node --perf output - https://pastebin.com/wyHPXfMH
cpu profile screenshot
![cpu_profile_v18 1 0](https://user-images.githubusercontent.com/1708854/168877260-03e8c28e-3744-4f40-8869-7bec2ff1ea16.png)

v16.15.0
Benchmark result - 1184 req/s
node --perf output - https://pastebin.com/0L0Z01iq
cpu profile screenshot
![cpu_profile_v16 15 0](https://user-images.githubusercontent.com/1708854/168877342-2330d40c-2ef9-4b15-92ff-926e3d41207c.png)

","closed","str1ke",1708854,"{confirmed-bug,tls}","https://github.com/nodejs/node/issues/43128",18,"Ambos",NULL,226,NULL,"A issue relata um problema de alto consumo de CPU em solicitações SSL de saída após a atualização do Node.js v16.15.0 para v18.1.0.  A análise dos comentários indica que o problema está relacionado à atualização do OpenSSL para a versão 3.x.  Há evidências de refatoração necessária no código do Node.js para lidar com as mudanças no OpenSSL 3.x (melhorias de performance observadas em versões posteriores do Node.js, como a 18.2.0, sugerem ajustes internos).  Simultaneamente, há necessidade de testes de regressão para garantir a compatibilidade com a nova versão do OpenSSL e verificar o desempenho em diferentes cenários de carga. A discussão sobre a utilização de `https.get` vs `fetch`, e a análise dos perfis de CPU em diferentes versões e com diferentes clientes HTTP, reforça a necessidade de ambos os tipos de intervenção (refatoração e testes)."
284,43122,"2022-05-17 02:13:03","2022-05-19 14:00:38","2022-05-19 14:00:38","Heap snapshot crash when using worker_threads","### Version

`v12.22.12` & `v14.19.2` & `v16.15.0`

### Platform

All

### Subsystem

V8 engine

### What steps will reproduce the bug?

```js
function createSnapshot(filename) {
  const stream = require('fs').createWriteStream(filename);
  require('v8').getHeapSnapshot().pipe(stream);

}

function main() {
  const workerThreads = require('worker_threads');
  if (workerThreads.isMainThread) {
    const w = new workerThreads.Worker(__filename, {
      env: process.env,
    });

    w.once('exit', code => {
      createSnapshot('main.heapsnapshot');
      console.log(JSON.stringify({ code }));
    });
  } else {
    createSnapshot('worker_threads.heapsnapshot');
  }
}

main();
```

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior?

No crashes.

### What do you see instead?

Always crashed with `SIGSEGV`:

```bash
hyj1991@GDP-WIN3:~/test$ lldb /home/hyj1991/.tnvm/versions/node/v16.15.0/bin/node -c node.1652753197.core.18410
(lldb) target create ""/home/hyj1991/.tnvm/versions/node/v16.15.0/bin/node"" --core ""node.1652753197.core.18410""
Core file '/home/hyj1991/test/node.1652753197.core.18410' (x86_64) was loaded.
(lldb) bt
* thread #1, name = 'node', stop reason = signal SIGSEGV
  * frame #0: 0x0000000000bcdfd7 node`node::worker::Worker::MemoryInfo(node::MemoryTracker*) const + 343
    frame #1: 0x0000000000a9ecd2 node`node::Environment::BuildEmbedderGraph(v8::Isolate*, v8::EmbedderGraph*, void*) + 2370
    frame #2: 0x000000000117f6ec node`v8::internal::HeapProfiler::BuildEmbedderGraph(v8::internal::Isolate*, v8::EmbedderGraph*) + 44
    frame #3: 0x000000000118ccf9 node`v8::internal::NativeObjectsExplorer::IterateAndExtractReferences(v8::internal::HeapSnapshotGenerator*) + 153
    frame #4: 0x000000000118e93f node`v8::internal::HeapSnapshotGenerator::GenerateSnapshot() + 495
    frame #5: 0x0000000001180246 node`v8::internal::HeapProfiler::TakeSnapshot(v8::ActivityControl*, v8::HeapProfiler::ObjectNameResolver*, bool, bool) + 134
    frame #6: 0x0000000000aa9b16 node`node::heap::CreateHeapSnapshotStream(v8::FunctionCallbackInfo<v8::Value> const&) + 118
    frame #7: 0x0000000000d552fe node`v8::internal::MaybeHandle<v8::internal::Object> v8::internal::(anonymous namespace)::HandleApiCallHelper<false>(v8::internal::Isolate*, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::FunctionTemplateInfo>, v8::internal::Handle<v8::internal::Object>, v8::internal::BuiltinArguments) + 926
    frame #8: 0x0000000000d5671f node`v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) + 175
    frame #9: 0x00000000015f2179 node`Builtins_CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit + 57
    frame #10: 0x0000000001584b4a node`Builtins_InterpreterEntryTrampoline + 202
    frame #11: 0x0000000001584b4a node`Builtins_InterpreterEntryTrampoline + 202
    frame #12: 0x0000000001584b4a node`Builtins_InterpreterEntryTrampoline + 202
    frame #13: 0x0000000001584b4a node`Builtins_InterpreterEntryTrampoline + 202
    frame #14: 0x0000000001584b4a node`Builtins_InterpreterEntryTrampoline + 202
    frame #15: 0x0000000001584b4a node`Builtins_InterpreterEntryTrampoline + 202
    frame #16: 0x0000000001584b4a node`Builtins_InterpreterEntryTrampoline + 202
    frame #17: 0x0000000001582d58 node`Builtins_JSEntryTrampoline + 88
    frame #18: 0x0000000001582ae3 node`Builtins_JSEntry + 131
    frame #19: 0x0000000000e24418 node`v8::internal::(anonymous namespace)::Invoke(v8::internal::Isolate*, v8::internal::(anonymous namespace)::InvokeParams const&) + 328
    frame #20: 0x0000000000e2526f node`v8::internal::Execution::Call(v8::internal::Isolate*, v8::internal::Handle<v8::internal::Object>, v8::internal::Handle<v8::internal::Object>, int, v8::internal::Handle<v8::internal::Object>*) + 95
    frame #21: 0x0000000000d15112 node`v8::Function::Call(v8::Local<v8::Context>, v8::Local<v8::Value>, int, v8::Local<v8::Value>*) + 258
    frame #22: 0x0000000000a43295 node`node::InternalMakeCallback(node::Environment*, v8::Local<v8::Object>, v8::Local<v8::Object>, v8::Local<v8::Function>, int, v8::Local<v8::Value>*, node::async_context) + 661
    frame #23: 0x0000000000a54029 node`node::AsyncWrap::MakeCallback(v8::Local<v8::Function>, int, v8::Local<v8::Value>*) + 121
    frame #24: 0x0000000000bcce1c node`node::worker::Worker::JoinThread() + 700
    frame #25: 0x0000000000a8a9f8 node`node::Environment::RunAndClearNativeImmediates(bool) + 1080
    frame #26: 0x0000000000a8addc node`node::Environment::InitializeLibuv()::'lambda'(uv_async_s*)::_FUN(uv_async_s*) + 60
    frame #27: 0x0000000001564936 node`uv__async_io(loop=0x00000000057f0860, w=<unavailable>, events=<unavailable>) at async.c:163:5
    frame #28: 0x0000000001577064 node`uv__io_poll(loop=0x0000000004a43c60, timeout=<unavailable>) at epoll.c:374:11
    frame #29: 0x0000000001565288 node`uv_run(loop=0x0000000004a43c60, mode=UV_RUN_DEFAULT) at core.c:389:5
    frame #30: 0x0000000000a43dd5 node`node::SpinEventLoop(node::Environment*) + 309
    frame #31: 0x0000000000b4bdb6 node`node::NodeMainInstance::Run(node::EnvSerializeInfo const*) + 406
    frame #32: 0x0000000000acd592 node`node::Start(int, char**) + 546
    frame #33: 0x00007f4e4a1c8c87 libc.so.6`__libc_start_main(main=(node`main), argc=2, argv=0x00007ffd6e0724c8, init=<unavailable>, fini=<unavailable>, rtld_fini=<unavailable>, stack_end=0x00007ffd6e0724b8) at libc-start.c:310
    frame #34: 0x0000000000a4067c node`_start + 41
(lldb)

```

### Additional information

It crashes on all the latest LTS versions, I guess this is an incompatibility implementation between the worker_threads and v8.","closed","hyj1991",19908330,"{confirmed-bug,worker}","https://github.com/nodejs/node/issues/43122",1,"Ambos",NULL,2,NULL,"O título da issue indica um crash relacionado ao heap snapshot ao usar worker_threads. O corpo da issue detalha os passos para reproduzir o erro, mostrando código que utiliza worker_threads e a função `getHeapSnapshot()` do V8.  O crash ocorre em múltiplas versões do Node.js, sugerindo um problema na interação entre o V8 e o módulo worker_threads. A necessidade de investigação e correção indica tanto a necessidade de refatoração do código (provavelmente no V8 ou no módulo worker_threads para corrigir a incompatibilidade) quanto a necessidade de testes de regressão para garantir que a correção não introduza novos problemas."
286,42868,"2022-04-25 15:45:32","2024-03-10 00:23:46","2024-03-10 00:23:47","Stalled top-level promise detection for TLA","### Version

v18.0.0

### Subsystem

modules

### What steps will reproduce the bug?

create file `1.mjs` with following content
```js
await new Promise(() => {})
```
run it and check code returned by process with `node 1.mjs && echo $?`

### What is the expected behavior?

I would like to be verbousely warned that script didn't reach it's end

### What do you see instead?

process finished with error code 13, with nothing in console

```console
> node 1.mjs && echo $?
13
```","closed","zuozp8",1228107,"{confirmed-bug}","https://github.com/nodejs/node/issues/42868",17,"Ambos",NULL,684,NULL,"A issue descreve um bug (comportamento inesperado do Node.js ao lidar com promises top-level em await) que requer tanto refatoração do código Node.js (para adicionar um aviso de promessa pendente) quanto testes de regressão para garantir que a correção não introduza novos problemas.  Os comentários discutem a necessidade de uma possível alteração em V8,  e a criação de um PR para implementar a solução. Isso indica a necessidade de ambos, refatoração e testes."
287,42829,"2022-04-22 19:59:56","2022-06-18 09:20:41","2022-06-18 09:20:41","Crash in AfterOpenFileHandle","### Version

latest (18.0.0)

### Platform

Linux

### Subsystem

fs (presumably)

### What steps will reproduce the bug?

1. Compile Node.js:

   ```console
   ./configure
   make
   ```

   For reference, I am building Node.js as of 3a6b975981.

2. Add WPTs for `wasm/webapi` and `wasm/jsapi`:

   ```console
   git node wpt wasm/webapi
   git node wpt wasm/jsapi
   ```

   For reference, for me, this has resulted in the following additions to `versions.json`:
   
   ```json
     ""wasm/jsapi"": {
       ""commit"": ""1dd414c79616489ea021c800eb0375a709e8114e"",
       ""path"": ""wasm/jsapi""
     },
     ""wasm/webapi"": {
       ""commit"": ""fd1b23eeaaf9a01555d4fa29cf79ed11a4c44a50"",
       ""path"": ""wasm/webapi""
     }
   ```

3. Create `test/wpt/status/wasm/webapi.json` and mark all tests as failing:

   ```json
   {
     ""historical.any.js"": {
       ""skip"": ""indexedDB is not defined""
     },
     ""origin.sub.any.js"": {
       ""skip"": ""CORS not implemented""
     },

     ""abort.any.js"": {
       ""fail"": ""WPTRunner does not support fetch()""
     },
     ""contenttype.any.js"": {
       ""fail"": ""WPTRunner does not support fetch()""
     },
     ""empty-body.any.js"": {
       ""fail"": ""Bug in undici, see https://github.com/nodejs/undici/issues/1345""
     },
     ""idlharness.any.js"": {
       ""fail"": ""not configured""
     },
     ""status.any.js"": {
       ""fail"": ""WPTRunner does not support fetch()""
     },

     ""body.any.js"": { ""fail"": ""."" },
     ""rejected-arg.any.js"": { ""fail"": ""."" },
     ""invalid-args.any.js"": { ""fail"": ""."" },
     ""invalid-code.any.js"": { ""fail"": ""."" },
     ""instantiateStreaming-bad-imports.any.js"": { ""fail"": ""."" },
     ""instantiateStreaming.any.js"": { ""fail"": ""."" },
     ""modified-contenttype.any.js"": { ""fail"": ""."" }
   }
   ```

   **If any of these WPTs are not failing, that likely only means that node's compliance with the WPTs improved. In that case, we might not be able to reproduce this bug using these WPTs anymore, but it does not necessarily mean that the bug has been fixed.**

4. Create `test/wpt/test-wasm-webapi.js`:

   ```js
   'use strict';

   require('../common');
   const { WPTRunner } = require('../common/wpt');

   const runner = new WPTRunner('wasm/webapi');
   runner.runJsTests();
   ```

5. Run the test until it crashes:

   ```console
   while ./node test/wpt/test-wasm-webapi.js ; do : ; done
   ```

### How often does it reproduce? Is there a required condition?

The probability that any given test run crashes appears to be low, but after sufficiently many runs, it inevitably crashes.

### What is the expected behavior?

Many WPT error messages and expected failures, but no crash.

### What do you see instead?

Many WPT error messages and expected failures, and eventually:

```
FATAL ERROR: v8::FromJust Maybe value is Nothing.
 1: 0x55b6fb8f7284 node::Abort() [./node]
 2: 0x55b6fb7ed3ee node::FatalError(char const*, char const*) [./node]
 3: 0x55b6fbb10c2c v8::api_internal::FromJustIsNothing() [./node]
 4: 0x55b6fb8222a5 node::UVException(v8::Isolate*, int, char const*, char const*, char const*, char const*) [./node]
 5: 0x55b6fb8ffb0b node::fs::FSReqAfterScope::Reject(uv_fs_s*) [./node]
 6: 0x55b6fb9045c8 node::fs::AfterOpenFileHandle(uv_fs_s*) [./node]
 7: 0x55b6fc531651  [./node]
 8: 0x55b6fc535838  [./node]
 9: 0x55b6fc5497d4  [./node]
10: 0x55b6fc536254 uv_run [./node]
11: 0x55b6fb81c756 node::SpinEventLoop(node::Environment*) [./node]
12: 0x55b6fb9dc759 node::worker::Worker::Run() [./node]
13: 0x55b6fb9dcb4c  [./node]
14: 0x7f3c3bdf3609  [/lib/x86_64-linux-gnu/libpthread.so.0]
15: 0x7f3c3bd18163 clone [/lib/x86_64-linux-gnu/libc.so.6]
```

### Additional information

Discovered while testing #42701. Reproduced both locally and on multiple CI systems.

Hopefully, we will add support for `fetch()` in the `WPTRunner` soon, at which point these instructions will likely not lead to the crash, assuming the currently vast number of `ENOENT` errors that occur when the WPTs attempt to use `fetch()` is responsible for the crash within fs.

However, once that happens and when these instructions do not reproduce the crash anymore, that does not mean that the underlying bug has been fixed.

If you find a simpler reproduction, please comment below :)","closed","tniessen",3109072,"{confirmed-bug,fs}","https://github.com/nodejs/node/issues/42829",2,"Nenhum",NULL,57,NULL,"A issue descreve um crash no Node.js durante a execução de testes Web Platform Tests (WPTs).  A causa raiz do crash parece estar relacionada a um problema com o `fetch()` no `WPTRunner` e potencialmente com o gerenciamento de arquivos (`fs`). Não há menção a refatoração de código ou a testes de regressão como objetivo principal da issue. A issue foca na identificação e resolução de um bug de crash, não em melhorias de código ou na execução de testes sistemáticos para prevenir regressões. Os comentários não adicionam informações relevantes para mudar essa classificação."
290,42646,"2022-04-07 23:45:52","2022-04-12 14:35:00","2022-04-12 14:35:00","`atob` should throw an error if the input is not correctly encoded","### Version

17.9.0

### Platform

MacOS 12.2

### Subsystem

global / buffer

### What steps will reproduce the bug?

_No response_

### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior?

```js
atob('a') // => DOMException
atob('a ') // => DOMException
atob('aaaaa') // => DOMException
```

### What do you see instead?

```js
atob('a') === ''
atob('a ') === ''
atob('aaaaa') === 'i¦\x9A'
```

### Additional information

https://infra.spec.whatwg.org/#forgiving-base64-decode step 3

Related to #42539 / #42530 @aduh95","closed","zloirock",2213682,"{confirmed-bug,buffer}","https://github.com/nodejs/node/issues/42646",2,"Ambos",NULL,5,NULL,"A issue descreve um bug onde a função `atob` não lança exceção para entradas incorretas, retornando strings inesperadas.  A resolução envolve corrigir o comportamento da função (`Refatoração`), e possivelmente adicionar testes para garantir que a correção funcione e que exceções sejam lançadas nos casos esperados (`Testes de Regressão`). A menção à especificação WhatWG e os números de outras issues (#42539 / #42530) reforçam a necessidade de ambas as ações."
292,42302,"2022-03-11 18:24:01","2023-06-24 15:36:16","2023-06-24 15:36:16","Linked modules do not get added to the built-in modules","### Version

v17.7.0

### Platform

Windows

### Subsystem

_No response_

### What steps will reproduce the bug?

Compile NodeJS and add a linked module by e.g. using this command:
```bash
vcbuild.bat x64 dll link-module ./my-extra-module.js
```

### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior?

The module should be available as a built-in module when using the resulting binary.

### What do you see instead?

The file is missing from the file generated by the `js2c` script, presumably by faulty refactoring done in the past. (It still worked with NodeJS v14)

### Additional information

_No response_","closed","LeonMrBonnie",27892888,"{confirmed-bug,build}","https://github.com/nodejs/node/issues/42302",2,"Ambos",NULL,470,NULL,"O título da issue indica um problema de compilação de módulos ('Linked modules do not get added...'), sugerindo um defeito que precisa de correção (refatoração).  Porém, o comentário menciona um pull request para corrigir o problema ('I've opened https://github.com/nodejs/node/pull/48522 to fix.'),  indicando que testes de regressão serão necessários para garantir que a correção não introduziu novos problemas.  A menção de um pull request anterior ('https://github.com/nodejs/node/pull/39069') também implica em testes prévios que podem ter falhado."
313,40452,"2021-10-14 06:49:52","2021-11-10 02:16:53","2021-11-10 02:16:53","Can someone take a look at this code in _http_agent.js there may be a bug.","### Discussed in https://github.com/nodejs/node/discussions/40443

<div type='discussions-op-text'>

<sup>Originally posted by **snytkine** October 13, 2021</sup>
I'm not sure if this is the correct forum for this. Also I have never worked on node.js code itself so I may not have a complete understanding how the agent manages sockets. I was reviewing the code in _http_agent.js and I think that several things regarding counters of sockets and free sockets are incorrect.

I want someone to review this code to confirm

In _http_agent.js around line 266 in function addRequest

``` const freeSockets = this.freeSockets[name];
  let socket;
  if (freeSockets) {
    while (freeSockets.length && freeSockets[0].destroyed) {
      ArrayPrototypeShift(freeSockets);
    }
    socket = this.scheduling === 'fifo' ?
      ArrayPrototypeShift(freeSockets) :
      ArrayPrototypePop(freeSockets);
    if (!freeSockets.length)
      delete this.freeSockets[name];
  }

  const freeLen = freeSockets ? freeSockets.length : 0;
  const sockLen = freeLen + this.sockets[name].length;

  if (socket) {
    asyncResetHandle(socket);
    this.reuseSocket(socket, req);
    setRequestSocket(this, req, socket);
    ArrayPrototypePush(this.sockets[name], socket);
    this.totalSocketCount++;
  } 
  ```
I understand that if socket is found in freeSockets then this socket will be used. But what I don't understand is why this.totalSocketCount is incremented at this point?

I mean the socket was basically taken from a pool of freeSockets and as far as I understand it the socket in freeSockets is already counted in this.totalSocketCount

I think this counter should only be incremented when new socket is created and decremented when socket is destroyed. But in this case it not a new socket so counter should not be incremented. 

if this is a bug then it can potentially increment totalSocketCount to a much higher number when sockets are being reused, preventing the system from creating new socket when new socket is needed

Can someone take a second look at it and confirm or deny my findings?
</div>","closed","ronag",3065230,"{confirmed-bug,http,""good first issue""}","https://github.com/nodejs/node/issues/40452",14,"Ambos",NULL,27,NULL,"A issue relata um potencial bug em um contador de sockets (`totalSocketCount`) no código do _http_agent.js.  A discussão inicial se foca em entender se o contador está sendo incrementado incorretamente quando um socket é reutilizado, o que poderia levar a uma contagem imprecisa e problemas na criação de novos sockets. Posteriormente, a análise se aprofunda e é confirmado que existe um bug, com um pull request apresentado para corrigir o problema.  A correção envolve tanto refatoração de código (alteração da lógica de incremento/decremento do contador) quanto a adição de testes para verificar o comportamento corrigido.  Portanto, a issue envolve ambos os aspectos, refatoração e testes de regressão."
296,42098,"2022-02-18 20:01:04","2022-03-11 00:37:00","2023-04-17 15:43:31","HTTPS imports fail for relative URLs","### Details

Part of the goal of the network import feature for ECM is that I should be able to load a module hosted via any HTTPS location, like for example common CDNs for hosting such modules such as https://esm.run or https://unpkg.com.

For example, the [popular `uuid` package](https://github.com/uuidjs/uuid) claims it's an ESM:
![image](https://user-images.githubusercontent.com/1086030/154751863-75901725-a649-4f01-bfba-1f00d091ac61.png)

It is hosted in the various CDNs:
- https://www.jsdelivr.com/package/npm/uuid
- https://unpkg.com/uuid@8.3.2

Yet, none of these work when trying to load with the new network imports, see snippet.

### Node.js version

17.5 with --experimental-network-imports

### Example code

Example:
```javascript
import { v4 as uuidv4 } from 'https://cdn.jsdelivr.net/npm/uuid@8.3.2/wrapper.mjs';
console.log(uuidv4());
```
Output:
```
> node --experimental-network-imports index.js
node:internal/errors:465
    ErrorCaptureStackTrace(err);
    ^

TypeError [ERR_INVALID_URL]: Invalid URL
    at new NodeError (node:internal/errors:372:5)
    at onParseError (node:internal/url:563:9)
    at new URL (node:internal/url:643:5)
    at ESMLoader.resolve (node:internal/modules/esm/loader:578:5)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at async ESMLoader.getModuleJob (node:internal/modules/esm/loader:250:7)
    at async ModuleWrap.<anonymous> (node:internal/modules/esm/module_job:81:21)
    at async Promise.all (index 0)
    at async link (node:internal/modules/esm/module_job:86:9) {
  input: './dist/index.js',
  code: 'ERR_INVALID_URL'
}

Node.js v18.0.0-nightly20220216dace5a804e
```

Another example
```javascript
import { v4 as uuidv4 } from 'https://unpkg.com/browse/uuid@8.3.2/wrapper.mjs'

console.log(uuidv4());
```

Output:
```
> node --experimental-network-imports index.js
node:internal/errors:465
    ErrorCaptureStackTrace(err);
    ^

RangeError [ERR_UNKNOWN_MODULE_FORMAT]: Unknown module format: null for URL https://unpkg.com/browse/uuid@8.3.2/wrapper.mjs
    at new NodeError (node:internal/errors:372:5)
    at ESMLoader.load (node:internal/modules/esm/loader:385:13)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at async ESMLoader.moduleProvider (node:internal/modules/esm/loader:282:11) {
  code: 'ERR_UNKNOWN_MODULE_FORMAT'
}

Node.js v18.0.0-nightly20220216dace5a804e
```

### Operating system

MacOS 12.1

### Scope

Runtimne

### Module and version

Not applicable.","closed","yavorg",1086030,"{confirmed-bug,module,esm}","https://github.com/nodejs/node/issues/42098",16,"Refatoração",NULL,20,NULL,"A issue relata problemas com o carregamento de módulos via HTTPS usando a flag `--experimental-network-imports` no Node.js.  Os comentários mostram a identificação de um bug no carregador de módulos (loader) que não suportava URLs relativos em imports HTTPS.  A solução envolveu a correção deste bug no código do loader,  uma alteração no código fonte do Node.js (como demonstrado pelo patch sugerido).  Embora haja testes envolvidos na verificação da correção, a solução principal é uma refatoração do código do loader para corrigir o suporte a URLs, o foco principal não é em testes de regressão, mas na correção de um erro de código."
297,41910,"2022-02-09 19:30:37","2022-02-12 17:57:53","2022-02-12 18:41:55","Uncatchable EINVAL when passing a 0-length array of buffers to FileHandle.writev","### Version

16.13.2

### Platform

Linux [myhostname] 3.10.0-1160.42.2.el7.x86_64 #1 SMP Tue Sep 7 14:49:57 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

fs

### What steps will reproduce the bug?

Invoke https://nodejs.org/api/fs.html#filehandlewritevbuffers-position with an empty array:

```
/tmp λ cat repro.mjs
import * as fs from 'fs';

try {
  const handle = await fs.promises.open('./out.txt', 'w');
  await handle.writev([]);
  await handle.close();
} catch (e) {
  console.error('caught', e);
}

console.log('done');
```

### How often does it reproduce? Is there a required condition?

Unconditionally with the above reproduction.  It also happens on macOS.

### What is the expected behavior?

The resulting error should be caught and logged by the catch block.

Alternatively, this should not be an error at all.  Writing no data with other FS functions does not result in errors.

### What do you see instead?

The resulting error is uncatchable and kills the process.
```
/tmp λ node repro.mjs
node:internal/fs/promises:547
  const bytesWritten = (await binding.writeBuffers(handle.fd, buffers, position,
                                      ^

Error: EINVAL: invalid argument, write
    at writev (node:internal/fs/promises:547:39)
    at fsCall (node:internal/fs/promises:313:18)
    at FileHandle.writev (node:internal/fs/promises:182:12)
    at file:///tmp/repro.mjs:5:16 {
  errno: -22,
  code: 'EINVAL',
  syscall: 'write'
}
```

### Additional information

_No response_","closed","isker",5225653,"{confirmed-bug,fs}","https://github.com/nodejs/node/issues/41910",7,"Ambos",NULL,3,NULL,"A issue relata um erro 'EINVAL' ao passar um array vazio para FileHandle.writev, causando um comportamento inesperado e impossibilitando a captura do erro.  Há menção de um pull request para corrigir o problema ('Opened a PR to fix at ...'), indicando refatoração. Além disso, os comentários descrevem testes adicionais que expõem outros problemas relacionados, indicando a necessidade de testes de regressão para garantir que a solução não introduza novos erros. A existência de testes e a necessidade de correção apontam para a necessidade de ambos."
369,36931,"2021-01-14 19:11:17","2021-02-03 22:06:02","2021-02-03 22:06:02","Unhandled `'error'` event on aborted request","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: v8.17.0, v10.23.1, v12.20.1, v14.15.4, v15.5.1
* **Platform**: Darwin imac.local 20.2.0 Darwin Kernel Version 20.2.0: Wed Dec  2 20:39:59 PST 2020; root:xnu-7195.60.75~1/RELEASE_X86_64 x86_64
* **Subsystem**: http

### What steps will reproduce the bug?

<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->

```
$ cat test.js 
const http = require('http');

const req = http.get('http://[2604:1380:45f1:3f00::1]:4002');

req.on('error', console.error);
req.abort();
```

```
$ node test.js 
node:events:353
      throw er; // Unhandled 'error' event
      ^

Error: connect EHOSTUNREACH 2604:1380:45f1:3f00::1:4002 - Local (:::49474)
    at internalConnect (node:net:910:16)
    at defaultTriggerAsyncIdScope (node:internal/async_hooks:430:12)
    at node:net:1001:9
    at processTicksAndRejections (node:internal/process/task_queues:75:11)
Emitted 'error' event on Socket instance at:
    at emitErrorNT (node:internal/streams/destroy:188:8)
    at emitErrorCloseNT (node:internal/streams/destroy:153:3)
    at processTicksAndRejections (node:internal/process/task_queues:80:21) {
  errno: -65,
  code: 'EHOSTUNREACH',
  syscall: 'connect',
  address: '2604:1380:45f1:3f00::1',
  port: 4002
}
```

### How often does it reproduce? Is there a required condition?

Always. No required condition.

### What is the expected behavior?

<!--
If possible please provide textual output instead of screenshots.
-->

The error is handled by the `'error'` event listener.

### What do you see instead?

<!--
If possible please provide textual output instead of screenshots.
-->

The error is not handled.

### Additional information

<!--
Tell us anything else you think we should know.
-->

If `req.abort()` is removed the error is correctly handled.
","closed","lpinca",1443911,"{confirmed-bug,http,macos,linux}","https://github.com/nodejs/node/issues/36931",6,"Ambos",NULL,20,"version v8.17.0 v10.23.1 v12.20.1 v14.15.4 v15.5.1 platform darwin imac.local darwin kernel version x86_64 subsystem http step reproduce bug cat test.js const http require http req http.get 2604:1380:45f1:3f00::1:4002 req.on error console.error req.abort node test.js node:events:353 throw er error error connect ehostunreach 2604:1380:45f1:3f00::1:4002 local :::49474 internalconnect node:net:910:16 defaulttriggerasyncidscope node:internal/async_hooks:430:12 node:net:1001:9 procesticksandrejections node:internal/process/task_queues:75:11 emitted error event socket instance emiterrornt node:internal/streams/destroy:188:8 emiterrorclosent node:internal/streams/destroy:153:3 procesticksandrejections node:internal/process/task_queues:80:21 errno code ehostunreach syscall connect address 2604:1380:45f1:3f00::1 port 4002 reproduce required condition always required condition expected behavior error handled error event listener see instead error handled additional information req.abort removed error correctly handled
","A issue descreve um bug em que o evento 'error' não é tratado corretamente quando uma requisição é abortada (Refatoração necessária para corrigir o tratamento do evento).  Um comentário menciona ""regression test"", indicando a necessidade de testes de regressão para garantir que a correção não introduza novos problemas."
299,41714,"2022-01-27 06:26:46","2023-03-24 07:20:33","2023-03-24 07:20:33","`assert.deepEqual` and `assert.deepStrictEqual` incorrectly compare Proxied arrays when using `ownKeys` trap","### Version

v17.4.0

### Platform

Darwin macbook-pro-5.lan 21.2.0 Darwin Kernel Version 21.2.0: Sun Nov 28 20:28:54 PST 2021; root:xnu-8019.61.5~1/RELEASE_X86_64 x86_64

### Subsystem

assert

### What steps will reproduce the bug?

```js
assert.deepEqual(new Proxy(['foo'], {}), ['foo']); // works properly
assert.deepEqual(new Proxy(['foo'], { ownKeys: (target) => Reflect.ownKeys(target) }), ['foo']) // throws

assert.deepStrictEqual(new Proxy(['foo'], {}), ['foo']); // works properly
assert.deepStrictEqual(new Proxy(['foo'], { ownKeys: (target) => Reflect.ownKeys(target) }), ['foo']) // throws
```
In the above, `Reflect.ownKeys(target)` should be the same as not setting an `ownKeys` trap, but it isn't.  The trap works fine elsewhere 

Indeed, 
```js
Reflect.ownKeys(['foo'])  // [ '0', 'length' ]
assert.deepEqual(new Proxy(['foo'], { ownKeys: (target) => ['0', 'length'] }), ['foo'])  // throws
```

### How often does it reproduce? Is there a required condition?

Every time

### What is the expected behavior?

Using a `ownKeys` trap shouldn't cause comparison errors.

The `ownKeys` trap seems to be working fine elsewhere.  I traced the code to:
https://github.com/nodejs/node/blob/dab8ab2837ae80b29678d882f2514b987e6764a0/lib/internal/util/comparisons.js#L179
Where the `GetOwnNonIndexProperties` function is called.  Perhaps it is incorrectly filtering or the filtering is broken for proxies somehow?

### What do you see instead?

Comparison errors from `assert.deepEquals` and `assert.deepStrictEquals` when the Arrays compared have the same content, but are using Proxies with `ownKeys` traps.

### Additional information

I tried this on node 14, 16, and 17, with the same results.","closed","itaylor",38120,"{confirmed-bug,assert,util,""v8 engine""}","https://github.com/nodejs/node/issues/41714",27,"Ambos",NULL,421,NULL,"A issue relata um problema na comparação de arrays com proxies usando o método `ownKeys`, afetando as funções `assert.deepEqual` e `assert.deepStrictEqual`.  A discussão nos comentários envolve a necessidade de corrigir um bug no V8 (motor JavaScript do Node.js) relacionado ao tratamento de índices em arrays com proxies, e também sugere a implementação de uma solução no Node.js para lidar com a incompatibilidade entre as funções `assert` e arrays com proxies.  Portanto, a issue abrange tanto a refatoração do código do Node.js para suportar melhor proxies quanto testes de regressão para garantir que as asserções funcionem corretamente com proxies, justificando a classificação 'Ambos'."
301,41450,"2022-01-09 01:18:43","2022-02-03 12:30:27","2022-02-03 12:30:27","structuredClone / atob / btoa should throw a TypeError without arguments","### Version

17.3.0

### Platform

MacOS 12.1

### Subsystem

global / buffer

### What steps will reproduce the bug?

```js
structuredClone(); // => undefined, should be a TypeError
atob(); // => 'ºw^~)Þ', should be a TypeError
btoa(); // => 'dW5kZWZpbmVk', should be a TypeError
```

### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior?

_No response_

### What do you see instead?

^

### Additional information

It's an inconsistency with web standards.","closed","zloirock",2213682,"{confirmed-bug,buffer,errors}","https://github.com/nodejs/node/issues/41450",14,"Ambos",NULL,25,NULL,"A issue relata um problema de inconsistência com padrões da web onde as funções `structuredClone`, `atob` e `btoa` não lançam um `TypeError` quando chamadas sem argumentos, como esperado.  Os comentários discutem a correção do comportamento, incluindo a adição de testes de regressão para verificar se as funções agora lançam a exceção correta (`TypeError`), e a refatoração do código para corrigir a inconsistência e se alinhar às especificações da web. A solução envolve tanto a adição de testes (Testes de Regressão) quanto a alteração do código para corrigir o comportamento incorreto (Refatoração)."
304,41202,"2021-12-16 18:46:02","2021-12-21 15:34:18","2021-12-21 15:34:18","async_hooks: fix AsyncLocalStorage in unhandledRejection cases","<!--
Before submitting a pull request, please read
https://github.com/nodejs/node/blob/HEAD/CONTRIBUTING.md.

Commit message formatting guidelines:
https://github.com/nodejs/node/blob/HEAD/doc/guides/contributing/pull-requests.md#commit-message-guidelines

For code changes:
1. Include tests for any bug fixes or new features.
2. Update documentation if relevant.
3. Ensure that `make -j4 test` (UNIX), or `vcbuild test` (Windows) passes.

Developer's Certificate of Origin 1.1

By making a contribution to this project, I certify that:

(a) The contribution was created in whole or in part by me and I
    have the right to submit it under the open source license
    indicated in the file; or

(b) The contribution is based upon previous work that, to the best
    of my knowledge, is covered under an appropriate open source
    license and I have the right under that license to submit that
    work with modifications, whether created in whole or in part
    by me, under the same open source license (unless I am
    permitted to submit under a different license), as indicated
    in the file; or

(c) The contribution was provided directly to me by some other
    person who certified (a), (b) or (c) and I have not modified
    it.

(d) I understand and agree that this project and the contribution
    are public and that a record of the contribution (including all
    personal information I submit with it, including my sign-off) is
    maintained indefinitely and may be redistributed consistent with
    this project or the open source license(s) involved.
-->

Right now async local storage doesn't properly propagate through unhandledRejections. This fixes that.","closed","bmeck",234659,"{confirmed-bug,process,promises,async_hooks,""author ready"",needs-ci}","https://github.com/nodejs/node/pull/41202",8,"Ambos","https://api.github.com/repos/nodejs/node/pulls/41202",5,NULL,"O título da issue sugere uma correção de bug ('fix'). O corpo menciona a inclusão de testes ('Include tests for any bug fixes or new features') e os comentários discutem problemas com os testes ('there is some kind of bug with the async id stack with this PR', 'I cannot write a test that covers all the branches...'), indicando que a issue envolve tanto refatoração (correção de bug) quanto testes de regressão (verificação da correção e impactos em outros componentes)."
306,40999,"2021-11-28 12:49:24","2022-07-14 11:05:50","2022-07-14 11:05:50","domain AsyncHook TypeError: Cannot read properties of undefined (again)","### Version

v16.13.0

### Platform

Linux t440p 5.4.0-89-generic #100-Ubuntu SMP Fri Sep 24 14:50:10 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

domain

### What steps will reproduce the bug?

Fairly minimal reproduction, `eval.js`:

```js
let createDomain = require(""domain"").create;
let vm = require(""vm"");

let context = vm.createContext({});
function eval(code) {
    let domain = createDomain();
    domain.run(() => {
      vm.runInContext(code, context)()
        .then(v => { console.log(v) })
        .catch(console.error);
    });
      
}
for (i = 0; i < 1000; i++) {
  eval(""async () => null"");
}
```

```
$ node --abort-on-uncaught-exception eval.js 
TypeError: Cannot read properties of undefined (reading 'enter')
    at AsyncHook.before (node:domain:97:20)
    at emitHook (node:internal/async_hooks:237:38)
    at emitBeforeScript (node:internal/async_hooks:503:5)
    at promiseBeforeHook (node:internal/async_hooks:347:3)
 1: 0xb02ec0 node::Abort() [node]
 2: 0xb76589  [node]
 3: 0xd4a18e  [node]
 4: 0xd4b5af v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) [node]
 5: 0x15e7959  [node]
Aborted (core dumped)
```

### How often does it reproduce? Is there a required condition?

The script runs without fault in node v12.22.7, but provokes failure reliably on stock node (as delivered by `nvm`) in versions:

* 14.18.0
* 16.13.0
* 17.1.0

Note that failure is only _sporadic_ if the number of evaluations scheduled (the upper bound of the `for` loop) is cut to, say, 100 or 500, and the script runs without fault when the number is set to something very small like 10.

### What is the expected behavior?

No failure, as in node v12.x.

### What do you see instead?

_No response_

### Additional information

A very similar-looking issue was reported in https://github.com/nodejs/node/issues/30122, but the script provided here _does_ work as expected in the failing version of node reported there (12.13.0).
","closed","cemerick",47489,"{confirmed-bug,domain,async_hooks}","https://github.com/nodejs/node/issues/40999",7,"Refatoração",NULL,228,NULL,"A issue descreve um erro (TypeError) relacionado ao uso de `domain`, `vm`, e `async/await` no Node.js, que leva a falhas em versões recentes (14.18.0, 16.13.0, 17.1.0), mas não em versões anteriores (12.22.7).  Um comentário sugere uma solução alternativa, que envolve adicionar um `setTimeout` antes de usar um `domain` recém-criado. Isso indica um problema de compatibilidade ou um bug em versões mais novas do Node.js, e a solução proposta é uma correção ou ajuste no código existente (refatoração) para contornar o problema, sem envolver novos testes de regressão. Os comentários discutem o problema e uma possível solução, mas não mencionam planos para adicionar testes de regressão."
341,38781,"2021-05-23 12:15:31","2021-06-02 14:57:58","2021-06-02 14:57:58","Promise hooks don't work well in vm contexts","After https://github.com/nodejs/node/pull/36394, the following test is broken:

```js
const vm = require('vm');
const { AsyncLocalStorage } = require('async_hooks')

const context = vm.createContext({
  AsyncLocalStorage,
  console,
});

vm.runInContext(`
  const storage = new AsyncLocalStorage()
  async function test() {
    return storage.run({ test: 'vm' }, async () => {
      console.log(storage.getStore());
      await 42;
      console.log(storage.getStore());
    });
  }
  test()
`, context);

const storage = new AsyncLocalStorage()
async function test() {
  return storage.run({ test: 'main context' }, async () => {
    console.log(storage.getStore());
    await 42;
    console.log(storage.getStore());
  });
}
test()
```

Node 16.1.0:
```
{ test: 'vm' }
{ test: 'main context' }
{ test: 'vm' }
{ test: 'main context' }
```

Node 16.2.0:
```
{ test: 'vm' }
{ test: 'main context' }
undefined
{ test: 'main context' }
```","closed","targos",2352663,"{confirmed-bug,async_hooks}","https://github.com/nodejs/node/issues/38781",17,"Ambos",NULL,10,"test broken node asynclocalstorage context
","A issue descreve um problema que afeta tanto a refatoração de como os Promise hooks funcionam em contextos de VM (o corpo da issue menciona 'test broken node asynclocalstorage context'), quanto testes de regressão, pois a quebra da funcionalidade resulta em uma regressão significativa nos testes com Jest ('problem break usage asynclocalstorage jest run test vm significant regression').  Comentários adicionais reforçam a necessidade de correções e a preocupação com a compatibilidade, indicando a necessidade de ambos os tipos de ações."
308,40794,"2021-11-12 17:42:48","2021-11-15 15:50:20","2021-11-15 15:50:20","crypto.sign swallows OpenSSL errors","### Version

current

### Platform

all

### Subsystem

crypto

### What steps will reproduce the bug?

```js
crypto.sign('sha512', '', crypto.generateKeyPairSync('rsa', { modulusLength: 512 }).privateKey)
```

### How often does it reproduce? Is there a required condition?

One of the internal OpenSSL calls must fail, in this case, due to incompatible digest and modulus length.

### What is the expected behavior?

A useful error message.

### What do you see instead?

```
Uncaught Error: Deriving bits failed
    at Object.signOneShot [as sign] (node:internal/crypto/sig:181:42)
```

### Additional information

_No response_","closed","tniessen",3109072,"{confirmed-bug,crypto}","https://github.com/nodejs/node/issues/40794",0,"Nenhum",NULL,3,NULL,"A issue descreve um bug onde a função `crypto.sign` não retorna uma mensagem de erro útil quando ocorre um erro interno no OpenSSL.  Não há menção a refatoração de código ou testes de regressão no título, descrição ou comentários. O foco é a correção de um comportamento inesperado do sistema."
310,40623,"2021-10-27 05:05:33","2022-06-12 09:45:01","2022-06-12 09:45:01","performance.timerify doesn't return wrapped function's return value","### Version

v16.13.0

### Platform

Darwin AC-MacBook-Pro.hsd1.ca.comcast.net 20.6.0 Darwin Kernel Version 20.6.0: Mon Aug 30 06:12:21 PDT 2021; root:xnu-7195.141.6~3/RELEASE_X86_64 x86_64 i386 MacBookPro16,1 Darwin

### Subsystem

performance

### What steps will reproduce the bug?

```
const perf = performance.timerify(function foo() {
    let sum = 0;
    for (let i = 0; i < 1000000; i++) {
        sum += i;
    }
    return sum;
});

const result = perf();
console.log(result);
```

### How often does it reproduce? Is there a required condition?

This reproduces deterministically.

### What is the expected behavior?

A number should be printed

### What do you see instead?

`foo {}`

### Additional information

_No response_","closed","acchou",1381213,"{confirmed-bug,perf_hooks}","https://github.com/nodejs/node/issues/40623",4,"Nenhum",NULL,228,NULL,"A issue descreve um bug em performance.timerify que não retorna o valor de retorno da função encapsulada.  Não há menção a refatoração de código ou testes de regressão. O foco é a correção de um comportamento inesperado do método, caracterizando um bug de implementação."
311,40612,"2021-10-26 15:14:27","2022-01-20 09:20:18","2022-01-20 09:20:18","ReadableStreamBYOBReader read() throws when given DataView","### Version

v17.0.1

### Platform

Darwin MrBBots-MBP 19.6.0 Darwin Kernel Version 19.6.0: Thu May  6 00:48:39 PDT 2021; root:xnu-6153.141.33~1/RELEASE_X86_64 x86_64

### Subsystem

stream

### What steps will reproduce the bug?

Running `node byob.mjs` with:

```js
// byob.mjs

import { ReadableStream } from ""stream/web"";

const stream = new ReadableStream({
  type: ""bytes"",
  start(controller) {
    controller.enqueue(new Uint8Array([1, 2, 3]));
    controller.close();
  },
});

const buffer = new ArrayBuffer(1024);
const reader = stream.getReader({ mode: ""byob"" });
const result = await reader.read(new DataView(buffer));
console.log(result);
```

...throws the following:

```
node:internal/webstreams/readablestream:1492
  return new ctor(transferredBuffer, byteOffset, bytesFilled / elementSize);
         ^

TypeError: ctor is not a constructor
    at readableByteStreamControllerConvertPullIntoDescriptor (node:internal/webstreams/readablestream:1492:10)
    at readableByteStreamControllerPullInto (node:internal/webstreams/readablestream:2145:9)
    at readableStreamBYOBReaderRead (node:internal/webstreams/readablestream:1717:3)
    at ReadableStreamBYOBReader.read (node:internal/webstreams/readablestream:881:5)
    at file:///.../byob.mjs:15:29
    at ModuleJob.run (node:internal/modules/esm/module_job:185:25)
    at async Promise.all (index 0)
    at async ESMLoader.import (node:internal/modules/esm/loader:281:24)
    at async loadESM (node:internal/process/esm_loader:88:5)
    at async handleMainPromise (node:internal/modules/run_main:65:12)
```

Replacing `new DataView` with `new Uint8Array` returns the expected output:

```
{ value: Uint8Array(3) [ 1, 2, 3 ], done: false }
```

### How often does it reproduce? Is there a required condition?

No required condition, throws every time

### What is the expected behavior?

Running the code in the latest Chrome (without the `import`) produces the following expected output:

```
{ value: DataView(3), done: false }
```

### What do you see instead?

See the stack trace above

### Additional information

_No response_","closed","mrbbot",15955327,"{confirmed-bug,""web streams""}","https://github.com/nodejs/node/issues/40612",0,"Nenhum",NULL,86,NULL,"A issue descreve um bug em um leitor de stream.  Não há menção a refatoração de código ou testes de regressão. O foco é a correção de um comportamento inesperado na manipulação de DataView com ReadableStreamBYOBReader. A solução sugerida envolve a substituição de DataView por Uint8Array para obter o resultado esperado, mas isso não se relaciona diretamente a refatoração ou testes de regressão."
312,40497,"2021-10-18 09:02:29","2021-10-19 13:55:22","2021-10-19 13:55:22","Duplex.from failure","```js
  pipeline(
    Readable.from('abc\ndef\nghi'),
    Duplex.from(async function * (source) {
      let rest = ''
      for await (const chunk of source) {
        const lines = (rest + chunk.toString()).split('\n')
        rest = lines.pop()
        for (const line of lines) {
          yield line
        }
      }
      yield rest
    }),
    async function * (source) {
      let ret = ''
      for await (const x of source) {
        ret += x
      }
      assert.strictEqual(ret, 'abcdefghi')
    },
    common.mustCall(() => {}),
  )
```

Replace `Duplex.from(arg) with arg` and it works...","closed","ronag",3065230,"{confirmed-bug,stream}","https://github.com/nodejs/node/issues/40497",0,"Refatoração",NULL,1,NULL,"O corpo da issue sugere uma refatoração do código, propondo a substituição de `Duplex.from(arg)` por `arg` para corrigir um problema.  A descrição foca na alteração estrutural do código, sem menção explícita a testes de regressão."
317,40191,"2021-09-23 16:17:02","2021-10-20 11:51:26","2021-10-20 11:51:26","stream.promises.pipeline doesn't support arrays of streams since node 16.10","### Version

v16.10.0

### Platform

5.8.0-63-generic #71-Ubuntu SMP Tue Jul 13 15:59:12 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

stream/promises

### What steps will reproduce the bug?

```javascript
'use strict';

const {pipeline} = require('stream/promises');

(async () => {
    await pipeline([
        async function * () {
            yield 'a';
            yield 'b';
            yield 'c';
        },
        async function (source) {
            for await (const chunk of source) {
               console.log(chunk)
            }
        }
    ]);
})();
```

### How often does it reproduce? Is there a required condition?

Always in 16.10, never in 16.9

### What is the expected behavior?

It should output:
```
a
b
c
```

### What do you see instead?

```
node:internal/errors:464
    ErrorCaptureStackTrace(err);
    ^

TypeError [ERR_MISSING_ARGS]: The ""streams"" argument must be specified
    at new NodeError (node:internal/errors:371:5)
    at pipelineImpl (node:internal/streams/pipeline:181:11)
    at node:stream/promises:26:5
    at new Promise (<anonymous>)
    at pipeline (node:stream/promises:17:10)
    [...] {
  code: 'ERR_MISSING_ARGS'
}
```

### Additional information

Starting with node 16.10, the promise version of `pipeline` doesn't handle this signature:`pipeline(streams)`, where `streams` is `<Stream[]> | <Iterable[]> | <AsyncIterable[]> | <Function[]>` according to the documentation. 
I think the problem is related with the introduction of the `signal` parameter, possibly with this change: https://github.com/nodejs/node/commit/97f3072ceb#diff-241fa22640048b6a147dec92f1ebf253043a1c4c342c7e52402112eb3c58f8fbL35
The callback version of `stream.pipeline` is not affected.
Related PR :
- https://github.com/nodejs/node/pull/37359
- https://github.com/nodejs/node/pull/39067","closed","darksabrefr",17409537,"{confirmed-bug,stream}","https://github.com/nodejs/node/issues/40191",0,"Nenhum",NULL,27,NULL,"A issue descreve um bug em uma versão específica do Node.js (16.10.0) relacionado ao funcionamento da função `stream.promises.pipeline` com arrays de streams.  Não há menção à refatoração de código ou a testes de regressão. O foco é a identificação e resolução de um problema de funcionamento da biblioteca."
324,39919,"2021-08-27 22:29:47","2022-05-25 12:24:28","2022-05-25 12:24:28","Invalid HTTP/2 origin set when servername is empty","### Version

v16.8.0

### Platform

Linux solus 5.13.12-193.current #1 SMP PREEMPT Fri Aug 20 14:21:44 UTC 2021 x86_64 GNU/Linux

### Subsystem

http2

### What steps will reproduce the bug?

```js
const http2 = require('http2');

const session = http2.connect('https://1.1.1.1', {servername: ''});
session.once('remoteSettings', () => {
  console.log(session.originSet);

  session.close();
});
```

### How often does it reproduce? Is there a required condition?

Always.

### What is the expected behavior?

```
[ 'https://1.1.1.1' ]
```

### What do you see instead?

```
[ 'https://false' ]
```

### Additional information

```js
const http2 = require('http2');

const session = http2.connect('https://1.1.1.1');
session.once('remoteSettings', () => {
  console.log(session.originSet);

  session.close();
});
```

gives a warning

```
(node:36333) [DEP0123] DeprecationWarning: Setting the TLS ServerName to an IP address is not permitted by RFC 6066. This will be ignored in a future version.
(Use `node --trace-deprecation ...` to show where the warning was created)
[ 'https://1.1.1.1' ]
```

/cc @ronag","closed","szmarczak",36894700,"{confirmed-bug,http2}","https://github.com/nodejs/node/issues/39919",2,"Refatoração",NULL,271,"version v16.8 platform linux solus subsystem http2 step reproduce bug connect servername expect behavior https additional information give warning deprecation warning set tls servername ip address permit rfc ignore future version
","O título e corpo da issue sugerem uma correção de um comportamento inesperado relacionado à configuração do servidor HTTP/2 quando o nome do servidor está vazio.  Os comentários indicam uma tentativa de consertar o bug ('fix bug') e uma discussão sobre o comportamento esperado, sugerindo uma alteração no código para corrigir o problema sem necessariamente adicionar novos testes, o que caracteriza uma refatoração."
320,40014,"2021-09-06 10:57:32","2023-10-27 14:45:19","2023-10-27 14:45:19","`vm` `Script` memory leak in Node.js 14 / 16","### Version

14 / 16

### Platform

x64 macOS / Linux

### Subsystem

vm

### What steps will reproduce the bug?

```js
'use strict';

let times = 0;

function run() {
  let str = 'var a = ""';
  for (let i = 0; i < 100 * 1024 / 18; i++) str += Math.random().toString();
  str += '"";';

  const script = new (require('vm').Script)(str);
  times++;
  if (times % 1000 === 0) console.log(times);
}

(async () => {
  while (true) {
    run();

    await new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, 10);
    });

    gc();
  }
})();
```

Run with:

```bash
$ node --expose-gc --max-heap-size=100 test.js
```

It will occur heap OOM under Node.js 14 and 16, and **Node.js 12 is OK**.

```
<--- Last few GCs --->                                                         
                                                                                                                                                               
[1430950:0x55695b1dc4b0]     6372 ms: Mark-sweep 72.0 (91.6) -> 71.6 (91.8) MB, 4.3 / 0.0 ms  (average mu = 0.728, current mu = 0.778) testing GC in old space requested
[1430950:0x55695b1dc4b0]     6388 ms: Mark-sweep 72.2 (91.8) -> 71.8 (92.1) MB, 3.1 / 0.0 ms  (average mu = 0.760, current mu = 0.804) testing GC in old space requested
[1430950:0x55695b1dc4b0]     6403 ms: Mark-sweep 72.4 (92.1) -> 72.0 (92.3) MB, 2.9 / 0.0 ms  (average mu = 0.781, current mu = 0.806) testing GC in old space requested
                                                                                                                                                               
                                                                               
<--- JS stacktrace --->                                                                                                                                        
                                                                               
FATAL ERROR: MarkCompactCollector: young object promotion failed Allocation failed - JavaScript heap out of memory  
```

### How often does it reproduce? Is there a required condition?

Every time.

### What is the expected behavior?

Not OOM.

### What do you see instead?

OOM.

### Additional information

_No response_","closed","XadillaX",2842176,"{confirmed-bug,vm,""v8 engine""}","https://github.com/nodejs/node/issues/40014",29,"Refatoração",NULL,781,"node js heap oom memory allocation fail markcompactcollector young object promotion  every time
","A issue relata um vazamento de memória (`vm` `Script` memory leak) em Node.js.  As soluções propostas e as discussões nos comentários se concentram em modificar o código (refatoração) para corrigir o problema de alocação de memória e gerenciamento de garbage collection, incluindo mudanças em como o `vm.Script` é usado.  Não há menção direta a testes de regressão, embora a correção de um bug possa implicar em sua execução posteriormente. A ênfase principal é na alteração do código para resolver o problema de vazamento de memória,  característica central da refatoração."
322,39936,"2021-08-29 21:24:12","2021-09-01 06:21:44","2021-09-01 06:21:44","RSA-PSS key pair generation incorrectly adds params since v15","### Version

≥ 15.0.0

### Platform

Any

### Subsystem

crypto

### What steps will reproduce the bug?

```
node -p ""crypto.generateKeyPairSync('rsa-pss', { modulusLength: 2048 }).publicKey.export({ format: 'pem', type: 'spki' })"" | openssl asn1parse
```

### How often does it reproduce? Is there a required condition?

Always.

### What is the expected behavior?

```
    0:d=0  hl=4 l= 288 cons: SEQUENCE          
    4:d=1  hl=2 l=  11 cons: SEQUENCE          
    6:d=2  hl=2 l=   9 prim: OBJECT            :rsassaPss
   17:d=1  hl=4 l= 271 prim: BIT STRING
```

### What do you see instead?

```
    0:d=0  hl=4 l= 295 cons: SEQUENCE          
    4:d=1  hl=2 l=  18 cons: SEQUENCE          
    6:d=2  hl=2 l=   9 prim: OBJECT            :rsassaPss
   17:d=2  hl=2 l=   5 cons: SEQUENCE          
   19:d=3  hl=2 l=   3 cons: cont [ 2 ]        
   21:d=4  hl=2 l=   1 prim: INTEGER           :00
   24:d=1  hl=4 l= 271 prim: BIT STRING
```

### Additional information

Likely caused by https://github.com/nodejs/node/pull/35093.","closed","tniessen",3109072,"{confirmed-bug,crypto}","https://github.com/nodejs/node/issues/39936",0,"Refatoração",NULL,2,"node p crypto generateKeyPairSync rsa pss modulusLength 2048 publicKey export format pem type spki openssl asn1parse sempre sequence object rsassaPss bit string sequence sequence object rsassaPss sequence cont integer caus likely github nodejs node pull
","O título da issue ""RSA-PSS key pair generation incorrectly adds params since v15"" e a descrição mencionam a correção de um problema na geração de pares de chaves RSA-PSS.  A menção a versões (""since v15"") e a descrição do problema sugerem uma refatoração para corrigir um comportamento incorreto, sem foco direto em testes de regressão, embora estes sejam provavelmente necessários após a refatoração."
323,39929,"2021-08-29 13:01:23","2021-09-08 19:15:37","2021-09-08 19:15:37","`await` an expression with surrogate characters raises a `SyntaxError`","### Version

16.8.0

### Platform

_No response_

### Subsystem

repl

### What steps will reproduce the bug?

```js
$ node
Welcome to Node.js v16.8.0.
Type "".help"" for more information.
> await '😀😀😀' // or
> await '😀😀😀'; // or
> await '😀😀😀';;
```

### How often does it reproduce? Is there a required condition?

All the time, as long as there is a top level await with one or more surrogate chars with a semicolon, or at least 3 surrogate chars.

### What is the expected behavior?

```js
> await '😀😀😀'
'😀😀😀'
```

### What do you see instead?

```js
> await '😀😀😀'
 }))()
 ^

Uncaught SyntaxError: Unexpected token '}'

> await '😀😀😀';
(async () => { return (await '😀😀😀';
                                     ^

Uncaught SyntaxError: Unexpected token ';'

> await '😀😀😀';;
undefined
```

### Additional information

This is obviously reproducible with a more complex expression (for example `await new buffer.Blob(['aaa', Buffer.from('èèee😁😁😁aaa')]).text()`.","closed","Mesteery",48163546,"{confirmed-bug,repl}","https://github.com/nodejs/node/issues/39929",4,"Nenhum",NULL,10,"node await surrogate char semicolon syntaxerror unexpected token
","O título e o corpo da issue não mencionam refatoração ou testes de regressão. Os comentários também não fornecem evidências de que a issue esteja relacionada a essas categorias.  A issue parece descrever um erro de sintaxe relacionado a caracteres substitutos em Node.js, o que não se enquadra nas categorias especificadas."
329,39743,"2021-08-12 01:05:46","2021-08-29 12:18:54","2022-06-18 20:25:34","[v14.x backport] deps: V8: cherry-pick 81814ed44574","Original commit message:

    [promise] Avoid stack overflow with context promise hooks in C++

    This was handled in JS but not in C++.

    Bug: chromium:236703, v8:11025
    Change-Id: Ic9adc4ceb4d2af2614427fec459c3e950654572f
    Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/3074460
    Commit-Queue: Camillo Bruni <cbruni@chromium.org>
    Reviewed-by: Victor Gomes <victorgomes@chromium.org>
    Cr-Commit-Position: refs/heads/master@{#76125}

Refs: https://github.com/v8/v8/commit/81814ed44574dbdb19ad22857220ac81fba5c107

PR-URL: https://github.com/nodejs/node/pull/39719
Reviewed-By: Michaël Zasso <targos@protonmail.com>
Reviewed-By: Richard Lau <rlau@redhat.com>
Reviewed-By: Anna Henningsen <anna@addaleax.net>","closed","Qard",205482,"{confirmed-bug,c++,build,""v8 engine"",promises,async_hooks,""author ready"",needs-ci}","https://github.com/nodejs/node/pull/39743",13,"Ambos","https://api.github.com/repos/nodejs/node/pulls/39743",17,"avoid stack overflow context promise hook c++ handle js bug change commit queue camillo bruni victor gomes commit position refs head master
","O título da issue menciona ""deps"" (dependências), sugerindo refatoração.  Os comentários incluem menções explícitas a testes ('V8 CI teste linux', 'test failure change land sure', 'run make test v8 locally', 'test'), e correções de bugs ('js bug', 'correctness check error'), indicando a necessidade de testes de regressão. A combinação de refatoração de dependências e a necessidade subsequente de testes de regressão justificam a classificação 'Ambos'."
330,39719,"2021-08-09 16:46:06","2021-08-11 17:44:15","2021-08-29 12:13:54","deps: V8: cherry-pick 81814ed44574","Original commit message:

    [promise] Avoid stack overflow with context promise hooks in C++

    This was handled in JS but not in C++.

    Bug: chromium:236703, v8:11025
    Change-Id: Ic9adc4ceb4d2af2614427fec459c3e950654572f
    Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/3074460
    Commit-Queue: Camillo Bruni <cbruni@chromium.org>
    Reviewed-by: Victor Gomes <victorgomes@chromium.org>
    Cr-Commit-Position: refs/heads/master@{#76125}

Refs: https://github.com/v8/v8/commit/81814ed44574dbdb19ad22857220ac81fba5c107","closed","Qard",205482,"{confirmed-bug,build,""v8 engine"",promises,async_hooks,""author ready"",needs-ci}","https://github.com/nodejs/node/pull/39719",4,"Refatoração","https://api.github.com/repos/nodejs/node/pulls/39719",2,"promise avoid stack overflow context promise hook c++ handle js bug change commit queue camillo bruni victor gomes cr commit position ref
","O título e o corpo da issue sugerem uma alteração na dependência V8 (deps: V8), com menção a correção de bug ('js bug'),  'handle' e  modificações no gerenciamento de pilha ('promise avoid stack overflow').  Não há menção explícita a testes de regressão."
332,39447,"2021-07-19 14:42:48","2021-08-11 13:28:07","2021-08-11 13:28:07","stream.pipeline does not invoke callback when error happens","### Version

v15.8.0

### Platform

Darwin Alekseys-iMac.local 20.5.0 Darwin Kernel Version 20.5.0: Sat May  8 05:10:33 PDT 2021; root:xnu-7195.121.3~9/RELEASE_X86_64 x86_64

### Subsystem

stream

### What steps will reproduce the bug?

Run the following code:

```js
'use strict'

const { Transform, pipeline } = require('stream')

function createTransformStream (tf, context) {
  return new Transform({
    readableObjectMode: true,
    writableObjectMode: true,

    transform (chunk, encoding, done) {
      tf(chunk, context, done)
    }
  })
}

const ts = createTransformStream((chunk, _, done) => done(new Error('Artificial error')))

pipeline(ts, process.stdout, (err) => {
  if (err) console.log(err)
  console.log('done')
})

console.log('run test')
ts.write('test')
```

### How often does it reproduce? Is there a required condition?

all the time

### What is the expected behavior?

I expect `pipeline` callback to be called with error argument. So I'll have the output like this:

```
run test
Error: Artificial error
    at /Users/hackerman/Documents/code/wave/demo.js:16:59
    at Transform.transform [as _transform] (/Users/hackerman/Documents/code/wave/demo.js:11:7)
    at Transform._write (node:internal/streams/transform:184:23)
    at writeOrBuffer (node:internal/streams/writable:400:12)
    at _write (node:internal/streams/writable:341:10)
    at Transform.Writable.write (node:internal/streams/writable:345:10)
    at Object.<anonymous> (/Users/hackerman/Documents/code/wave/demo.js:24:4)
    at Module._compile (node:internal/modules/cjs/loader:1105:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1137:10)
    at Module.load (node:internal/modules/cjs/loader:973:32)
done
```

### What do you see instead?

`pipeline` callback is not called. Output that I have:

```
run test
```

### Additional information

When I run mentioned code with `--inspect-brk` flag — I can achieve expected behaviour in google chrome console. Steps:
- run `node --inspect-brk demo.js`
- open `chrome://inspect/#devices` in chrome
- click inspect and resume script execution","closed","mightyaleksey",5006221,"{confirmed-bug,stream,""good first issue""}","https://github.com/nodejs/node/issues/39447",20,"Ambos",NULL,23,"run code expect pipeline callback call error argument output run test error artificial error done pipeline callback call output run test  run code inspect brk flag achieve expected behavior google chrome console run node inspect brk demo js open chrome inspect devices click inspect resume script execution
","A issue descreve um problema onde o callback do pipeline não é chamado quando ocorre um erro (problema de funcionalidade).  Há menções a adição de testes ('add test stdout', 'test process stdout', 'run test artificial error', 'run test'), e também à refatoração do código para corrigir o problema ('change pass test case describe ref', 'work issue locate entry point stream transformer put test test folder execution happen exist mechanism execution',  'fix pipeline process stdout'). A combinação de correção de bug e adição/modificação de testes indica que a issue envolve ambos os aspectos."
334,39224,"2021-07-01 16:03:44","2021-07-05 17:51:21","2022-09-30 20:05:57","Install directory permissions broken on non-English Windows systems","* **Version**: 16.4.1
* **Platform**: Windows

### What steps will reproduce the bug?

- Install Node v16.4.1 on a non-English Windows system.

### How often does it reproduce? Is there a required condition?

It always reproduces as far as I can tell.

### What do you see?

![afbeelding](https://user-images.githubusercontent.com/954385/124154188-8cac0c80-da95-11eb-8bf9-c853b1ca0fc8.png)

### Additional information

I presume this bug was introduced in e817ba70f56c4bfd5d4a68dce8b165142312e7b6.

Core issue seems to be that Windows localizes names of built-in users and groups. On my non-English Windows system, there does not exist a group called ""Authenticated Users"". It exists using a localized name. Hence, the solution implemented in that commit will never work on non-English Windows systems.

Instead, we should probably use a SID to reference the correct group. See https://support.microsoft.com/kb/243330.

EDIT: Presumably also affects v14.17.2 and v12.22.2, as these seem to include this same change. Haven't checked.

EDIT2: To clarify; this completely breaks Node.js installs, make it unable to complete installation, and when upgrading will leave Node.js in a broken state.","closed","DvdGiessen",954385,"{confirmed-bug,windows,install}","https://github.com/nodejs/node/issues/39224",53,"Ambos",NULL,4,"instalacao node windows falha sistema nao ingles grupo usuario autenticado localizado solucao commit funcionar sistema nao ingles usar sid referencia grupo correto problema interromper instalacao node deixar estado quebrado versao afetada
","A issue relata problemas de instalação em sistemas Windows não ingleses (Refatoração, pois envolve mudanças na instalação para corrigir um problema),  e há vários comentários mencionando problemas de atualização e testes com diferentes versões (Testes de Regressão, pois usuários estão testando diferentes versões após a correção do problema original)."
336,39149,"2021-06-25 06:13:07","2022-08-27 02:53:10","2022-08-27 02:53:11","Missing source marker on error throw by vm module with `--enable-source-maps`","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: `14.17.0`, `16.1.0`, `16.4.0` and very likely all between
* **Platform**: Microsoft Windows NT 10.0.19042.0 x64
* **Subsystem**: vm

### What steps will reproduce the bug?

```js
const {Script} = require('vm');
try {
  const script = new Script(`Math.max(a, b`, {filename: 'main'});
} catch (error) {
  console.log(error.stack);
}
```

Executing the snippet will display the source code line with the marker `^` where the error happened:
```
main:1
Math.max(a, b
            ^

SyntaxError: missing ) after argument list
    at new Script (vm.js:101:7)
    ...
```

But when executing node with `--enable-source-maps` the source code line with the marker is not displayed:
```
SyntaxError: missing ) after argument list
    at new Script (vm.js:101:7)
    ...
```
<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->

### How often does it reproduce? Is there a required condition?
It does always reproduce. I have tested on node `14.17.0`, `16.1.0` and `16.4.0`.

### What is the expected behavior?

Always display the source location with the marker `^` no matter whether `--enable-source-maps` is set or not.

<!--
If possible please provide textual output instead of screenshots.
-->

### What do you see instead?

<!--
If possible please provide textual output instead of screenshots.
-->

### Additional information

On node 14.16.1 the source code line with the marker is always displayed no matter whether `--enable-source-maps` is set or not. I have looked into the Changelog and I think that maybe #33491 has introduced this bug.

<!--
Tell us anything else you think we should know.
-->
","closed","sonallux",13821543,"{confirmed-bug,""help wanted"",""source maps""}","https://github.com/nodejs/node/issues/39149",7,"Nenhum",NULL,428,"version 14.17.0 16.1.0 16.4.0 likely platform microsoft windows nt 10.0.19042.0 x64 subsystem vm step reproduce bug script math.max a b syntaxerror missing argument list execute snippet display source code line marker syntaxerror missing argument list execute node enable source map source code line marker display expected behavior always display source location marker enable source map set see instead additional information node 14.16.1 source code line marker always display enable source map set bug
","A issue descreve um bug relacionado à exibição de marcadores de origem em mensagens de erro do módulo `vm` do Node.js, quando usado com `--enable-source-maps`.  Os comentários discutem a investigação e a correção do bug, mas não há menção a refatoração de código ou testes de regressão.  O foco é exclusivamente na correção de um problema de funcionalidade."
337,38936,"2021-06-05 01:34:09","2021-06-06 09:48:18","2021-06-06 09:48:19","Repl crashes when used with AsyncLocalStorage","* **Version**: v16.2.0 (also reproduces on v16.3.0, but not v16.1.0)
* **Platform**: Darwin [host] 18.6.0 Darwin Kernel Version 18.6.0: Thu Apr 25 23:16:27 PDT 2019; root:xnu-4903.261.4~2/RELEASE_X86_64 x86_64
* **Subsystem**: Not sure

### What steps will reproduce the bug?

Run the following script with `node repro.js`:
```js
// repro.js
'use strict';

const Repl = require('repl');
const { AsyncLocalStorage } = require('async_hooks');

new AsyncLocalStorage().run({}, async () => {

    Repl.start();

    await new Promise(process.nextTick);
});
```

The process crashes after the repl prompt `> ` is printed, and a stacktrace from C-land is produced: see the output below.

### How often does it reproduce? Is there a required condition?

Given the info above it consistently reproduces on node v16.2.0 and v16.3.0, but not on any of the previous versions of node v16.

### What is the expected behavior?

The repl should appear, and the rest of the callback passed to `run()` should execute.  The process should not exit until the user exits the repl.

### What do you see instead?

This is the output from the reproduction script shown above.  The process crashes near-immediately, but you can see that the repl prompt `> ` is output.

```
> node[90057]: ../src/api/callback.cc:125:void node::InternalCallbackScope::Close(): Assertion `(env_->execution_async_id()) == (0)' failed.
 1: 0x106e127e5 node::Abort() (.cold.1) [/path/to/node]
 2: 0x105ac5b39 node::Abort() [/path/to/node]
 3: 0x105ac59a1 node::Assert(node::AssertionInfo const&) [/path/to/node]
 4: 0x1059f5cdd node::InternalCallbackScope::Close() [/path/to/node]
 5: 0x1059f55de node::InternalCallbackScope::~InternalCallbackScope() [/path/to/node]
 6: 0x105b331db node::PerIsolatePlatformData::RunForegroundTask(std::__1::unique_ptr<v8::Task, std::__1::default_delete<v8::Task> >) [/path/to/node]
 7: 0x105b31ca7 node::PerIsolatePlatformData::FlushForegroundTasksInternal() [/path/to/node]
 8: 0x1064bec03 uv__async_io [/path/to/node]
 9: 0x1064d287c uv__io_poll [/path/to/node]
10: 0x1064bf171 uv_run [/path/to/node]
11: 0x1059f6ea4 node::SpinEventLoop(node::Environment*) [/path/to/node]
12: 0x105b07414 node::NodeMainInstance::Run(node::EnvSerializeInfo const*) [/path/to/node]
13: 0x105a9397d node::Start(int, char**) [/path/to/node]
14: 0x7fff793ca3d5 start [/usr/lib/system/libdyld.dylib]
15: 0x2 
[1]    90057 abort      node repro.js
```

### Additional information

This was originally observed when using [hpal-debug](https://github.com/hapipal/hpal-debug)'s repl, which is run under async local storage.  I think that's about it, but happy to provide any more information!
","closed","devinivy",3150233,"{confirmed-bug,async_hooks}","https://github.com/nodejs/node/issues/38936",4,"Nenhum",NULL,1,"node repl crash async local storage assertion fail  callback close process exit repl prompt  version v16.2 v16.3  platform darwin  subsystem unsure  reproduction script node repro js  consistent reproduce v16.2 v16.3  expected behavior repl appear callback execute process exit user exit repl  unexpected behavior process crash repl prompt output stacktrace c land  additional information hpal debug async local storage
","A issue descreve um crash no REPL do Node.js ao usar AsyncLocalStorage.  Não há menção a refatoração de código ou testes de regressão. O foco é a resolução de um bug de funcionamento."
338,38912,"2021-06-03 05:27:03","2021-06-05 19:22:39","2021-08-03 08:22:23","async_hooks: switch between native and context hooks correctly","🤦  Might help if I remember to disable the _other_ promise
hook implementation when switching between them...

Fixes #38814
Fixes #38815
","closed","Qard",205482,"{confirmed-bug,async_hooks,""author ready"",needs-ci}","https://github.com/nodejs/node/pull/38912",13,"Ambos","https://api.github.com/repos/nodejs/node/pulls/38912",3,"disable promise hook implementation switch
","A issue contém menções a testes de regressão ('regression test nice', 'add regression test', 'restructure test work correctly worker test') e também sugere refatoração ('disable promise hook implementation switch', 'restructure test work correctly worker test')."
340,38790,"2021-05-23 16:11:28","2021-06-28 19:36:16","2022-08-03 15:48:15","--enable-source-maps causes ""TypeError [ERR_INVALID_URL]"" in  esm/resolve","* **Version**: v16.2.0
* **Platform**: Linux

### What steps will reproduce the bug?

<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->

```javascript
// index.js
import { Something } from './something.js';
```
```javascript
// something.js
// Empty file, does NOT export `Something`
```

```json5
// package.json
{
  ""type"": ""module""
}
```

To reproduce:

- `node index.js` (throws a SyntaxError, this is expected behavior :+1:)
- `node --enable-source-maps index.js` (throws  TypeError [ERR_INVALID_URL], unexpected behavior :-1:)

### What is the expected behavior?

<!--
If possible please provide textual output instead of screenshots.
-->

```
$ node index.js

import { Something } from './something.js';
         ^^^^^^^^^
SyntaxError: The requested module './something.js' does not provide an export named 'Something'
    at ModuleJob._instantiate (node:internal/modules/esm/module_job:121:21)
    at async ModuleJob.run (node:internal/modules/esm/module_job:171:5)
    at async Loader.import (node:internal/modules/esm/loader:178:24)
    at async Object.loadESM (node:internal/process/esm_loader:68:5)

```

### What do you see instead?

<!--
If possible please provide textual output instead of screenshots.
-->

```
$ node --enable-source-maps index.js

TypeError [ERR_INVALID_URL]: Invalid URL
    at __node_internal_captureLargerStackTrace (node:internal/errors:456:5)
    at __node_internal_addCodeToName (node:internal/errors:191:9)
    at new NodeError (node:internal/errors:363:5)
    at onParseError (node:internal/url:537:9)
    at new URL (node:internal/url:613:5)
    at getPackageScopeConfig (node:internal/modules/esm/resolve:177:24)
    at packageResolve (node:internal/modules/esm/resolve:657:25)
    at moduleResolve (node:internal/modules/esm/resolve:739:18)
    at Loader.defaultResolve [as _resolve] (node:internal/modules/esm/resolve:853:11)
    at Loader.resolve (node:internal/modules/esm/loader:89:40)
    at ModuleJob._instantiate (node:internal/modules/esm/module_job:137:31)
    at async ModuleJob.run (node:internal/modules/esm/module_job:171:5)
    at async Loader.import (node:internal/modules/esm/loader:178:24)
    at async Object.loadESM (node:internal/process/esm_loader:68:5) {
  input: './package.json',
  code: 'ERR_INVALID_URL'
```

### Additional information

<!--
Tell us anything else you think we should know.
-->

A cursory review tracked this to [ModuleJob._instantiate in esm/module_job.js](https://github.com/nodejs/node/blob/dc43066ee9a37655bcf8a391a594a17fd5d03140/lib/internal/modules/esm/module_job.js#L128).

The code seems to expect a full path as the first element in the array, but when `--enable-source-maps` is on, the stack does not have this path.

As a result, the full error message is passed down into `esm/resolve` instead of a pathname, resulting in an Invalid URL.
","closed","maxholman",250517,"{confirmed-bug,""source maps""}","https://github.com/nodejs/node/issues/38790",5,"Nenhum",NULL,36,"node enable source map unexpected behavior syntaxerror requested module provide export named something typeerror err invalid url invalid url expect full path array enable source map stack path full error message pass esm resolve pathname result invalid url
","A issue descreve um erro (""TypeError [ERR_INVALID_URL]"") ao usar a flag '--enable-source-maps'. Os comentários discutem a solução do problema (remover a flag ou usar uma versão diferente), mas não há menção explícita à refatoração de código ou à execução de testes de regressão.  O foco é na correção de um bug específico, sem envolver mudanças estruturais no código ou testes sistêmicos."
343,38695,"2021-05-15 10:54:41","2023-09-14 15:48:08","2023-09-14 15:48:08","SEGFAULT in REPL","REPL crashes when doing a dynamic import when the working directory contains a folder with the name `src`:

```console
$ mkdir repro
$ cd repro
$ mkdir src
$ node
Welcome to Node.js v16.1.0.
Type "".help"" for more information.
> const fn = () => import('crypto')
undefined
> fn('')
Promise { <pending> }
> undefined
undefined
> fn('')
[1]    59895 segmentation fault  node
$ node_master
Welcome to Node.js v17.0.0-pre.
Type "".help"" for more information.
> const fn = () => import('crypto')
undefined
> fn('')
[1]    59992 segmentation fault  ../../node/out/Release/node
$ node_master
Welcome to Node.js v17.0.0-pre.
Type "".help"" for more information.
> const fn = () => import('crypto')
undefined
> fn('')
Promise { <pending> }
> fn('')
Promise { <pending> }
> fn('')
Promise { <pending> }
> fn('')
Promise { <pending> }
> fn('')
[1]    59997 segmentation fault  ../../node/out/Release/node
```

Here's the info given by `lldb` when the process crashes:

```
Process 59603 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x18)
    frame #0: 0x000000010008a952 node`node::loader::ImportModuleDynamically(v8::Local<v8::Context>, v8::Local<v8::ScriptOrModule>, v8::Local<v8::String>, v8::Local<v8::FixedArray>) + 489
node`node::loader::ImportModuleDynamically:
->  0x10008a952 <+489>: movq   0x18(%rax), %rcx
    0x10008a956 <+493>: movq   0x8(%rcx), %rax
    0x10008a95a <+497>: testq  %rax, %rax
    0x10008a95d <+500>: movq   -0x58(%rbp), %rbx
Target 0: (node) stopped.
```

The crash also happen with a module other than `crypto`.



_Originally posted by @rayfoss in https://github.com/nodejs/node/issues/38090#issuecomment-841427433_","closed","aduh95",14309773,"{confirmed-bug,repl,esm}","https://github.com/nodejs/node/issues/38695",2,"Nenhum",NULL,852,"repl crash dynamic import working directory folder name src node segmentation fault importmoduledynamically exc_bad_access module crypto
","A issue descreve um segmentation fault (SEGFAULT) no REPL durante a importação dinâmica de um módulo.  Os comentários descrevem tentativas de depuração e uma possível solução, mas não há menção explícita a refatoração ou testes de regressão.  O problema parece ser um bug no próprio sistema, não relacionado a atividades de refatoração ou testes."
344,38683,"2021-05-13 21:32:18","2021-05-25 14:18:24","2021-12-20 10:41:29","rmSync does not throw error if file exists but cannot be deleted.","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: v14.17.0 and v16.1.0
* **Platform**: Darwin Randalls-iMac.fios-router.home 20.4.0 Darwin Kernel Version 20.4.0: Thu Apr 22 21:46:47 PDT 2021; root:xnu-7195.101.2~1/RELEASE_X86_64 x86_64 (macOS 11.3.1)
* **Subsystem**: filesystem

### What steps will reproduce the bug?

`fs.rmSync` does not error if file exists, but cannot be deleted because parent directory is readonly. The file remains, but no error is thrown. (Note that `fs.rm` works as expected.)

I expect the following code to emit an EACCES error, but it does not:
```js
import * as nodefs from 'fs'

nodefs.mkdirSync('tmp')
nodefs.writeFileSync('tmp/file', 'A file.')
nodefs.chmodSync('tmp', '500')
nodefs.rmSync('tmp/file' {force: true})
```

However, this code does emit that error:
```js
import * as nodefs from 'fs'

nodefs.mkdirSync('tmp')
nodefs.writeFileSync('tmp/file', 'A file.')
nodefs.chmodSync('tmp', '500')
nodefs.rm('tmp/file', {force: true}, function(err) {
    if (err) console.error(err)
})
```
as does:
```js
import * as nodefs from 'fs'
import * as promisefs from 'fs/promises'

nodefs.mkdirSync('tmp')
nodefs.writeFileSync('tmp/file', 'A file.')
nodefs.chmodSync('tmp', '500')
promisefs.rm('tmp/file', {force: true})
```

### How often does it reproduce? Is there a required condition?

Always reproducible.

### What is the expected behavior?

The file is not deleted, and the error is emitted:
```js
[Error: EACCES: permission denied, unlink 'tmp/file'] {
  errno: -13,
  code: 'EACCES',
  syscall: 'unlink',
  path: 'tmp/file'
}
```

### What do you see instead?

The file is not deleted, but no error is emitted.

### Additional information

The commands `mkdir tmp ; touch tmp/file ; chmod 500 tmp ; rm -f tmp/file` show the expected result `rm: tmp/file: Permission denied` and the file is not deleted.

I believe Linux systems also exhibit this, but have not explicitly tested this minimal reproducible example on Linux.","closed","rhwood",297232,"{confirmed-bug,fs}","https://github.com/nodejs/node/issues/38683",5,"Ambos",NULL,12,"fs rmsync error file exist parent directory readonly file remain error throw fs rm work expect code emit eacces error emit mkdir tmp writefile tmp file chmod tmp rm tmp file force true code emit error mkdir tmp writefile tmp file chmod tmp rm tmp file force true function err err console error err code emit error mkdir tmp writefile tmp file chmod tmp rm tmp file force true file delete error emit error eacces permission deny unlink tmp file errno code syscall path tmp file file delete error emit file delete error emit command mkdir tmp touch tmp file chmod tmp rm f tmp file show expect result rm tmp file permission deny file delete believe linux system exhibit explicitly test minimal reproducible example linux
","O título da issue indica um problema de funcionamento ('rmSync does not throw error...'), sugerindo a necessidade de testes de regressão para garantir que a correção não introduza novos problemas.  O corpo da issue descreve problemas com a manipulação de arquivos e permissões, indicando que uma refatoração do código relacionada à gestão de erros e permissões de arquivos seria necessária para corrigir o problema. A discussão nos comentários também aponta para a necessidade de testes ('fix plan backport 16 LTS', 'fix issue break node js build') e possíveis mudanças ('fix consider break change'). Portanto, a issue requer tanto refatoração quanto testes de regressão."
346,38521,"2021-05-03 16:08:21","2021-06-14 13:20:17","2021-06-14 13:20:17","Crash in typescript using nodejs 16 on ppcle","* **Version**: 16.0.0
* **Platform**: Linux ls-ub-lf40a2dv 4.4.0-200-generic #232-Ubuntu SMP Wed Jan 13 10:17:10 UTC 2021 ppc64le ppc64le ppc64le GNU/Linux
* **Subsystem**: @nodejs/v8 

### What steps will reproduce the bug?

building a project (unfortunately closed source) using typescript 4.2.4

Update: Seems to happen with other projects, e.g. building typescript itself

### How often does it reproduce? Is there a required condition?

always, no special condition besides using PPCLE (no problem on windows, linux x86, linux arm).

### What is the expected behavior?

building works also on PPCLE

### What do you see instead?

```
/home/labuser/repo/node/proj/node_modules/typescript/lib/tsc.js:88057
                throw e;
                ^

TypeError: nodes.slice is not a function
    at visitNodes (/home/labuser/repo/node/proj/node_modules/typescript/lib/tsc.js:68214:37)
    at Object.visitEachChild (/home/labuser/repo/node/proj/node_modules/typescript/lib/tsc.js:68448:58)
    at visitTypeScript (/home/labuser/repo/node/proj/node_modules/typescript/lib/tsc.js:70186:31)
    at visitorWorker (/home/labuser/repo/node/proj/node_modules/typescript/lib/tsc.js:69997:24)
    at saveStateAndInvoke (/home/labuser/repo/node/proj/node_modules/typescript/lib/tsc.js:69956:27)
    at visitor (/home/labuser/repo/node/proj/node_modules/typescript/lib/tsc.js:69993:20)
    at visitNode (/home/labuser/repo/node/proj/node_modules/typescript/lib/tsc.js:68172:23)
    at Object.visitFunctionBody (/home/labuser/repo/node/proj/node_modules/typescript/lib/tsc.js:68309:23)
    at visitMethodDeclaration (/home/labuser/repo/node/proj/node_modules/typescript/lib/tsc.js:70932:292)
    at visitTypeScript (/home/labuser/repo/node/proj/node_modules/typescript/lib/tsc.js:70145:28)
    at visitorWorker (/home/labuser/repo/node/proj/node_modules/typescript/lib/tsc.js:69997:24)
    at classElementVisitorWorker (/home/labuser/repo/node/proj/node_modules/typescript/lib/tsc.js:70065:28)
```


### Additional information

If I attach the debugger problem is gone.
If I add `typeof(node.slice)` (which should be a not in my opinion) just before the line causing the `TypeError` it no longer occurs but a similar `TypeError` happens at another place.
If I add also `typeof()` checks at the next two such locations I finally end up in a segmentation fault with a quite small callstack:

```
#0  0x00000000115dd9b4 in Builtins_LoadIC_Megamorphic ()
#1  0x00000e8ec1d600e0 in ?? ()
```
","closed","Flarna",18708370,"{confirmed-bug,""v8 engine"",ppc}","https://github.com/nodejs/node/issues/38521",15,"Nenhum",NULL,42,"typeerror node slice function build project typescript ppcle linux problem window linux x86 linux arm debugger segmentation fault
","A issue descreve um crash no Node.js em um ambiente específico (ppc64le) e não menciona refatoração ou testes de regressão. Os comentários focam em depuração, reprodução do erro e solução do problema, sem menção a atividades de refatoração ou testes."
370,36845,"2021-01-08 10:55:12","2025-01-22 20:02:13","2025-01-22 20:02:14","--inspect crash in Node >=14.0.0 when accessing global variable in devtools","* **Version**: >=14.0.0
* **Platform**: Linux ubuntu 5.4.0-59-generic #65~18.04.1-Ubuntu SMP Mon Dec 14 15:59:40 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux

### What steps will reproduce the bug?
Run below _test.js_ by using  `node --inspect=0.0.0.0:9229 test.js` and inspect the file with `chrome://inspect` in Chrome (I am using Windows 10).
In the chrome dev tools try to access the ""test"" variable by typing `test `in the devtools. The node process will crash on the first try or on your next couple calls.

```js
// test.js
function registerGlobals(objects){
    Object.keys(objects).forEach((key) => {
        (globalThis)[key] = objects[key];
    });
};

var test = {
    blaat: 'some value'
};
registerGlobals({
    test
});

setInterval(() => {
    console.log('hearthbeat');
}, 1000);

```

### How often does it reproduce? Is there a required condition?
It happends consistently after the first 1-5 tries when accessing the ""test"" global variable.

### What is the expected behavior?
Not crash and return the results like in Node <= 13

### What do you see instead?
```
node --inspect=0.0.0.0:9229 test
Debugger listening on ws://0.0.0.0:9229/e7de75b7-eb6f-4fee-a374-0666c9644a98
For help, see: https://nodejs.org/en/docs/inspector
Debugger attached.
test
test
test
test
test


#
# Fatal error in , line 0
# Check failed: !isolate->has_pending_exception().
#
#
#
#FailureMessage Object: 0x7fffb56adfb0
 1: 0xa96131  [node]
 2: 0x19614f4 V8_Fatal(char const*, ...) [node]
 3: 0xc191fa  [node]
 4: 0xc1c634 v8::internal::Builtin_ConsoleLog(int, unsigned long*, v8::internal::Isolate*) [node]
 5: 0x13a6339  [node]
Illegal instruction (core dumped)
```

### Additional information
This only started happenening since Node version 14.0.0. Before, in v13.14.0, this crash does not happen.
","closed","jrmyio",971199,"{confirmed-bug,inspector}","https://github.com/nodejs/node/issues/36845",10,"Nenhum",NULL,1475,"node crash version 14 access global variable inspect chrome devtool consistent crash first try node 13 work  illegal instruction core dump
","A issue descreve um crash no Node.js versão 14 ao acessar variáveis globais no Chrome DevTools.  Não há menção a refatoração de código ou a testes de regressão. Os comentários focam em reproduzir o problema, depurar e encontrar a causa raiz do crash.  Não há indícios de atividades relacionadas a refatoração ou testes de regressão."
348,38412,"2021-04-26 13:38:31","2021-04-27 14:31:34","2021-05-14 09:42:20","perf_hooks.PerformanceObserver.observe kills node.js 16.0.0 when registering same entryTypes twice","
* **Version**: v16.0.0
* **Platform**: debian x64 in WSL, also Windows 10
* **Subsystem**: Envionment (?)

### What steps will reproduce the bug?

The easiest way is to clone siimon/prom-client (13.1.0 or current master branch) and run unit tests.

The minimum use case I could find is this code - I don't know or use perf_tools myself, but I can confirm this snippet works in Node.js 14.x

```
let perf_hooks = require('perf_hooks');
// works
const obs = new perf_hooks.PerformanceObserver(list => { console.log('in observer'); });
// works
obs.observe({ entryTypes: ['gc'], buffered: false });
// works
perf_hooks.performance.measure('gc');

// works
const obs2 = new perf_hooks.PerformanceObserver(list => { console.log('in observer 2'); });
// kills node.js
obs2.observe({ entryTypes: ['gc'], buffered: false });
```

### How often does it reproduce? Is there a required condition?

Every time.

### What is the expected behavior?

All prom-client unit tests pass like in node.js 14 or 15.

### What do you see instead?

Under Debian:

```
Welcome to Node.js v16.0.0.
Type "".help"" for more information.
> let perf_hooks = require('perf_hooks');
undefined
> // works
undefined
> const obs = new perf_hooks.PerformanceObserver(list => {
...     console.log('in observer');
... });
undefined
> // works
undefined
> obs.observe({ entryTypes: ['gc'], buffered: false });
undefined
> // works
undefined
> perf_hooks.performance.measure('gc');
PerformanceMeasure {
  name: 'gc',
  entryType: 'measure',
  startTime: 0,
  duration: 83245.0522999987,
  detail: undefined
}
> const obs2 = new perf_hooks.PerformanceObserver(list => {
...     console.log('in obin observer
server 2');
... });
undefined
>
> obs2.observe({ entryTypes: ['gc'], buffered: false });
node[1367]: ../src/env-inl.h:1052:void node::Environment::AddCleanupHook(node::Environment::CleanupCallback, void*): Assertion `(insertion_info.second) == (true)' failed.
 1: 0xb12b00 node::Abort() [node]
 2: 0xb12b7e  [node]
 3: 0xb7a58c  [node]
 4: 0xd5f70b  [node]
 5: 0xd60bac  [node]
 6: 0xd61226 v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) [node]
 7: 0x160c579  [node]
Aborted
```

Under Windows:

```
λ node
Welcome to Node.js v16.0.0.
Type "".help"" for more information.
> let perf_hooks = require('perf_hooks');
undefined
> // works
undefined
> const obs = new perf_hooks.PerformanceObserver(list => { console.log('in observer'); });
undefined
> // works
undefined
> obs.observe({ entryTypes: ['gc'], buffered: false });
undefined
> // works
undefined
> perf_hooks.performance.measure('gc');
PerformanceMeasure {
  name: 'gc',
  entryType: 'measure',
  startTime: 0,
  duration: 12642.107500001788,
  detail: undefined
}
>
> // works
undefined
> const obs2 = new perf_hooks.PerformanceObserver(list => { console.log('in observer 2'); });
undefined
> in observer
obs2.observe({ entryTypes: ['gc'], buffered: falsese });
cmd - node[4256]: c:\ws\src\env-inl.h:1052: Assertion `(insertion_info.second) == (true)' failed.
 1: 00007FF798E886BF v8::internal::Isolate::ArchiveSpacePerThread+4719
 2: 00007FF798E1B246 v8::internal::wasm::WasmCode::safepoint_table_offset+67414
 3: 00007FF798E1B5C1 v8::internal::wasm::WasmCode::safepoint_table_offset+68305
 4: 00007FF798DAFFB1 v8::CFunction::ReturnInfo+27953
 5: 00007FF799743969 v8::internal::Builtins::builtin_handle+318073
 6: 00007FF799742F01 v8::internal::Builtins::builtin_handle+315409
 7: 00007FF7997431F1 v8::internal::Builtins::builtin_handle+316161
 8: 00007FF799743033 v8::internal::Builtins::builtin_handle+315715
 9: 00007FF7998198B1 v8::internal::SetupIsolateDelegate::SetupHeap+455217
10: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
11: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
12: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
13: 00007FF7997B1C0F v8::internal::SetupIsolateDelegate::SetupHeap+30095
14: 00007FF7997B180B v8::internal::SetupIsolateDelegate::SetupHeap+29067
15: 00007FF79966A022 v8::internal::Execution::CallWasm+1698
16: 00007FF79966985F v8::internal::Execution::Call+191
17: 00007FF799794CC6 v8::Script::Run+694
18: 00007FF798E268B6 node::OnFatalError+43190
19: 00007FF798E29E46 node::OnFatalError+56902
20: 00007FF799743969 v8::internal::Builtins::builtin_handle+318073
21: 00007FF799742F01 v8::internal::Builtins::builtin_handle+315409
22: 00007FF7997431F1 v8::internal::Builtins::builtin_handle+316161
23: 00007FF799743033 v8::internal::Builtins::builtin_handle+315715
24: 00007FF7998198B1 v8::internal::SetupIsolateDelegate::SetupHeap+455217
25: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
26: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
27: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
28: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
29: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
30: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
31: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
32: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
33: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
34: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
35: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
36: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
37: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
38: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
39: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
40: 00007FF7997E1EA7 v8::internal::SetupIsolateDelegate::SetupHeap+227367
41: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
42: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
43: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
44: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
45: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
46: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
47: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
48: 00007FF7997B39B9 v8::internal::SetupIsolateDelegate::SetupHeap+37689
49: 00007FF7997B1C0F v8::internal::SetupIsolateDelegate::SetupHeap+30095
50: 00007FF7997B180B v8::internal::SetupIsolateDelegate::SetupHeap+29067
51: 00007FF79966A022 v8::internal::Execution::CallWasm+1698
52: 00007FF79966985F v8::internal::Execution::Call+191
53: 00007FF799770EF1 v8::Function::Call+609
54: 00007FF798EB7B8A node::CallbackScope::~CallbackScope+1674
55: 00007FF798EAF714 v8::internal::compiler::Operator::EffectOutputCount+228
56: 00007FF798D39A53 RSA_meth_get_flags+20675
57: 00007FF798D3A5CD RSA_meth_get_flags+23613
58: 00007FF798D34EF9 RSA_meth_get_flags+1385
59: 00007FF798ECD698 uv_udp_set_ttl+5176
60: 00007FF798EE796C uv_loop_init+908
61: 00007FF798EE7C8A uv_run+202
62: 00007FF798EB6F64 node::SpinEventLoop+308
63: 00007FF798DD3F53 v8::internal::UnoptimizedCompilationInfo::feedback_vector_spec+52995
64: 00007FF798E4E387 node::Start+215
65: 00007FF798C7822C RC4_options+346412
66: 00007FF799D3931C v8::internal::compiler::RepresentationChanger::Uint32OverflowOperatorFor+151692
67: 00007FFE484C7034 BaseThreadInitThunk+20
68: 00007FFE48602651 RtlUserThreadStart+33
```
","closed","analytik",372365,"{confirmed-bug,perf_hooks}","https://github.com/nodejs/node/issues/38412",4,"Ambos",NULL,1,"nodejs performanceobserver assertion fail unit test prom client node v16 debian windows gc entrytype measure work kill node


","O título menciona falha em teste unitário ('unit test') e o corpo menciona 'fix implementation' e  'observe entrytype gc buffered option', indicando correção de implementação e possivelmente testes de regressão.  A menção a 'perf_hooks' sugere que o problema está relacionado a parte de performance do código, indicando necessidade de refatoração para resolver o problema de forma adequada. A combinação de correção de implementação, testes e performance aponta para ambos os tipos de atividades."
349,38407,"2021-04-26 03:12:49","2021-05-01 23:42:47","2021-05-01 23:42:47","`zlib.brotliCompressSync` results in no response","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: v16.0.0-pre
* **Platform**:  Linux 5.8.0-38-generic #43~20.04.1-Ubuntu SMP Tue Jan 12 16:39:47 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
* **Subsystem**: zlib.brotliCompressSync

### What steps will reproduce the bug?
Setup a node instance,
```
» node
```
and run the following javascript code.
```
zlib = require('zlib');zlib.brotliCompressSync('',{flush:3,finishFlush:4});
```
Then the node instance stuck and has no response even with ""Ctl-D"".
<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->

### How often does it reproduce? Is there a required condition?
This can be always triggered following the steps above.

### What is the expected behavior?
Don't cause any no response.
<!--
If possible please provide textual output instead of screenshots.
-->

### What do you see instead?
```
» node
Welcome to Node.js v16.0.0-pre.
Type "".help"" for more information.
> zlib = require('zlib');zlib.brotliCompressSync('',{flush:3,finishFlush:4});


^C^C^C^C

                                                                                                                                                                                                 
```
<!--
If possible please provide textual output instead of screenshots.
-->

### Additional information

<!--
Tell us anything else you think we should know.
-->
","closed","zyscoder",23655282,"{confirmed-bug,zlib,brotli}","https://github.com/nodejs/node/issues/38407",1,"Nenhum",NULL,6,"node instance stuck response ctl version v16 pre platform linux x86 subsystem zlib brotlicompresssync steps reproduce bug node instance run javascript code zlib require zlib brotlicompresssync flush finishflush node instance stuck response ctl expected behavior response see instead node welcome node v16 pre type help zlib require zlib brotlicompresssync flush finishflush additional information
","A issue descreve um problema de travamento do Node.js ao usar a função `zlib.brotliCompressSync`.  Não há menção a refatoração de código ou testes de regressão. O problema parece ser um bug na implementação da função `brotliCompressSync`."
350,38381,"2021-04-24 14:50:26","2021-04-26 18:50:38","2021-04-26 18:50:38","`crypto.scrypt` results in an abort","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: v16.0.0-pre
* **Platform**:  Linux 5.8.0-38-generic #43~20.04.1-Ubuntu SMP Tue Jan 12 16:39:47 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
* **Subsystem**: crypto.scrypt

### What steps will reproduce the bug?
Setup a node instance,
```
» node
```
and run the following javascript code.
```
crypto = require('crypto');crypto.scrypt('','',2147485780,(err,derivedKey)=>{});
```
Then the node instance occurs an abort.
<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->

### How often does it reproduce? Is there a required condition?
This abort can always be triggered following the steps above.

### What is the expected behavior?
If any error occurs, an exception or other similar error-reporting stuff should be thrown. There is no reason to abort the whole node process.
<!--
If possible please provide textual output instead of screenshots.
-->

### What do you see instead?
```
» node
Welcome to Node.js v16.0.0-pre.
Type "".help"" for more information.
> crypto = require('crypto');crypto.scrypt('','',2147485780,(err,derivedKey)=>{});
/home/zys/Toolchains/node/node[209342]: ../src/crypto/crypto_scrypt.cc:90:static v8::Maybe<bool> node::crypto::ScryptTraits::AdditionalConfig(node::crypto::CryptoJobMode, const v8::FunctionCallbackInfo<v8::Value>&, unsigned int, node::crypto::ScryptConfig*): Assertion `args[offset + 6]->IsInt32()' failed.
 1: 0x562ea70e1af4 node::Abort() [/home/zys/Toolchains/node/node]
 2: 0x562ea70e1b88  [/home/zys/Toolchains/node/node]
 3: 0x562ea729fc2c node::crypto::ScryptTraits::AdditionalConfig(node::crypto::CryptoJobMode, v8::FunctionCallbackInfo<v8::Value> const&, unsigned int, node::crypto::ScryptConfig*) [/home/zys/Toolchains/node/node]
 4: 0x562ea72b33ad node::crypto::DeriveBitsJob<node::crypto::ScryptTraits>::New(v8::FunctionCallbackInfo<v8::Value> const&) [/home/zys/Toolchains/node/node]
 5: 0x562ea7360167 v8::internal::FunctionCallbackArguments::Call(v8::internal::CallHandlerInfo) [/home/zys/Toolchains/node/node]
 6: 0x562ea7360be2  [/home/zys/Toolchains/node/node]
 7: 0x562ea73614ad  [/home/zys/Toolchains/node/node]
 8: 0x562ea736179a v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) [/home/zys/Toolchains/node/node]
 9: 0x562ea7cff259  [/home/zys/Toolchains/node/node]
[1]    209342 abort (core dumped)  /home/zys/Toolchains/node/node                                                                                                                                                                        
```
<!--
If possible please provide textual output instead of screenshots.
-->

### Additional information

<!--
Tell us anything else you think we should know.
-->
","closed","zyscoder",23655282,"{confirmed-bug,crypto}","https://github.com/nodejs/node/issues/38381",0,"Nenhum",NULL,2,"version v16 pre platform linux x86 subsystem crypto scrypt step reproduce node instance run javascript code crypto require crypto scrypt err derivedkey node instance abort reproduce always trigger step expected behavior error occurs exception error reporting stuff thrown reason abort node process see instead node welcome node v16 pre type help information crypto require crypto scrypt err derivedkey home node src crypto crypto scrypt cc static v8 maybe bool node crypto scrypttraits additionalconfig node crypto cryptojobmode v8 functioncallbackinfo v8 value unsigned int node crypto scryptconfig assertion args offset failed node abort node node node crypto scrypttraits additionalconfig node crypto cryptojobmode v8 functioncallbackinfo v8 value unsigned int node crypto scryptconfig node node crypto derivebitsjob node crypto scrypttraits new v8 functioncallbackinfo v8 value v8 internal functioncallbackarguments call v8 internal callhandlerinfo node node node v8 internal builtin handleapicall int unsigned long v8 internal isolate node node node abort core dumped home node node additional information
","A issue descreve um crash no processo Node.js ao usar a função `crypto.scrypt`.  Não há menção a refatoração de código ou testes de regressão. O problema parece ser um bug ou um comportamento inesperado na implementação da função `crypto.scrypt`."
351,38377,"2021-04-24 02:37:09","2021-04-27 14:38:13","2021-04-27 14:38:13","`process.exit` results in a segmentation fault in v12.x","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: v12.21.0
* **Platform**:  Linux 5.8.0-38-generic #43~20.04.1-Ubuntu SMP Tue Jan 12 16:39:47 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
* **Subsystem**: process.exit

### What steps will reproduce the bug?
Setup a node instance,
```
» node
```
and run the following javascript code.
```
fs.write(7,fs.promises.chown,(err, written, buffer)=>{})
process.exit()
```
Then the node instance occurs a segmentation fault.
<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->

### How often does it reproduce? Is there a required condition?
This problem can always be triggered following the steps above.

### What is the expected behavior?
If any error occurs, an exception or other similar error-reporting stuff should be thrown. There is no reason to abort the whole node process.
<!--
If possible please provide textual output instead of screenshots.
-->

### What do you see instead?
```
» node
Welcome to Node.js v12.21.0.
Type "".help"" for more information.
> fs.write(7,fs.promises.chown,(err, written, buffer)=>{})
undefined
> process.exit()
[1]    160706 segmentation fault (core dumped)  /home/zys/Toolchains/node-v12.21.0/node                                                                                                                                                                                    
```
<!--
If possible please provide textual output instead of screenshots.
-->

### Additional information

<!--
Tell us anything else you think we should know.
-->
","closed","zyscoder",23655282,"{confirmed-bug,fs,process}","https://github.com/nodejs/node/issues/38377",3,"Nenhum",NULL,4,"version v12.21.0 platform linux x86_64 subsystem process.exit step reproduce node instance run javascript code fs.write 7 fs.promises.chown err written buffer process.exit node instance segmentation fault reproduce problem always trigger step expected behavior error occurs exception error report thrown reason abort node process see instead node welcome node v12.21.0 type help fs.write 7 fs.promises.chown undefined process.exit segmentation fault core dumped additional information
","A issue descreve um erro de segmentação (`segmentation fault`) ao usar `process.exit` no Node.js v12.  Não há menção a refatoração de código ou testes de regressão. O foco é em um bug e sua reprodução."
352,38358,"2021-04-22 15:25:37","2021-04-26 18:56:04","2021-04-26 18:56:04","`crypto.generateKeyPair` results in an abort","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: v16.0.0-pre
* **Platform**:  Linux 5.8.0-38-generic #43~20.04.1-Ubuntu SMP Tue Jan 12 16:39:47 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
* **Subsystem**: crypto.generateKeyPair

### What steps will reproduce the bug?
Setup a node instance,
```
» node
```
and run the following javascript code.
```
crypto = require('crypto');crypto.generateKeyPair('dsa',{modulusLength:0,divisorLength: 2147485780},(err,publicKey,privateKey)=>{});
```
Then the node instance occurs an abort.
<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->

### How often does it reproduce? Is there a required condition?
This abort can always be triggered following the steps above.

### What is the expected behavior?
If any error occurs, an exception or other similar error-reporting stuff should be thrown. There is no reason to abort the whole node process.
<!--
If possible please provide textual output instead of screenshots.
-->

### What do you see instead?
```
» node
Welcome to Node.js v16.0.0-pre.
Type "".help"" for more information.
> crypto = require('crypto');crypto.generateKeyPair('dsa',{modulusLength:0,divisorLength: 2147485780},(err,publicKey,privateKey)=>{});
/home/zys/Toolchains/node/node[53567]: ../src/crypto/crypto_dsa.cc:82:static v8::Maybe<bool> node::crypto::DsaKeyGenTraits::AdditionalConfig(node::crypto::CryptoJobMode, const v8::FunctionCallbackInfo<v8::Value>&, unsigned int*, node::crypto::DsaKeyPairGenConfig*): Assertion `args[*offset + 1]->IsInt32()' failed.
 1: 0x557dae7c5af4 node::Abort() [/home/zys/Toolchains/node/node]
 2: 0x557dae7c5b88  [/home/zys/Toolchains/node/node]
 3: 0x557dae919f2c node::crypto::DsaKeyGenTraits::AdditionalConfig(node::crypto::CryptoJobMode, v8::FunctionCallbackInfo<v8::Value> const&, unsigned int*, node::crypto::KeyPairGenConfig<node::crypto::DsaKeyPairParams>*) [/home/zys/Toolchains/node/node]
 4: 0x557dae91eba5 node::crypto::KeyGenJob<node::crypto::KeyPairGenTraits<node::crypto::DsaKeyGenTraits> >::New(v8::FunctionCallbackInfo<v8::Value> const&) [/home/zys/Toolchains/node/node]
 5: 0x557daea44167 v8::internal::FunctionCallbackArguments::Call(v8::internal::CallHandlerInfo) [/home/zys/Toolchains/node/node]
 6: 0x557daea44be2  [/home/zys/Toolchains/node/node]
 7: 0x557daea454ad  [/home/zys/Toolchains/node/node]
 8: 0x557daea4579a v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) [/home/zys/Toolchains/node/node]
 9: 0x557daf3e3259  [/home/zys/Toolchains/node/node]
[1]    53567 abort (core dumped)  /home/zys/Toolchains/node/node                                                                                                                                                                          
```
<!--
If possible please provide textual output instead of screenshots.
-->

### Additional information

<!--
Tell us anything else you think we should know.
-->
","closed","zyscoder",23655282,"{confirmed-bug,crypto}","https://github.com/nodejs/node/issues/38358",1,"Nenhum",NULL,4,"node instance abort crypto generatekeypair dsa moduluslength divisorlength exception error reporting abort node process assertion failed abort core dumped
","A issue descreve um erro de abortamento do processo Node.js durante a geração de um par de chaves criptográficas. Não há menção a refatoração de código ou testes de regressão."
353,37808,"2021-03-19 08:45:58","2021-03-23 10:04:39","2021-03-23 10:04:39","""crypto.createDiffieHellman"" results in an abort","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: v14.15.1
* **Platform**:  Linux 5.8.0-38-generic #43~20.04.1-Ubuntu SMP Tue Jan 12 16:39:47 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
* **Subsystem**: crypto.createDiffieHellman

### What steps will reproduce the bug?
Setup a node instance,
```
» node
```
and run the following javascript code.
```
crypto.createDiffieHellman('',true);
```
Then an abort occurs.
<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->

### How often does it reproduce? Is there a required condition?
This abort can always be triggered following the steps above.

### What is the expected behavior?
If any error occurs, an exception or other similar error-reporting stuff should be thrown. There is no reason to abort the whole node process.
<!--
If possible please provide textual output instead of screenshots.
-->

### What do you see instead?
```
» node
crypto.createDiffieHellman('',true);
node[79037]: ../src/util-inl.h:490:node::ArrayBufferViewContents<T, kStackStorageSize>::ArrayBufferViewContents(v8::Local<v8::Value>) [with T = char; long unsigned int kStackStorageSize = 64]: Assertion `value->IsArrayBufferView()' failed.
 1: 0xa03530 node::Abort() [node]
 2: 0xa035ae  [node]
 3: 0xb396fa node::ArrayBufferViewContents<char, 64ul>::ArrayBufferViewContents(v8::Local<v8::Value>) [node]
 4: 0xb30625 node::crypto::DiffieHellman::New(v8::FunctionCallbackInfo<v8::Value> const&) [node]
 5: 0xbe4695  [node]
 6: 0xbe4c9f  [node]
 7: 0xbe52c6 v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) [node]
 8: 0x13ff259  [node]
[1]    79037 abort (core dumped)  node
                                                                                                                                                                                                                                                 
```
<!--
If possible please provide textual output instead of screenshots.
-->

### Additional information

<!--
Tell us anything else you think we should know.
-->
","closed","zyscoder",23655282,"{confirmed-bug,crypto}","https://github.com/nodejs/node/issues/37808",0,"Nenhum",NULL,4,"version v14 node linux subsystem crypto createDiffieHellman step reproduce node instance run javascript code crypto createDiffieHellman abort occur reproduce always trigger step expect behavior error occur exception error reporting stuff thrown reason abort node process see instead node crypto createDiffieHellman node assertion value isArrayBufferView failed node abort core dumped node additional information
","A issue descreve um problema de falha de execução ('abort') na função 'crypto.createDiffieHellman' do Node.js. Não há menção a refatoração de código ou testes de regressão. O texto descreve um problema de funcionamento da biblioteca criptográfica, indicando um bug ou problema de compatibilidade."
354,37806,"2021-03-19 07:18:55","2021-03-28 17:21:48","2021-03-28 17:21:48","""clearImmediate"" results in an abort","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: v14.15.1
* **Platform**: Linux 5.8.0-38-generic #43~20.04.1-Ubuntu SMP Tue Jan 12 16:39:47 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
* **Subsystem**: clearImmediate

### What steps will reproduce the bug?
Setup a node instance,
```
» node
```
and run the following javascript code.
```
clearImmediate({hasRef: true, _onImmediate: 100000000000000000})
```
Then an abort occurs.
<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->

### How often does it reproduce? Is there a required condition?
This abort can always be triggered following the steps above.

### What is the expected behavior?
If any error occurs, an exception or other similar error-reporting stuff should be thrown. There is no reason to abort the whole node process.

<!--
If possible please provide textual output instead of screenshots.
-->

### What do you see instead?
```
» node
Welcome to Node.js v14.15.1.
Type "".help"" for more information.
> clearImmediate({hasRef: true, _onImmediate: 100000000000000000})
node[65197]: ../src/async_wrap.cc:623:static void node::AsyncWrap::QueueDestroyAsyncId(const v8::FunctionCallbackInfo<v8::Value>&): Assertion `args[0]->IsNumber()' failed.
 1: 0xa03530 node::Abort() [node]
 2: 0xa035ae  [node]
 3: 0x979ceb node::AsyncWrap::QueueDestroyAsyncId(v8::FunctionCallbackInfo<v8::Value> const&) [node]
 4: 0xbe369b  [node]
 5: 0xbe4c46  [node]
 6: 0xbe52c6 v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) [node]
 7: 0x13ff259  [node]
[1]    65197 abort (core dumped)  node
```
<!--
If possible please provide textual output instead of screenshots.
-->

### Additional information

<!--
Tell us anything else you think we should know.
-->
","closed","zyscoder",23655282,"{confirmed-bug,repl,timers}","https://github.com/nodejs/node/issues/37806",1,"Nenhum",NULL,9,"version v14.15.1 platform linux x86_64 subsystem clearimmediate step reproduce node instance run javascript code clearimmediate hasref true _onimmediate 100000000000000000 abort occur expected behavior error occur exception similar error report thrown reason abort node process see instead node welcome nodejs v14.15.1 type help information clearimmediate node node src async_wrap cc static void node asyncwrap queuedestroyasyncid v8 functioncallbackinfo v8 value assertion args failed node node node node node v8 internal builtin handleapicall node node abort core dumped node additional information
","A issue descreve um crash no Node.js relacionado ao método `clearImmediate`.  Não há menção a refatoração de código ou a execução de testes de regressão. O texto descreve um problema de funcionamento e um comportamento inesperado, indicando um bug a ser corrigido, mas não se relaciona diretamente às categorias de refatoração ou testes de regressão."
355,37805,"2021-03-19 06:17:53","2021-03-23 10:03:02","2021-03-23 10:03:02","""tty.isatty"" results in an abort","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: v14.15.1
* **Platform**:  Linux 5.8.0-38-generic #43~20.04.1-Ubuntu SMP Tue Jan 12 16:39:47 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
* **Subsystem**: tty.isatty

### What steps will reproduce the bug?
Setup a node instance,
```
» node
```
and run the following javascript code.
```
tty = require('tty');tty.isatty(1000000000000000000);
```
Then an abort occurs.
<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->

### How often does it reproduce? Is there a required condition?
This abort can always be triggered following the steps above.

### What is the expected behavior?
If any error occurs, an exception or other similar error-reporting stuff should be thrown. There is no reason to abort the whole node process.
<!--
If possible please provide textual output instead of screenshots.
-->

### What do you see instead?
```
» node                                                                                                                                                                                                                                                 134 ↵ zys@zys-X299-UD4-Pro
Welcome to Node.js v14.15.1.
Type "".help"" for more information.
> tty = require('tty');tty.isatty(1000000000000000000);
node[57893]: ../src/tty_wrap.cc:73:static void node::TTYWrap::IsTTY(const v8::FunctionCallbackInfo<v8::Value>&): Assertion `(fd) >= (0)' failed.
 1: 0xa03530 node::Abort() [node]
 2: 0xa035ae  [node]
 3: 0xaea222  [node]
 4: 0xbe369b  [node]
 5: 0xbe4c46  [node]
 6: 0xbe52c6 v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) [node]
 7: 0x13ff259  [node]
[1]    57893 abort (core dumped)  node
```
<!--
If possible please provide textual output instead of screenshots.
-->

### Additional information

<!--
Tell us anything else you think we should know.
-->
","closed","zyscoder",23655282,"{confirmed-bug}","https://github.com/nodejs/node/issues/37805",0,"Nenhum",NULL,4,"node core bug javascript code abort exception error reporting node process tty isatty assertion fd large number v14.15.1 linux x86_64
","A issue descreve um bug no core do Node.js relacionado a `tty.isatty()` resultando em um abort.  Não há menção a refatoração de código ou testes de regressão."
357,37782,"2021-03-17 17:14:03","2025-01-25 18:47:25","2025-01-25 18:47:25","child_process 'spawn' event is emitted too soon","**Version**: `15.1.0` thru `15.11.0` (see screenshot below)
**Platform**: `Darwin CALLMT20389 19.6.0 Darwin Kernel Version 19.6.0: Thu Oct 29 22:56:45 PDT 2020; root:xnu-6153.141.2.2~1/RELEASE_X86_64 x86_64`

### What steps will reproduce the bug?

Run the following simple repro example:

```console
$> node ./parent.mjs
```

<details>
<summary>parent.mjs</summary>

```js
import { fork } from 'child_process';


const subprocess = fork('./child.mjs');

subprocess.on('close', (...args) => { console.error('[PARENT] received', ...args) });
subprocess.on('disconnect', (...args) => { console.error('[PARENT] received', ...args) });
subprocess.on('error', (...args) => { console.error('[PARENT] received', ...args) });
subprocess.on('exit', (...args) => { console.error('[PARENT] received', ...args) });
subprocess.on('message', (...args) => { console.log('[PARENT] received', ...args) });
subprocess.on('spawn', () => {
  console.log({
    'parent::subprocess.send': subprocess.send({ hello: 'child' })
  });
});
```
</details>

<details>
<summary>child.mjs</summary>

```js
process.on('message', (...args) => { console.log('[CHILD] received', ...args) });

process.send({ hello: 'parent' });
```
</details>

### How often does it reproduce? Is there a required condition?

100% of the time (dozens of executions)

### What is the expected behavior?

child's process.on('message') should be triggered (parent's message should be received and logged to console).

### What do you see instead?

Only parent's subprocess.on('message') is triggered:

```console
$> node ./parent.mjs
{ 'parent::subprocess.send': true }
[PARENT] received { hello: 'parent' }
```

![image](https://user-images.githubusercontent.com/3012099/111513980-b0865500-8727-11eb-8d07-617170365ded.jpeg)

### Additional info

I installed node via nvm. I verified the version of node actually running is truly 15.11.0 by console logging `process.version` in both parent.mjs and child.mjs (both output `v15.11.0`)","closed","JakobJingleheimer",3012099,"{confirmed-bug,child_process,module,esm}","https://github.com/nodejs/node/issues/37782",18,"Ambos",NULL,1410,"process trigger message child process message parent process trigger message parent process send message child process receive message parent process receive message node nvm version node  child process receive message parent process send message  expect child process receive message see parent process receive message install node nvm verify version node console log process version parent mjs child mjs output v15.11","A issue relata um problema com o evento 'spawn' do módulo 'child_process', que é emitido muito cedo, causando uma condição de corrida.  Os comentários discutem soluções alternativas, como adicionar um handshake,  mas também abordam testes e investigação da documentação do evento 'spawn' para entender o comportamento em diferentes versões do Node.js e cenários (CommonJS vs ESM). A busca por uma solução envolve tanto a refatoração do código (para corrigir a emissão prematura do evento) quanto testes de regressão para verificar se a correção resolve o problema em diferentes contextos e versões do Node.js.  A menção a diferentes versões do Node.js e a busca por reprodução em diferentes cenários (mjs, CommonJS) reforçam a necessidade de testes abrangentes."
358,37757,"2021-03-15 10:16:46","2021-04-27 21:40:19","2022-04-26 00:53:17","Nodejs runs out of memory trying to connect to HTTPS host with self-signed certificate","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: 15.11.0 (also tested with 12 and 14 on same machine)
Platform: Ubuntu 16.04 (Linux 4.4.0-1127.8.2.vz7.151.14 #1 SMP Tue Jun 9 12:58:54 MSK 2020 x86_64 x86_64 x86_64 GNU/Linux)
Subsystem: https
-->

* **Version**: 15.11.0 (also tested with 12 and 14 on same machine)
* **Platform**: Ubuntu 16.04 (Linux 4.4.0-1127.8.2.vz7.151.14 #1 SMP Tue Jun 9 12:58:54 MSK 2020 x86_64 x86_64 x86_64 GNU/Linux)
* **Subsystem**: https

### What steps will reproduce the bug?

When trying to connect to a https-enabled host and using a self-signed certificate provided to node via `NODE_EXTRA_CA_CERTS` node hangs for a few minutes, using more and more memory, until it exits with `Allocation failed - JavaScript heap out of memory`. Full stacktrace below.


<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->

### How often does it reproduce? Is there a required condition?

The server needs to be up and the correct server certificate needs to be used.

### What is the expected behavior?

I would expect the connection to  be made successfully, since the self-signed certificate has been provided to node.
<!--
If possible please provide textual output instead of screenshots.
-->

### What do you see instead?

```
<--- Last few GCs --->

[15068:0x52f3bd0]   324861 ms: Scavenge (reduce) 4053.6 (4128.3) -> 4053.4 (4129.3) MB, 72.6 / 0.0 ms  (average mu = 0.851, current mu = 0.769) allocation failure
[15068:0x52f3bd0]   325180 ms: Scavenge (reduce) 4054.9 (4129.3) -> 4054.8 (4131.1) MB, 86.6 / 0.0 ms  (average mu = 0.851, current mu = 0.769) allocation failure
[15068:0x52f3bd0]   325442 ms: Scavenge (reduce) 4056.6 (4131.1) -> 4056.4 (4132.6) MB, 71.5 / 0.0 ms  (average mu = 0.851, current mu = 0.769) allocation failure


<--- JS stacktrace --->

FATAL ERROR: MarkCompactCollector: young object promotion failed Allocation failed - JavaScript heap out of memory
 1: 0xa7f490 node::Abort() [node]
 2: 0x9a5c4d node::FatalError(char const*, char const*) [node]
 3: 0xc6c2ae v8::Utils::ReportOOMFailure(v8::internal::Isolate*, char const*, bool) [node]
 4: 0xc6c627 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [node]
 5: 0xe360a5  [node]
 6: 0xe65633 v8::internal::EvacuateNewSpaceVisitor::Visit(v8::internal::HeapObject, int) [node]
 7: 0xe721e6 v8::internal::FullEvacuator::RawEvacuatePage(v8::internal::MemoryChunk*, long*) [node]
 8: 0xe5e30f v8::internal::Evacuator::EvacuatePage(v8::internal::MemoryChunk*) [node]
 9: 0xe5e588 v8::internal::PageEvacuationTask::RunInParallel(v8::internal::ItemParallelJob::Task::Runner) [node]
10: 0xe503a9 v8::internal::ItemParallelJob::Run() [node]
11: 0xe74170 void v8::internal::MarkCompactCollectorBase::CreateAndExecuteEvacuationTasks<v8::internal::FullEvacuator, v8::internal::MarkCompactCollector>(v8::internal::MarkCompactCollector*, v8::internal::ItemParallelJob*, v8::internal::MigrationObserver*, long) [node]
12: 0xe749b3 v8::internal::MarkCompactCollector::EvacuatePagesInParallel() [node]
13: 0xe74d75 v8::internal::MarkCompactCollector::Evacuate() [node]
14: 0xe874e1 v8::internal::MarkCompactCollector::CollectGarbage() [node]
15: 0xe433a8 v8::internal::Heap::MarkCompact() [node]
16: 0xe44d38 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [node]
17: 0xe482dc v8::internal::Heap::AllocateRawWithRetryOrFailSlowPath(int, v8::internal::AllocationType, v8::internal::AllocationOrigin, v8::internal::AllocationAlignment) [node]
18: 0xe0bf3a v8::internal::Factory::AllocateRaw(int, v8::internal::AllocationType, v8::internal::AllocationAlignment) [node]
19: 0xe05444 v8::internal::FactoryBase<v8::internal::Factory>::AllocateRawWithImmortalMap(int, v8::internal::AllocationType, v8::internal::Map, v8::internal::AllocationAlignment) [node]
20: 0xe07540 v8::internal::FactoryBase<v8::internal::Factory>::NewRawOneByteString(int, v8::internal::AllocationType) [node]
21: 0xe1955e v8::internal::Factory::NewStringFromOneByte(v8::internal::Vector<unsigned char const> const&, v8::internal::AllocationType) [node]
22: 0xc839e2 v8::String::NewFromOneByte(v8::Isolate*, unsigned char const*, v8::NewStringType, int) [node]
23: 0xbb5914 node::crypto::GetFingerprintDigest(node::Environment*, evp_md_st const*, x509_st*) [node]
24: 0xbb736e node::crypto::X509ToObject(node::Environment*, x509_st*) [node]
25: 0xbb81e4 node::crypto::GetPeerCert(node::Environment*, std::unique_ptr<ssl_st, node::FunctionDeleter<ssl_st, &SSL_free> > const&, bool, bool) [node]
26: 0xc2b567 node::crypto::TLSWrap::GetPeerCertificate(v8::FunctionCallbackInfo<v8::Value> const&) [node]
27: 0xcd8cbb  [node]
28: 0xcda26c  [node]
29: 0xcda8e6 v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) [node]
30: 0x14fa219  [node]
./run.sh: line 5: 15068 Aborted                 node index.js
```

<!--
If possible please provide textual output instead of screenshots.
-->

### Additional information

All files i´ve used to reproduce: [node_https_test.zip](https://github.com/nodejs/node/files/6140472/node_https_test.zip)
https_renew_cert.sh is a script used to generate the key/certificate pair. (Sample certificate and key is also included in the zip, so you don´t have to regenerate them, if you don´t have oppenssl installed)
server.js is the server. Execute with node server.js.
index.js is the client. Started from run.sh
run.sh: Starts the client and sets `NODE_EXTRA_CA_CERTS`. (You need to update the path to the certificate)

<!--
Tell us anything else you think we should know.
-->
","closed","nils91",7298243,"{confirmed-bug,tls}","https://github.com/nodejs/node/issues/37757",15,"Ambos",NULL,43,"version 15.11.0 test 12 14 machine platform ubuntu linux subsystem https step reproduce bug connect https enable host self sign certificate provide node node extra ca cert node hang minute use memory exit allocation failure javascript heap memory full stacktrace server need correct server certificate expect connection make successfully self sign certificate provide node see instead scavenge allocation failure fatal error markcompactcollector young object promotion fail allocation failure javascript heap memory node abort node fatalerror node util report oomfailure node v8 internal v8 fatalprocessoutofmemory node node node node node node node node node node node node node node node node node node node node node node node node node node node node node node additional information file use reproduce node https test zip https renew cert sh script generate key certificate pair sample certificate key include zip regenerate openssl install server js server execute node server js index js client start run sh run sh start client set node extra ca cert
","A issue relata um problema de memória (javascript heap memory) no Node.js ao conectar a um host HTTPS com um certificado auto-assinado.  Os comentários discutem a causa raiz, que parece estar relacionada a uma alteração no OpenSSL (v15.5.0) e a configuração do `keyUsage` no certificado.  Há menções a testes de regressão (reprodução do problema em diferentes sistemas operacionais e versões do Node.js) e a necessidade de refatoração/correção no código para lidar corretamente com a configuração do certificado e evitar o erro de memória.  A solução proposta envolve ajustar a configuração do certificado (`keyUsage`), o que indica tanto refatoração quanto a necessidade de testes de regressão após a correção."
359,37710,"2021-03-11 07:31:36","2021-03-13 12:44:43","2021-03-13 12:44:43","deepStrictEqual not commutative by not accounting for non-enumerable properties","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**:
  * 14.x (but probably also others)
* **Platform**:
  * all

### What steps will reproduce the bug?

```js
const { deepStrictEqual } = require(""assert"");

const a = {};
const b = {};

a.x = 1;

Object.defineProperties(b, {
  x: {
    value: 1,
    writable: true,
  },
  y: {
    value: 5,
    writable: true,
    enumerable: true,
    configurable: true,
  },
});

console.log({ a, b });
deepStrictEqual(a, b); // does not assert
deepStrictEqual(b, a); // does assert
```

### How often does it reproduce? Is there a required condition?
Always

### What is the expected behavior?
I expect deepStrictEqual to be at least commutative. (Whether it should handle non-enumerable properties may be up for discussion)

### What do you see instead?
`deepStrictEqual(b, a)` does throw an assertion while `deepStrictEqual(a, b)` does not.


### Additional information
If you point me in the right direction I'm willing to fix it myself.","closed","nmalyschkin",44928856,"{confirmed-bug,assert}","https://github.com/nodejs/node/issues/37710",0,"Refatoração",NULL,2,"deepStrictEqual comutativo manipular propriedade nao enumeravel expect deepStrictEqual comutativo assertion deepStrictEqual assertion
","O título da issue ""deepStrictEqual not commutative by not accounting for non-enumerable properties"" e o corpo da issue mencionam problemas com a função deepStrictEqual e suas propriedades não enumeráveis. Isso sugere uma necessidade de refatoração do código para corrigir o comportamento da função e garantir que ela seja comutativa, tratando corretamente as propriedades não enumeráveis.  Não há menção a testes de regressão, apenas a necessidade de alteração no código existente."
361,37676,"2021-03-09 15:22:37","2021-04-12 11:06:00","2021-04-12 11:06:00","HTTP Response read past end","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: 15.8.*
* **Platform**: All
* **Subsystem**: http

### What steps will reproduce the bug?

```mjs
import net from 'net';
import http from 'http';

// create a simple server with too small of content-length
const body = 'HTTP/1.1 200 OK\r\n' +
  'Content-Length: 5\r\n' +
  'Connection: close\r\n' +
  '\r\n' +
  '2ad731e3-4dcd-4f70-b871-0ad284b29ffc'
const server = net.createServer((conn) => conn.end(body));
const port = 9191;
server.listen(port, () => {
  // try to GET from the server
  http.get('http://localhost:' + port);
});

// causes Error: Parse Error: Expected HTTP/
```

<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior?

No error, doesn't read past content-length and/or doesn't try to parse a second response from a `connection: close` response. Unclear on expected HTTP semantics and common leniency here. Likely shouldn't do either I suspect.

### What do you see instead?

<!--
If possible please provide textual output instead of screenshots.
-->

```console
$ node bug.js
node:events:355
      throw er; // Unhandled 'error' event
      ^

Error: Parse Error: Expected HTTP/
    at Socket.socketOnData (node:_http_client:502:22)
    at Socket.emit (node:events:378:20)
    at addChunk (node:internal/streams/readable:313:12)
    at readableAddChunk (node:internal/streams/readable:288:9)
    at Socket.Readable.push (node:internal/streams/readable:227:10)
    at TCP.onStreamRead (node:internal/stream_base_commons:190:23)
Emitted 'error' event on ClientRequest instance at:
    at Socket.socketOnData (node:_http_client:509:9)
    at Socket.emit (node:events:378:20)
    [... lines matching original stack trace ...]
    at TCP.onStreamRead (node:internal/stream_base_commons:190:23) {
  bytesParsed: 62,
  code: 'HPE_INVALID_CONSTANT',
  reason: 'Expected HTTP/',
  rawPacket: Buffer(93) [Uint8Array] [
     72,  84,  84,  80,  47,  49,  46,  49,  32,  50,  48,  48,
     32,  79,  75,  13,  10,  67, 111, 110, 116, 101, 110, 116,
     45,  76, 101, 110, 103, 116, 104,  58,  32,  53,  13,  10,
     67, 111, 110, 110, 101,  99, 116, 105, 111, 110,  58,  32,
     99, 108, 111, 115, 101,  13,  10,  13,  10,  50,  97, 100,
     55,  51,  49, 101,  51,  45,  52, 100,  99, 100,  45,  52,
    102,  55,  48,  45,  98,  56,  55,  49,  45,  48,  97, 100,
     50,  56,  52,  98,  50,  57, 102, 102,  99
  ]
}
```

### Additional information

<!--
Tell us anything else you think we should know.
-->
","closed","bmeck",234659,"{confirmed-bug,http,http_parser}","https://github.com/nodejs/node/issues/37676",13,"Refatoração",NULL,34,"version 15 platform all subsystem http step reproduce bug create simple server small content length try get server cause error parse error expect http expected behavior error read past content length try parse second response connection close response unclear expect http semantic common leniency likely suspect see instead error parse error expect http additional information
","A issue descreve a correção de um erro de parsing no tratamento de respostas HTTP.  As discussões nos comentários focam em como lidar com dados além do comprimento especificado na resposta,  propondo mudanças no código ('patch llhttp port http_parser server client') e ajustes para melhor alinhamento com a especificação.  Embora testes sejam mencionados, o foco principal é na alteração do código para um comportamento mais estrito e correto, caracterizando uma refatoração."
364,37298,"2021-02-09 20:01:58","2021-02-15 22:05:52","2022-02-03 21:46:30","Policy scope fix","<!--
Before submitting a pull request, please read
https://github.com/nodejs/node/blob/master/CONTRIBUTING.md.

Commit message formatting guidelines:
https://github.com/nodejs/node/blob/master/doc/guides/contributing/pull-requests.md#commit-message-guidelines

For code changes:
1. Include tests for any bug fixes or new features.
2. Update documentation if relevant.
3. Ensure that `make -j4 test` (UNIX), or `vcbuild test` (Windows) passes.

Developer's Certificate of Origin 1.1

By making a contribution to this project, I certify that:

(a) The contribution was created in whole or in part by me and I
    have the right to submit it under the open source license
    indicated in the file; or

(b) The contribution is based upon previous work that, to the best
    of my knowledge, is covered under an appropriate open source
    license and I have the right under that license to submit that
    work with modifications, whether created in whole or in part
    by me, under the same open source license (unless I am
    permitted to submit under a different license), as indicated
    in the file; or

(c) The contribution was provided directly to me by some other
    person who certified (a), (b) or (c) and I have not modified
    it.

(d) I understand and agree that this project and the contribution
    are public and that a record of the contribution (including all
    personal information I submit with it, including my sign-off) is
    maintained indefinitely and may be redistributed consistent with
    this project or the open source license(s) involved.
-->

This fixes a case where repeated scope lookup for modules with multiple dependencies would fail and the manifest would look up the dependency redirector of the referrer rather than the scope. This was found in stress testing of https://github.com/bmeck/local-fs-https-imports . The reason it didn't appear to have a test before is likely that code coverage was unaffected.","closed","bmeck",234659,"{confirmed-bug,""author ready"",policy}","https://github.com/nodejs/node/pull/37298",8,"Ambos","https://api.github.com/repos/nodejs/node/pulls/37298",6,"fix case repeated scope lookup module multiple dependency fail manifest look dependency redirector referrer scope find stress test reason appear test code coverage unaffected
","O título ""Policy scope fix"" sugere uma refatoração, enquanto o corpo menciona ""stress test"" e a menção repetida de ""CI"" nos comentários indica testes de regressão.  A frase ""reason appear test code coverage unaffected"" também sugere que os testes de regressão foram realizados. Portanto, tanto refatoração quanto testes de regressão estão envolvidos."
366,37122,"2021-01-29 13:21:18","2021-02-06 13:10:18","2021-02-06 13:10:18","fs: error when fd = -0","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: v15.2.0
* **Platform**: Ubuntu-18.04
* **Subsystem**: fs

### What steps will reproduce the bug?

<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->

```console
❯ node -p 'fs.fstatSync(-0)'
node[10415]: ../src/node_file.cc:1077:void node::fs::FStat(const v8::FunctionCallbackInfo<v8::Value>&): Assertion `args[0]->IsInt32()' failed.
 1: 0xb0c720 node::Abort() [node]
 2: 0xb0c7a1  [node]
 3: 0xb1944f  [node]
 4: 0xdb938c  [node]
 5: 0xdbb317 v8::internal::Builtin_HandleApiCall(int, unsigned int*, v8::internal::Isolate*) [node]
 6: 0x16e6017  [node]
 7: 0x168b379  [node]
 8: 0x1684cf2  [node]
 9: 0x168b379  [node]
10: 0x168949a  [node]
11: 0x16892bb  [node]
12: 0xece07e  [node]
13: 0xecf072 v8::internal::Execution::Call(v8::internal::Isolate*, v8::internal::Handle<v8::internal::Object>, v8::internal::Handle<v8::internal::Object>, int, v8::internal::Handle<v8::internal::Object>*) [node]
14: 0xd40619 v8::Script::Run(v8::Local<v8::Context>) [node]
15: 0xafc6d3 node::contextify::ContextifyScript::EvalMachine(node::Environment*, long long, bool, bool, bool, std::shared_ptr<v8::MicrotaskQueue>, v8::FunctionCallbackInfo<v8::Value> const&) [node]
16: 0xafceb1 node::contextify::ContextifyScript::RunInThisContext(v8::FunctionCallbackInfo<v8::Value> const&) [node]
17: 0xdb938c  [node]
18: 0xdbb317 v8::internal::Builtin_HandleApiCall(int, unsigned int*, v8::internal::Isolate*) [node]
19: 0x16e6017  [node]
20: 0x168b379  [node]
21: 0x168b379  [node]
22: 0x168b379  [node]
23: 0x168b379  [node]
24: 0x168b379  [node]
25: 0x168b379  [node]
26: 0x168949a  [node]
27: 0x16892bb  [node]
28: 0xece07e  [node]
29: 0xecf072 v8::internal::Execution::Call(v8::internal::Isolate*, v8::internal::Handle<v8::internal::Object>, v8::internal::Handle<v8::internal::Object>, int, v8::internal::Handle<v8::internal::Object>*) [node]
30: 0xd504c1 v8::Function::Call(v8::Local<v8::Context>, v8::Local<v8::Value>, int, v8::Local<v8::Value>*) [node]
31: 0xacbcdf node::ExecuteBootstrapper(node::Environment*, char const*, std::vector<v8::Local<v8::String>, std::allocator<v8::Local<v8::String> > >*, std::vector<v8::Local<v8::Value>, std::allocator<v8::Local<v8::Value> > >*) [node]
32: 0xacc007  [node]
33: 0xacd5ef node::StartExecution(node::Environment*, std::function<v8::MaybeLocal<v8::Value> (node::StartExecutionCallbackInfo const&)>) [node]
34: 0xa51397 node::LoadEnvironment(node::Environment*) [node]
35: 0xb5bd4e node::NodeMainInstance::Run(node::EnvSerializeInfo const*) [node]
36: 0xacfec9 node::Start(int, char**) [node]
37: 0xa46c39 main [node]
38: 0xb7a31f21 __libc_start_main [/lib/i386-linux-gnu/libc.so.6]
[1]    10415 abort (core dumped)  node -p 'fs.fstatSync(-0)'

```

### How often does it reproduce? Is there a required condition?

Always.

### What is the expected behavior?

<!--
If possible please provide textual output instead of screenshots.
-->
No error.","closed","RaisinTen",42526976,"{confirmed-bug,fs}","https://github.com/nodejs/node/issues/37122",1,"Nenhum",NULL,8,"version v15 platform ubuntu subsystem fs step reproduce bug node p fs fstatsync assertion args isint failed expect behavior error
","O título e a descrição da issue ""fs: error when fd = -0"" e o comentário ""work"" não indicam claramente a necessidade de refatoração ou testes de regressão.  A descrição parece relatar um erro de funcionamento do sistema de arquivos, sem menção a mudanças de código ou a necessidade de testes para garantir a integridade de funcionalidades existentes."
367,37054,"2021-01-24 21:38:24","2021-04-30 19:47:14","2021-04-30 19:47:14","specific scenario causes infinite recursion in util.inspect (max stack size exceeded)","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: v15.6.0
* **Platform**: Microsoft Windows NT 10.0.19042.0 x64
* **Subsystem**: util

### What steps will reproduce the bug?

<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->

```js
const { inspect } = require(""util"");

class A {
    constructor(B) {
        this.B = B;
    }
    get b() {
        return this.B;
    }
}

class B {
    constructor() {
        this.A = new A(this);
    }
    get a() {
        return this.A;
    }
}

const test = new B();
const result = inspect(test, {
    depth:1,
    getters:true,
    showHidden:true
});

console.log(result);
```

### How often does it reproduce? Is there a required condition?

Happens when both `getters` and `showHidden` are enabled and the class contains circular references accessible by getters

### What is the expected behavior?

<!--
If possible please provide textual output instead of screenshots.
-->

The `depth` option should short circuit the circular references and display no more than 2 levels of depth.

### What do you see instead?

<!--
If possible please provide textual output instead of screenshots.
-->

A giant wall of text.

### Additional information

<!--
Tell us anything else you think we should know.
-->

Also tested on node v15.4.0 and NWJS running node v15.3.0 but did not test in v14.

Issue discovered when attempting to inspect a `client` instance from the `discord.js` library, which makes use of such circular references.

EDIT: just tested in v15.2.0 and it works correctly. It seems the issue was introduced with v15.3.0
","closed","timotejroiko",33236065,"{confirmed-bug,util}","https://github.com/nodejs/node/issues/37054",4,"Ambos",NULL,96,"version v15 6 0 platform microsoft windows nt 10 0 19042 0 x64 subsystem util step reproduce bug getter showhidden enable class contain circular reference accessible getter often reproduce required condition happen getter showhidden enable class contain circular reference accessible getter expect behavior depth option short circuit circular reference display level depth see instead giant wall text additional information test node v15 4 0 nwjs run node v15 3 0 test v14 issue discover attempt inspect client instance discord j library make use circular reference edit test v15 2 0 work correctly seem issue introduce v15 3 0
","A issue relata um problema de recursão infinita (Refatoração) em uma versão específica do Node.js (v15.3.0), que foi corrigido em uma versão anterior (v15.2.0).  A descrição inclui testes ('test node v15 4 0 nwjs run node v15 3 0 test v14', 'run correctly v15.2 node test js', 'run correctly v15.2 issue happen v15.3'), indicando a necessidade de testes de regressão para garantir a correção do problema. A menção à correção por meio de um pull request ('fix submit pr') reforça a natureza de refatoração da solução. Portanto, a issue abrange tanto refatoração quanto testes de regressão."
368,37053,"2021-01-24 18:22:00","2021-05-20 19:34:00","2021-06-03 21:36:55","[linux-armv7l] http.request() fails with HPE_INVALID_CONSTANT error ","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: tested on Node v14.15.4, v15.6.0 and v14.7.x
* **Platform**: Linux 5.4.51-v7l+ armv7l GNU/Linux (it's a Raspberry Pi 4 running Debian 10)
* **Subsystem**: http

### What steps will reproduce the bug?

<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->

Run the following:

```node
const http = require(`http`)
const url = `http://51.77.66.14/Trilogia%20%20John%20Wick%202014-2019%20REMUX%204K%20HDR%20Latino/John%20Wick%203%20Parabellum%202019%20REMUX%204K%20HDR%20Latino.mkv`
const byteOffset = 2595000000

const req = http.request(url, {
  method: `GET`,
  headers: {
    'Range': `bytes=${byteOffset}-`,
  }
}, (res) => {
  console.log(`STATUS:`, res.statusCode);
  console.log(`HEADERS:`, res.headers);
  // res.setEncoding('hex');
  res.on('data', (chunk) => {
    // needs to be registered so that the body is parsed
  });
})

req.on('error', (err) => {
  console.error(err)
});
req.end();
```

### How often does it reproduce? Is there a required condition?

One this platform, always.

### What is the expected behavior?

<!--
If possible please provide textual output instead of screenshots.
-->

No error, the response should be parsed just fine. I know the responding web server might be (at least partially) at fault, but the issue does not appear on win32 (Windows 10) or in Linux/WSL1 (openSUSE & Debian) on x64, so this probably isn't desired behavior.

For what it's worth, both `curl` and `wget` don't face this issue either.

### What do you see instead?

<!--
If possible please provide textual output instead of screenshots.
-->

```node
STATUS: 206
HEADERS: {
  date: 'Sun, 24 Jan 2021 18:03:49 GMT',
  server: 'Apache/2.4.29 (Ubuntu)',
  'last-modified': 'Sun, 05 Jan 2020 20:21:31 GMT',
  etag: '""f9ac35f5c-59b6a49dd4bc5""',
  'accept-ranges': 'bytes',
  'content-length': '64426004636',
  'content-range': 'bytes 2595000000-67021004635/67021004636',
  connection: 'close',
  'content-type': 'video/x-matroska'
}
Error: Parse Error: Expected HTTP/
    at Socket.socketOnData (_http_client.js:509:22)
    at Socket.emit (events.js:315:20)
    at addChunk (internal/streams/readable.js:309:12)
    at readableAddChunk (internal/streams/readable.js:284:9)
    at Socket.Readable.push (internal/streams/readable.js:223:10)
    at TCP.onStreamRead (internal/stream_base_commons.js:188:23) {
  bytesParsed: 335,
  code: 'HPE_INVALID_CONSTANT',
  reason: 'Expected HTTP/',
  rawPacket: <Buffer 9a 40 a4 1b 3b aa 46 a5 7e e7 09 dd 35 3f 9e 93 b6 bc 75 3e 04 ac dc e6 f8 cd 99 c4 7f 07 98 0c e7 f9 c3 2c e8 d2 20 ff d0 98 98 48 c0 ef 07 66 60 5d ... 1350 more bytes>
}
```

### Additional information

<!--
Tell us anything else you think we should know.
-->

The requested file is quite large, so if it doesn't throw an error after a few seconds, don't wait for it to finish. I wish I had another URL to shared, but right now I only have this one. Although I am very sure I've encountered this error several times before (but didn't look into it further).

Also, notice the `byteOffset`. The issue happens at a specific byte range, hence the offset. The offset isn't totally exact, but should narrow it down to a few megabytes...

I really hope someone can figure out what's going on here. I'm building a download manager and it's very unfortunate that it doesn't work reliably on my server...","closed","Chaphasilor",18015147,"{confirmed-bug,http_parser}","https://github.com/nodejs/node/issues/37053",16,"Ambos",NULL,116,"version test node v14 15 4 v15 6 0 v14 7 x platform linux armv7l subsystem http step reproduce bug run following const http require http const url http 51 77 66 14 trilogia john wick 2014 2019 remux 4k hdr latino john wick 3 parabellum 2019 remux 4k hdr latino mkv const byteoffset 2595000000 const req http request url method get header range bytes byteoffset res console log status res statuscode console log header res header res data chunk console log chunk req error err console error err req end platform always expect behavior error response parse fine know respond web server least partially fault issue appear win32 windows 10 linux wsl1 opensuse debian x64 probably desire behavior curl wget face issue see instead status 206 header date server apache last modified etag accept ranges content length content range connection content type video x matroska error parse error expect http socket socketondata socket emit addchunk readableaddchunk readablepush tcp onstreamread byteparsed code hpe invalid constant reason expect http rawpacket additional information request file quite large throw error second wait finish wish url share right one encounter error several time look wish someone figure build download manager unfortunate work reliably server
","A issue relata um erro em `http.request()` que ocorre em plataformas ARMv7l, mas também é mencionado problemas em x64.  Comentários discutem a reprodução do erro em diferentes versões do Node.js e a possível relação com o parser `llhttp`.  A investigação envolve tanto refatoração do código (mudança para `llhttp`) quanto testes de regressão para verificar a correção do problema em diferentes arquiteturas e versões."
373,36656,"2020-12-28 05:33:33","2021-02-24 13:45:33","2021-02-24 13:45:34","make check failure for macOS arch64","Commit 0b6d3070a1 

macOS 11.1  aarch64

Xcode 12.3

```bash
make; make check

=== release test-worker-prof ===                                              
Path: sequential/test-worker-prof
node:assert:119
  throw new AssertionError(obj);
  ^

AssertionError [ERR_ASSERTION]: child exited with signal: {
  status: null,
  signal: 'SIGSEGV',
  output: [ null, '', '' ],
  pid: 73280,
  stdout: '',
  stderr: ''
}
    at Object.<anonymous> (/Users/USERNAME/github/node/test/sequential/test-worker-prof.js:58:10)
    at Module._compile (node:internal/modules/cjs/loader:1108:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1137:10)
    at Module.load (node:internal/modules/cjs/loader:973:32)
    at Function.Module._load (node:internal/modules/cjs/loader:813:14)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:76:12)
    at node:internal/main/run_main_module:17:47 {
  generatedMessage: false,
  code: 'ERR_ASSERTION',
  actual: 'SIGSEGV',
  expected: null,
  operator: 'strictEqual'
}
Command: out/Release/node /Users/USERNAME/github/node/test/sequential/test-worker-prof.js
[02:41|% 100|+ 3282|-   1]: Done                                              
make[1]: *** [jstest] Error 1
make: *** [test] Error 2
```","closed","chadbrewbaker",230310,"{confirmed-bug,build,macos}","https://github.com/nodejs/node/issues/36656",9,"Testes de Regressão",NULL,58,"erro segfault teste worker processo assertionerror comando node teste sequential test worker prof js
","O título da issue ""make check failure for macOS arch64"" e o corpo da issue mencionam falhas em testes (""erro segfault teste worker processo assertionerror comando node teste sequential test worker prof js"").  Os comentários também discutem problemas de testes, depuração e reprodução de erros em diferentes ambientes (macOS, Windows, Apple Silicon), indicando um foco na regressão de testes."
374,36620,"2020-12-24 18:06:18","2021-01-12 10:01:09","2021-01-12 10:01:09","Calling res.end() twice stalls follow-up HTTP request (drain event is missing)","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: 14.0.0...14.15.3 (latest lts), 15.0.0...15.5.0 (latest stable)
* **Platform**: macos / ubuntu / windows
* **Subsystem**: N/A

### What steps will reproduce the bug?

Originally, I noticed this behaviour in a Next.js app and it took me quite a while to drill down to the bottom of it. You can find a plain MWE here: https://github.com/kachkaev/node-http-response-double-end-call-breaking-drain-event (no NPM packages involved). 

Since Node version 14.0.0, calling `res.end()` twice in a body-less response seems to be silencing the `drain` event in a follow-up HTTP request if it uses the same connection. This can happen in practice when redirecting a client to a heavy page and using [compression](https://www.npmjs.com/package/compression) package as middleware.

I understand that calling `res.end()` twice is a developer mistake, however it does not seem right to have to debug such a small oversight for more than two working days 😅 When using [`res.redirect(...)` helper method in Next.js](https://github.com/vercel/next.js/blob/9b3edd3b2476b9915fe8c94071a77ac8e8f14499/packages/next/next-server/server/api-utils.ts#L195-L217), it’s easy to forget that it’s not only doing `res.writeHead(...)` for you, but also calls `res.end()`. Seeing `res.redirect(...); res.end()` does not feel too wrong initially and there is no feedback from the server or the tooling to suggest that this involves `res.end()` being called twice.

Here are the reproduction steps from the server POV:

1. A client establishes a connection and requests a page that results with a redirect:

    ```ts
    res.writeHead(302, { Location: ""/another-page"" });
    res.end();
    res.end(); // called twice intentionally
    ```

2. The same client immediately comes back with another request, which is meant to return 200 and contain some payload.

    - If the size of the payload is small enough to fit a single `res.write(...)`, all works fine.
    
    - If the payload involves `res.write(...) === true` → `res.on(""drain"", () => {...})`, the second request is never finished because the `drain` event is never invoked.
    
You can look into how `compression` is using `res.write(...)` + `res.on(""drain"", ...)` to find a practical example: https://github.com/expressjs/compression/blob/3fea81d0eaed1eb872bf3e0405f20d9e175ab2cf/index.js#L193-L218

### How often does it reproduce? Is there a required condition?

I am able to silence the `drain` event quite reliably on any Node version ≥14.0.0 on any OS. See the [GitHub Workflow for my MWE](https://github.com/kachkaev/node-http-response-double-end-call-breaking-drain-event/actions/runs/442932230).

### What is the expected behavior?

Ideally, I would expect the second `res.end()` to not produce any side effects or at least to give me a warning. All works fine in Node v13.14.0 and below.

### What do you see instead?

I stumbled across some magic behaviour which took more than two days to investigate 😅

### Additional information

The unwanted side effect from a double call to `res.end()` is negated:

- if the follow-up request does not share the connection with the first (body-less) request (i.e. `curl` called twice);
- or if `res.write("""")` is added to the first (body-less) request

Both observations are included into GitHub Workflows within the MWE repo. I also tried playing with `res.end("""")` as a replacement for `res.write("""")`, but it did not help.","closed","kachkaev",608862,"{confirmed-bug,http}","https://github.com/nodejs/node/issues/36620",2,"Nenhum",NULL,19,"version lts stable platform macos ubuntu windows subsystem na step reproduce bug notice behaviour next app take quite while drill bottom find plain mwe npm package involve node version call res end twice body less response seem silence drain event follow http request use connection happen practice redirect client heavy page use compression package middleware understand call res end twice developer mistake seem right debug small oversight work day use res redirect helper method next easy forget only write also call res end see res redirect res end feel wrong initially feedback server tooling suggest involve res end call twice reproduction step server pov client establish connection request page result redirect res writehead location another page res end res end call twice intentionally client immediately come request mean return payload size payload small enough fit single res write work fine payload involve res write true res drain second request never finish drain event never invoke look compression use res write res drain find practical example often reproduce required condition able silence drain event quite reliably node version os see github workflow mwe expect behavior ideally expect second res end produce side effect least give warning work fine node v below see instead stumble magic behaviour take day investigate additional information unwanted side effect double call res end negate follow request share connection first body less request curl call twice res write add first body less request observation include github workflow mwe also try play res end replacement res write help
","A issue descreve um bug onde chamar `res.end()` duas vezes em uma requisição HTTP causa problemas com requisições subsequentes.  Não há menção a refatoração de código ou a testes de regressão. O foco é na solução de um problema de funcionamento do servidor."
375,36615,"2020-12-24 05:01:02","2020-12-29 00:48:59","2020-12-29 00:48:59","gunzipSync DOA in Node 14.15.2","* **Version**: 14.15.2
* **Platform**: Linux lbvm 5.4.0-56-generic #62~18.04.1-Ubuntu SMP Tue Nov 24 10:07:50 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux
* **Subsystem**:

### What steps will reproduce the bug?
Any code using `gunzipSync` will crash

```
$ cat gunzip.js 
const { gunzipSync } = require('zlib');
console.log(gunzipSync('fooobar'));

$ node -v
v14.15.2

$ node gunzip.js 
internal/streams/readable.js:193
  const isDuplex = this instanceof Stream.Duplex;
                        ^

TypeError: Right-hand side of 'instanceof' is not an object
    at Gunzip.Readable (internal/streams/readable.js:193:25)
    at Gunzip.Duplex (internal/streams/duplex.js:56:12)
    at Gunzip.Transform (internal/streams/transform.js:117:10)
    at Gunzip.ZlibBase (zlib.js:271:13)
    at Gunzip.Zlib (zlib.js:669:12)
    at new Gunzip (zlib.js:732:8)
    at syncBufferWrapper (zlib.js:765:29)
    at Object.<anonymous> (/home/ledion/workspaces/js2bin/gunzip.js:2:13)
    at Module._compile (internal/modules/cjs/loader.js:1063:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1092:10)
```

The regression seems to have been introduced in 14.15.2 and is present in 14.15.3.

Maybe related to #35239? cc @mcollina 
","closed","ledbit",6250118,"{confirmed-bug,zlib}","https://github.com/nodejs/node/issues/36615",2,"Ambos",NULL,5,"código usar gunzipSync crash tipoerror lado direito instanceof objeto gunzip readable gunzip duplex gunzip transform gunzip zlibbase gunzip zlib gunzip zlib syncbufferwrapper objeto home workspaces js2bin gunzip js modulo compile modulo extensions js regressão introduzir presente relacionado
","O título menciona um problema de compatibilidade ('gunzipSync DOA in Node 14.15.2'), sugerindo a necessidade de refatoração para corrigir o código.  O corpo menciona 'regressão', indicando um problema de regressão que requer testes de regressão para garantir que a correção não introduza novos bugs.  Os comentários também sugerem uma correção ('fix backport v14') e verificação ('code work stream correctly initialize')."
376,36559,"2020-12-18 05:37:23","2020-12-31 20:31:26","2020-12-31 20:31:26","`new URL` gives wrong result on leading backslash","<!--
Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: v15.4.0
* **Platform**: `Linux 5b80145d2618 4.19.0-13-amd64 #1 SMP Debian 4.19.160-2 (2020-11-28) x86_64 GNU/Linux`
* **Subsystem**:

### What steps will reproduce the bug?

Parse a relative-URL string that begins with a backslash. For example:
```
> new URL(""\\x"", ""https://example/foo/bar"").href
'https://example/foo//x'
```

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior?

The leading backslash should have the same behavior as if it were a proper `/`. The input would be treated as a path-absolute URL (replacing the whole path from the base URL), or a scheme-relative URL (replacing all but the scheme from the base URL).

For example:
`new URL(""\\x"", ""https://example/foo/bar"").href` -> `""https://example/x""`
`new URL(""\\\\x"", ""https://example/foo/bar"").href` -> `""https://x/""`

### What do you see instead?

The leading backslash is treated incorrectly. The effect seems to be as if the input were a path-relative-URL string -- the base URL's path, except for its last component, appears in the result. In the example:
```
> new URL(""\\x"", ""https://example/foo/bar"").href
'https://example/foo//x'
```

### Additional information

The behavior of `new URL` is documented as being defined by the WHATWG [URL Standard](https://url.spec.whatwg.org/). An input string like `\x`, with a leading backslash, is never a ""valid URL string"" as defined in that standard... but the standard nevertheless defines what the `URL` constructor should return for it.

Because the example input `\x` is so short, it's not hard to walk through [the URL parser](https://url.spec.whatwg.org/#url-parsing) as defined in the URL Standard and confirm what result the standard calls for. For the base URL of `https://example/`, it goes from ""scheme start state"" to ""no scheme state"" to ""relative state"" to ""relative slash state"" to ""path state"", following exactly the same track as an input of `/x` would do, except only that `\x` emits a validation error. In the URL parser as defined by the URL Standard, a ""validation error"" [does not affect the parser's result](https://url.spec.whatwg.org/#validation-error), so the resulting URL should be the same as for `/x`.

As a different kind of check, Chrome (87.0.4280.88) gives the correct answer according to the spec. In the browser console:
```
> new URL(""\\x"", ""https://example/foo/bar"").href
""https://example/x""
```

So does Firefox (78.0):
```
�� new URL(""\\x"", ""https://example/foo/bar"").href
← ""https://example/x""
```
","closed","gnprice",28173,"{confirmed-bug,url}","https://github.com/nodejs/node/issues/36559",1,"Nenhum",NULL,14,"versão v15.4.0 plataforma linux subsystem parse url relativo iniciar barra exemplo url x https example foo bar href https example foo x reproduzir sempre esperado comportamento barra inicial mesmo comportamento barra entrada tratar caminho absoluto url substituir caminho url base url relativo substituir esquema url base exemplo url x https example foo bar href https example url x https example foo bar href https x ver comportamento barra inicial tratar incorretamente efeito entrada caminho relativo url base url componente exemplo url x https example foo bar href https example foo x informação adicional comportamento url documentar whatwg url standard entrada x barra inicial url válido standard definir url constructor retornar exemplo x curto fácil percorrer url parser definir url standard confirmar resultado standard chamar url base https example ir esquema iniciar estado esquema estado relativo estado barra relativo estado caminho seguir mesmo caminho entrada x emitir erro validação url parser definir url standard erro validação afetar resultado parser url resultar mesmo x tipo diferente verificação chrome 87.0.4280.88 resposta correta especificação console navegador url x https example foo bar href https example firefox 78.0 url x https example foo bar href https example
","A issue descreve um problema com o funcionamento da função `new URL` em relação ao tratamento de barras invertidas no início de URLs relativas.  Não há menção a refatoração de código ou a testes de regressão. O foco é na correção de um bug de comportamento inesperado."
83,56449,"2025-01-03 07:10:21","2025-01-07 22:38:26","2025-01-07 22:38:26","crypto.generatePrime seems have much higher priority over than process.exit which results in stuck","### Version

v22.11.0

### Platform

```text
Linux u24vm 6.8.0-51-generic #52-Ubuntu SMP PREEMPT_DYNAMIC Thu Dec  5 13:09:44 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux
```

### Subsystem

crypto

### What steps will reproduce the bug?

Setup a node instance,
```
» node
```
and run the following javascript code.
```
_crypto = require('crypto');
_crypto.generatePrime(134217728,{bigint:true},function(err,prime){});
process.exit();
```
The node instance cannot be closed using process.exit() or with double Ctl-C or Ctl-D.
Note that if we don't execute ```process.exit()``` but run other code, it works.

### How often does it reproduce? Is there a required condition?

This issue can always be triggered following the steps above.

### What is the expected behavior? Why is that the expected behavior?

I don't know if this is a bug.
[The documentation of process.exit()](https://nodejs.org/api/process.html#processexitcode) says ```The process.exit() method instructs Node.js to terminate the process **synchronously**. Calling process.exit() will force the process to exit as quickly as possible even if there are still asynchronous operations pending that have not yet completed fully, including I/O operations to process.stdout and process.stderr.```
However, the above code cannot close the node instance immediately, leading to the node server being stuck.

### What do you see instead?

```
» node   
Welcome to Node.js v22.11.0.
Type "".help"" for more information.
> _crypto = require('crypto');
{
  checkPrime: [Function: checkPrime],
  checkPrimeSync: [Function: checkPrimeSync],
  createCipheriv: [Function: createCipheriv],
  createDecipheriv: [Function: createDecipheriv],
  createDiffieHellman: [Function: createDiffieHellman],
  createDiffieHellmanGroup: [Function: createDiffieHellmanGroup],
  createECDH: [Function: createECDH],
  createHash: [Function: createHash],
  createHmac: [Function: createHmac],
  createPrivateKey: [Function: createPrivateKey],
  createPublicKey: [Function: createPublicKey],
  createSecretKey: [Function: createSecretKey],
  createSign: [Function: createSign],
  createVerify: [Function: createVerify],
  diffieHellman: [Function: diffieHellman],
  generatePrime: [Function: generatePrime],
  generatePrimeSync: [Function: generatePrimeSync],
  getCiphers: [Function (anonymous)],
  getCipherInfo: [Function: getCipherInfo],
  getCurves: [Function (anonymous)],
  getDiffieHellman: [Function: createDiffieHellmanGroup],
  getHashes: [Function (anonymous)],
  hkdf: [Function: hkdf],
  hkdfSync: [Function: hkdfSync],
  pbkdf2: [Function: pbkdf2],
  pbkdf2Sync: [Function: pbkdf2Sync],
  generateKeyPair: [Function: generateKeyPair],
  generateKeyPairSync: [Function: generateKeyPairSync],
  generateKey: [Function: generateKey],
  generateKeySync: [Function: generateKeySync],
  privateDecrypt: [Function (anonymous)],
  privateEncrypt: [Function (anonymous)],
  publicDecrypt: [Function (anonymous)],
  publicEncrypt: [Function (anonymous)],
  randomBytes: [Function: randomBytes],
  randomFill: [Function: randomFill],
  randomFillSync: [Function: randomFillSync],
  randomInt: [Function: randomInt],
  randomUUID: [Function: randomUUID],
  scrypt: [Function: scrypt],
  scryptSync: [Function: scryptSync],
  sign: [Function: signOneShot],
  setEngine: [Function: setEngine],
  timingSafeEqual: [Function (anonymous)],
  getFips: [Function: getFips],
  setFips: [Function: setFips],
  verify: [Function: verifyOneShot],
  hash: [Function: hash],
  Certificate: [Function: Certificate] {
    exportChallenge: [Function: exportChallenge],
    exportPublicKey: [Function: exportPublicKey],
    verifySpkac: [Function: verifySpkac]
  },
  Cipher: undefined,
  Cipheriv: [Function: Cipheriv],
  Decipher: undefined,
  Decipheriv: [Function: Decipheriv],
  DiffieHellman: [Function: DiffieHellman],
  DiffieHellmanGroup: [Function: DiffieHellmanGroup],
  ECDH: [Function: ECDH] { convertKey: [Function: convertKey] },
  Hash: [Function: deprecated],
  Hmac: [Function: deprecated],
  KeyObject: [class KeyObject],
  Sign: [Function: Sign],
  Verify: [Function: Verify],
  X509Certificate: [class X509Certificate],
  secureHeapUsed: [Function: secureHeapUsed],
  constants: [Object: null prototype] {
    OPENSSL_VERSION_NUMBER: 805306608,
    SSL_OP_ALL: 2147485776,
    SSL_OP_ALLOW_NO_DHE_KEX: 1024,
    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
    SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
    SSL_OP_CISCO_ANYCONNECT: 32768,
    SSL_OP_COOKIE_EXCHANGE: 8192,
    SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
    SSL_OP_LEGACY_SERVER_CONNECT: 4,
    SSL_OP_NO_COMPRESSION: 131072,
    SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
    SSL_OP_NO_QUERY_MTU: 4096,
    SSL_OP_NO_RENEGOTIATION: 1073741824,
    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
    SSL_OP_NO_SSLv2: 0,
    SSL_OP_NO_SSLv3: 33554432,
    SSL_OP_NO_TICKET: 16384,
    SSL_OP_NO_TLSv1: 67108864,
    SSL_OP_NO_TLSv1_1: 268435456,
    SSL_OP_NO_TLSv1_2: 134217728,
    SSL_OP_NO_TLSv1_3: 536870912,
    SSL_OP_PRIORITIZE_CHACHA: 2097152,
    SSL_OP_TLS_ROLLBACK_BUG: 8388608,
    ENGINE_METHOD_RSA: 1,
    ENGINE_METHOD_DSA: 2,
    ENGINE_METHOD_DH: 4,
    ENGINE_METHOD_RAND: 8,
    ENGINE_METHOD_EC: 2048,
    ENGINE_METHOD_CIPHERS: 64,
    ENGINE_METHOD_DIGESTS: 128,
    ENGINE_METHOD_PKEY_METHS: 512,
    ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
    ENGINE_METHOD_ALL: 65535,
    ENGINE_METHOD_NONE: 0,
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    RSA_PKCS1_PADDING: 1,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    RSA_PSS_SALTLEN_DIGEST: -1,
    RSA_PSS_SALTLEN_MAX_SIGN: -2,
    RSA_PSS_SALTLEN_AUTO: -2,
    defaultCoreCipherList: 'TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA',
    TLS1_VERSION: 769,
    TLS1_1_VERSION: 770,
    TLS1_2_VERSION: 771,
    TLS1_3_VERSION: 772,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6,
    defaultCipherList: [Getter/Setter]
  },
  webcrypto: [Getter],
  subtle: [Getter],
  getRandomValues: [Getter]
}
> _crypto.generatePrime(134217728,{bigint:true},function(err,prime){});
undefined
> process.exit();


^C^C^C^C^C
```

### Additional information

_No response_","closed","zyscoder",23655282,"{confirmed-bug,crypto}","https://github.com/nodejs/node/issues/56449",3,"Ambos",NULL,5,"node instance close process exit double ctl c ctl d execute process exit code node server bug documentation process exit method instruct node terminate process synchronously call process exit force process exit quickly possible asynchronous operation pending complete include io operation process stdout process stderr code close node instance immediately node server stuck issue trigger step
","O título da issue indica um problema de funcionamento do Node.js relacionado à geração de números primos ('crypto.generatePrime'), sugerindo a necessidade de refatoração para melhorar o tratamento de interrupções e a prioridade das operações. O corpo e os comentários descrevem tentativas de resolução, incluindo a menção de callbacks e a implementação de verificações para permitir interrupções durante a geração de chaves.  A menção explícita à necessidade de testes para garantir a correção da solução ('fix address issue')  indica a necessidade de testes de regressão para validar se a refatoração resolveu o problema e não introduziu novos bugs."
378,36544,"2020-12-16 23:20:32","2020-12-20 09:28:51","2020-12-20 09:28:51","doc: Piping multiple streams to the same Writable stream might not end","# 📗 API Reference Docs Problem

<!--

Thank you for wanting to make nodejs.org better!

This template is for issues with the Node.js API
reference documentation.

For problems with nodejs.org beyond the API
reference documentation, please open an issue
using the issue tracker for our site repository.

  https://github.com/nodejs/nodejs.org

For more general support, please open an issue
using the issue tracker for our help repository.

  https://github.com/nodejs/help

---

For the issue title, please enter a one-line
summary after “doc: ” (preferably 50 characters
or less and no more than 72).

The “✍️” are placeholders signifying requests for
input. Replace them with your responses.

If you are unsure of something, do your best.

-->

<!-- The output of “node --version”. -->

- **Version**: 15.4.0

<!-- The output of “uname -a” (UNIX) or version
and 32-bit or 64-bit (Windows). -->

- **Platform**: Linux pop-os 5.8.0-7630-generic 20.10~61c3910-Ubuntu SMP Thu Nov 26 00:10:35 UTC  x86_64 x86_64 x86_64 GNU/Linux

<!-- The name of affected core module. -->

- **Subsystem**: stream

## Location

_Section of the site where the content exists_

Affected URL(s):

- https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options

## Description

_Concise explanation of the problem_

<!-- If applicable, include any screenshots that
may help solve the problem. -->

The documentation for `readable.pipe()` reads:

> ... The flow of data will be automatically managed so that the destination Writable stream is not overwhelmed by a faster Readable stream.

So when we open a Writable stream and then pipe multiple Readable streams into this Writable stream; the stream becomes full/congested and needs to drain but then we pipe more Readable streams into this stream. This seems to sometimes cause a Readable stream to not end and thus does not pipe its data to the Writable stream.

Bug in electron/asar explaining the issue https://github.com/electron/asar/issues/210.

Since electron/asar does this in basically a `for await`-loop, we get stuck waiting for a Readable stream which never ends.

Is this expected behavior when piping multiple Readable streams into one Writable stream? Should one check `writable.writableNeedDrain` before piping a Readable stream?

---

<!-- Use “[x]” to check the box below if you are
interested in contributing. -->

- [ ] I would like to work on this issue and
      submit a pull request.
","closed","weedz",634476,"{confirmed-bug,stream}","https://github.com/nodejs/node/issues/36544",7,"Ambos",NULL,3,"doc problema api referencia documentacao readable pipe fluxo dado automaticamente gerencia destino writable stream nao sobrecarrega rapido readable stream abrir writable stream pipe multiplo readable stream stream fica cheio congestionado precisa drenar pipe mais readable stream parece causar readable stream nao terminar nao pipe dado writable stream bug electron asar explica problema electron asar basicamente for await loop fica esperando readable stream nunca termina esperado comportamento pipe multiplo readable stream writable stream verificar writable writable need drain antes pipe readable stream
","O título e o corpo da issue mencionam problemas de documentação ('doc problema api referencia documentacao'), indicando a necessidade de refatoração.  Além disso, os comentários discutem a adição de testes ('minimal repro basis test', 'lack test', 'work write small test'), indicando a necessidade de testes de regressão.  A combinação de ambos sugere a classificação 'Ambos'."
380,36490,"2020-12-12 09:14:33","2022-11-05 19:59:07","2022-11-05 19:59:07","fs.mkdir with recursive option and invalid name hangs the program","<!--
Thank you for reporting an issue.

This issue tracker is for bugs and issues found within Node.js core.
If you require more general support please file an issue on our help
repo. https://github.com/nodejs/help


Please fill in as much of the template below as you're able.

Version: output of `node -v`
Platform: output of `uname -a` (UNIX), or output of `""$([Environment]::OSVersion | ForEach-Object VersionString) $(if ([Environment]::Is64BitOperatingSystem) { ""x64"" } else { ""x86"" })""` in PowerShell console (Windows)
Subsystem: if known, please specify affected core module name
-->

* **Version**: v12.18.0
* **Platform**: Windows10
* **Subsystem**:

### What steps will reproduce the bug?

<!--
Enter details about your bug, preferably a simple code snippet that can be
run using `node` directly without installing third-party dependencies.
-->
```js
const fs = require(""fs"");
const path = ""./to-delete/s:d"";

fs.mkdir(path, { recursive: true }, (err) => {
  if (err) {
    console.log(err);
    return;
  }
  console.log(""success"");
});
```
### How often does it reproduce? Is there a required condition?
Using **:** (double dots) character in folder name after the first prefix will make the program freeze
### What is the expected behavior?
Throw an error

<!--
If possible please provide textual output instead of screenshots.
-->

### What do you see instead?
The program hangs

<!--
If possible please provide textual output instead of screenshots.
-->

### Additional information
--
<!--
Tell us anything else you think we should know.
-->
","closed","GeorgianStan",25796932,"{confirmed-bug,fs,windows,libuv}","https://github.com/nodejs/node/issues/36490",12,"Testes de Regressão",NULL,693,"version v12 platform windows subsystem program hang folder name double dot character program freeze error expect error see program hang
","Os comentários indicam múltiplas tentativas de testar o problema em diferentes ambientes (Windows e Linux), versões do Node.js (v12, v14), e confirmações de que o problema foi corrigido em versões posteriores.  Expressões como ""test"", ""test linux"", ""test window"", ""confirm happen"", ""confirm issue fix"" demonstram foco em testes de regressão para verificar se a correção funcionou em diferentes cenários."
381,36237,"2020-11-23 21:06:26","2020-11-27 17:47:53","2020-11-27 17:47:53","Asynchronous dir.close() throws immediately, if already closed","* **Version**: v12.12.0 - v14.15.1
* **Platform**: platform-independent
* **Subsystem**: lib/internal/fs/dir.js

### What steps will reproduce the bug?
Calling asynchronous version of dir.close() with dir already closed, e.g. by it's async iterator.
```
const fs = require('fs')

const dir = fs.opendirSync('.')  // Using async function in this example just for brevity.

dir.closeSync()     //  In my actual code, here is an async loop over dir.entries() which may terminate in the middle.

try {
  dir.close((error) => {
    if(!error) return
    // We never get ERR_DIR_CLOSED here...
  })
} catch (error) {
    // ... but here instead (but we should see only ERR_INVALID_CALLBACK here).
}
```
### How often does it reproduce? Is there a required condition?
Always, when dir.close() is called redundantly.
### What is the expected behavior?
Asynchronous functions should forward errors via callback, unless the provided callback argument itself is invalid.
### What do you see instead?
Error is thrown immediately (synchronously), This is especially embarrassing with promises API:
```
try {
  dir.close().then(() => console.log('closed the dir just now')
  ).catch(error => console.log('something wrong', error))
} catch (error) {
  if(error.code === 'ERR_DIR_CLOSED') console.log('Oh no... again!')
  else console.log('a real surprise!', e)
}
```
### Additional information
If this behaviour is intentional, it should be documented; otherwise I would gladly provide a fix.","closed","valango",191752,"{confirmed-bug,fs}","https://github.com/nodejs/node/issues/36237",3,"Refatoração",NULL,4,"chamar versão assíncrona dir close dir já fechado exemplo iterador assíncrono função assíncrona exemplo brevidade fechar sincronamente código loop assíncrono dir entries terminar meio erro encaminhar erro callback callback inválido erro lançado imediatamente sincronicamente especialmente embaraçoso promises api comportamento intencional documentar contrário fornecer correção
","A issue descreve um problema com o fechamento assíncrono de um diretório, sugerindo uma correção ou melhoria no código existente.  Palavras como 'correção', 'comportamento intencional', 'documentar' e a menção de melhorar a 'promises api' indicam uma necessidade de refatoração do código para solucionar o problema, sem menção explícita a testes de regressão."
88,56219,"2024-12-11 00:04:22","2024-12-14 18:09:51","2024-12-14 18:09:51","TextDecoder regressed for ascii, windows-1252, ... encodings in v23.4.0","### Version

23.4.0

### Platform

```text
macOS 15.1.1 (24B91)
```

### Subsystem

_No response_

### What steps will reproduce the bug?

```bash
~: node
Welcome to Node.js v23.4.0.
> b = new Uint8Array([97, 108, 101])
> decoder = new TextDecoder('ascii')
> decoder.decode(b)
<Buffer 61 6c 65>
```

### How often does it reproduce? Is there a required condition?

Reproduces reliably.

### What is the expected behavior? Why is that the expected behavior?

Returns a string instead of a buffer. See output from `v23.3.0`:

```
~: node
Welcome to Node.js v23.3.0.
> b = new Uint8Array([97, 108, 101])
> decoder = new TextDecoder('ascii')
> decoder.decode(b)
'ale'
```

### What do you see instead?

Returns a buffer.

### Additional information

@mertcanaltin @RafaelGSS @anonrig @jasnell @lemire @targos #55275","closed","lutzroeder",438516,"{confirmed-bug}","https://github.com/nodejs/node/issues/56219",6,"Ambos",NULL,4,"node textdecoder retornar string buffer versão  reproduzir confiável  esperar string buffer  ver  saída  retornar buffer
","O título da issue indica uma regressão (TextDecoder regressed...), sugerindo a necessidade de testes de regressão.  O corpo e os comentários discutem a correção de um problema relacionado à saída de uma função (retornar buffer em vez de string), indicando a necessidade de refatoração do código para corrigir o comportamento incorreto. A menção à correção em uma próxima versão ('fix next release') reforça a necessidade de ambos os tipos de atividades."
90,56137,"2024-12-05 00:40:58","2024-12-17 13:06:53","2024-12-17 13:06:53","dns.lookup('localhost', { all: true}) returns only ::1 with Node.js v22.12, while v22.11 returned both ::1 and 127.0.0.1","### Version

v22.12.0

### Platform

```text
Windows 11 (Microsoft Windows NT 10.0.26100.0 x64)
```


### Subsystem

dns

### What steps will reproduce the bug?

On my Windows 11 system, the `localhost` hostname resolves to both `::1` and `127.0.0.1`, as confirmed by PowerShell `Resolve-DnsName`:

```PowerShell
PS> Resolve-DnsName localhost
Name             Type   TTL   Section    IPAddress
----             ----   ---   -------    ---------
localhost        AAAA   1200  Question   ::1
localhost        A      1200  Question   127.0.0.1
```

And with Node.js v22.11 (and v20, and v18), both addresses are returned by a DNS lookup, as expected:

```PowerShell
PS> node -v
v22.11.0
PS> node -e ""require('dns').lookup('localhost', {all: true}, (err, addresses) => console.log(JSON.stringify(addresses, null, '  ')))""
[
  {
    ""address"": ""::1"",
    ""family"": 6
  },
  {
    ""address"": ""127.0.0.1"",
    ""family"": 4
  }
]
```

However with Node.js v22.12, only `::1` is returned:

```PowerShell
PS> node -v
v22.12.0
PS> node -e ""require('dns').lookup('localhost', {all: true}, (err, addresses) => console.log(JSON.stringify(addresses, null, '  ')))""
[
  {
    ""address"": ""::1"",
    ""family"": 6
  }
]
```

### How often does it reproduce? Is there a required condition?

It repros consistently on Windows.

I do not see the same problem on Linux: after editing `/etc/hosts` to include dual mappings for `localhost`, I do see both addresses returned from the Node.js DNS lookup, and it is consistent between Node.js v22.11 and v22.12.

### What is the expected behavior? Why is that the expected behavior?

I found this bug because we have some Node.js test code that needs to connect to a port on localhost without knowing whether the local server is listening on the IPv4 or IPv6 localhost. It actually uses `net.createConection({..., autoSelectFamily: true })`, but the problem seems to be with the DNS resolution before the ""happy eyeballs"" algorithm gets a chance to auto-select an address family. Because only ::1 is tried, the connection fails if the local server was actually listening on IPv4.

### What do you see instead?

```
Error: connect ECONNREFUSED ::1:51793
```

...when the server was actually listening on `127.0.0.1:51793`

### Additional information

_No response_","closed","jasongin",13093042,"{confirmed-bug,dns,windows}","https://github.com/nodejs/node/issues/56137",1,"Nenhum",NULL,13,"windows nodejs dns resolução ipv4 ipv6 localhost conexão erro econnrefused
","O título descreve um problema de resolução de DNS com diferentes versões do Node.js, afetando a devolução de endereços IPv4 e IPv6. O corpo menciona problemas de conexão e o comentário sugere a utilização de um bisect para encontrar o commit problemático.  Não há menção explícita à refatoração ou testes de regressão. O problema parece ser um bug ou um comportamento inesperado da biblioteca DNS do Node.js."
92,56006,"2024-11-26 20:04:43","2024-12-05 20:25:27","2024-12-05 20:25:27","fs.readdir(path,  { recursive: true }) is sync","Reviving https://github.com/nodejs/node/issues/51749. 

The implementation in https://github.com/nodejs/node/pull/41439 is calling a synchronous approach even for an asynchronous call. See https://github.com/nodejs/node/blob/main/lib/fs.js#L1458.

I will take a quick look at that and see if I can fix it; otherwise, we might want to consider documenting it explicitly until we have a real solution for it. 

cc: @Ethan-Arrowood ","closed","RafaelGSS",26234614,"{confirmed-bug,fs}","https://github.com/nodejs/node/issues/56006",3,"Refatoração",NULL,9,"implementação chamar abordagem síncrona chamada assíncrona  olhar rápido ver corrigir caso considerar documentar explicitamente solução real
","O título da issue ""fs.readdir(path,  { recursive: true }) is sync"" indica um problema com a função fs.readdir sendo síncrona.  O corpo menciona a necessidade de olhar, corrigir e documentar uma solução, sugerindo uma alteração na implementação existente. Os comentários discutem a correção de uma versão assíncrona, e a possibilidade de uma nova função, indicando que o foco é melhorar o código existente, sem adicionar novos recursos.  Não há menção a testes de regressão explicitamente, embora a correção possa exigir testes para garantir a compatibilidade."
95,55829,"2024-11-12 21:56:17","2024-11-13 08:14:13","2024-11-13 08:41:07","v18.20.5 is missing all download files","### Version

N/A

### Platform

_No response_

### Subsystem

_No response_

### What steps will reproduce the bug?

- Look at https://nodejs.org/dist/index.tab - the version 18.20.5 is shown as available.
- Look at https://nodejs.org/dist/v18.20.5/ - only SHA hash files are there.
- Look at https://nodejs.org/dist/v18.20.4/ as a comparison - hashes and downloads are available.

![screen capture of 18.20.5 download location](https://github.com/user-attachments/assets/1fd8514a-e179-44dc-8a28-7030518803ad)

### How often does it reproduce? Is there a required condition?

It's consistent.

### What is the expected behavior? Why is that the expected behavior?

I expect either the version to be removed from `index.tab` or the downloads to be available. It's messing up version managers like `n` and others that assume the index has the list of available releases.

### What do you see instead?

Errors from version managers due to missing files (404).

### Additional information

_No response_","closed","tillig",1156571,"{confirmed-bug,v18.x}","https://github.com/nodejs/node/issues/55829",22,"Ambos",NULL,0,"versão disponível arquivo hash versão administrador erro arquivo ausente
","A issue relata problemas na versão 18.20.5, com arquivos de download ausentes (body e vários comentários).  Comentários como 'build fail', 'fix break deployment update build', e menções a ações de build e deploy indicam problemas de infraestrutura e na integração contínua.  Porém, as soluções envolvem correções no processo de atualização dos arquivos e do index (fix update index file), indicando atividades de refatoração no processo de release e gerenciamento de versões.  A combinação de correções de bugs e melhorias no processo de build e deploy justificam a classificação 'Ambos'."
96,55609,"2024-10-30 19:55:56","2024-11-03 04:45:55","2024-11-03 05:07:59","Regression in `fs.readFile` ","### Version

v23.1.0

### Platform

```text
Linux akait-notebook 6.8.0-47-generic #47-Ubuntu SMP PREEMPT_DYNAMIC Fri Sep 27 21:40:26 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux
```


### Subsystem

_No response_

### What steps will reproduce the bug?

```js
const fs = require(""fs"");

fs.readFile(""/"", err => {
	console.log(err);
});

fs.readFile(""/"", err => {
	console.log(err);
});
```


### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

Like in `Node.js@22`, each callback should be run with `err` and `code` should be `EISDIR`

### What do you see instead?

The call happens only once for the first call and the callbacks are not called instead an error is thrown like for sync function

### Additional information

Ref: https://github.com/webpack/webpack/pull/18891","closed","alexander-akait",4567934,"{confirmed-bug,fs,regression,v23.x}","https://github.com/nodejs/node/issues/55609",7,"Testes de Regressão",NULL,3,"versão 23.1 plataforma linux subsystem resposta passo reproduzir erro ler arquivo diretório esperar comportamento nodejs 22 callback executar erro código eisdir ver invocar primeira vez callback chamar erro lançar função adicional informação
","O título da issue menciona ""Regression"" (Regressão) e os comentários incluem termos como ""regression introduce"", ""regression revert"", ""bisect"" (que sugere testes de bisseção para identificar a regressão) e ""patch release"" (que indica a necessidade de um patch para corrigir a regressão).  A descrição do problema descreve um erro de comportamento, focando na reprodução e na identificação da causa do erro, o que é típico de um processo de testes de regressão."
97,55577,"2024-10-28 22:19:36","2024-11-14 12:37:09","2024-11-14 12:37:09","fetch data from sqllite module give me  'ERR_SQLITE_ERROR',","### Version

v22.10.0

### Platform

```text
windows 10 x64
```


### Subsystem

_No response_

### What steps will reproduce the bug?

`import path from 'node:path';


import {DatabaseSync} from 'node:sqlite'

export class Connectdb{

    dbConnectionString:string;

    database:any

    constructor(dbConnectionString:string){

        this.dbConnectionString=dbConnectionString

    }

    Connect(){

        this.database=new DatabaseSync(this.dbConnectionString);

    }

    RetriveData() {

        const query = this.database.prepare('SELECT * FROM ""titles"" ');  

        console.log(query.all())

    }

}

    let obj=new Connectdb('../database.db')

    obj.Connect()

    obj.RetriveData()
`

### How often does it reproduce? Is there a required condition?

always it produce

### What is the expected behavior? Why is that the expected behavior?

get data I need

### What do you see instead?

`const query = this.database.prepare('SELECT * FROM ""titles"" ');
                                    ^

Error: no such table: titles
 {
  code: 'ERR_SQLITE_ERROR',
  errcode: 1,
  errstr: 'SQL logic error'
}

`
and titles found in the database

### Additional information

_No response_","closed","sharafabacery",52586357,"{confirmed-bug,windows,sqlite}","https://github.com/nodejs/node/issues/55577",12,"Ambos",NULL,17,"erro sql tabela titulo nao existir banco dados
","A issue relata um erro SQL ('ERR_SQLITE_ERROR') relacionado à inexistência de uma tabela no banco de dados SQLite.  Comentários como 'load database seperate client title existent', 'load db browser sqlite show correctly', 'error table problem', e 'table database exist' indicam que a investigação envolveu testes de regressão para verificar a existência da tabela e os dados.  Por outro lado, a solução envolveu alterações de código ('code week change path basedir databasefile db work problem happen compile ts js need explore repo'), sugerindo refatoração para corrigir o caminho do arquivo de banco de dados.  A combinação de investigação de erros (testes) e alteração de código (refatoração) justifica a classificação 'Ambos'."
99,55539,"2024-10-25 19:46:51","2024-11-06 09:57:16","2024-11-06 09:57:16","ERR_INTERNAL_ASSERTION from console.log(), TypeError: Converting circular structure to JSON","### Version

v20.18.0, v23.1.0

### Platform

```text
Microsoft Windows NT 10.0.19045.0 x64
```


### Subsystem

_No response_

### What steps will reproduce the bug?

```js
import {Bot} from ""@skyware/bot"";

var bot = new Bot({
	emitEvents: false,
	emitChatEvents: true
});
await bot.login({
	identifier: ""..."",
	password: ""...""
});

bot.on(""message"", async message => {
	console.log(message);
});
```

Then send chat message to the bot

### How often does it reproduce? Is there a required condition?

100%, I cannot console.log() an object from someone's library.

### What is the expected behavior? Why is that the expected behavior?

Usually console.log() can log absolutely anything and will never error, circular references would just display [Circular].

### What do you see instead?

```
node:internal/assert:20
  throw new ERR_INTERNAL_ASSERTION(message);
        ^

Error [ERR_INTERNAL_ASSERTION]: Error [ERR_INTERNAL_ASSERTION]: Error [ERR_INTERNAL_ASSERTION]: TypeError: Converting circular structure to JSON
    --> starting at object with constructor 'Bot'
    |     property 'chatEventEmitter' -> object with constructor 'BotChatEmitter'
    --- property 'bot' closes the circle
    at JSON.stringify (<anonymous>)
    at get [Symbol.toStringTag] (file:///C:/Users/me/Desktop/bskychatbot/node_modules/quick-lru/index.js:291:15)
    at formatRaw (node:internal/util/inspect:857:18)
    at formatValue (node:internal/util/inspect:841:10)
    at formatProperty (node:internal/util/inspect:1946:11)
    at formatRaw (node:internal/util/inspect:1055:9)
    at formatValue (node:internal/util/inspect:841:10)
    at formatProperty (node:internal/util/inspect:1946:11)
    at formatRaw (node:internal/util/inspect:1055:9)
    at formatValue (node:internal/util/inspect:841:10)
This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues

    at Function.fail (node:internal/assert:20:9)
    at handleMaxCallStackSize (node:internal/util/inspect:1557:10)
    at formatRaw (node:internal/util/inspect:1063:12)
    at formatValue (node:internal/util/inspect:841:10)
    at formatProperty (node:internal/util/inspect:1946:11)
    at formatRaw (node:internal/util/inspect:1055:9)
    at formatValue (node:internal/util/inspect:841:10)
    at formatProperty (node:internal/util/inspect:1946:11)
    at formatRaw (node:internal/util/inspect:1055:9)
    at formatValue (node:internal/util/inspect:841:10)
This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues

    at Function.fail (node:internal/assert:20:9)
    at handleMaxCallStackSize (node:internal/util/inspect:1557:10)
    at formatRaw (node:internal/util/inspect:1063:12)
    at formatValue (node:internal/util/inspect:841:10)
    at formatProperty (node:internal/util/inspect:1946:11)
This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues

    at Function.fail (node:internal/assert:20:9)
    at handleMaxCallStackSize (node:internal/util/inspect:1557:10)
    at formatRaw (node:internal/util/inspect:1063:12)
    at formatValue (node:internal/util/inspect:841:10)
    at formatProperty (node:internal/util/inspect:1946:11)
Please open an issue with this stack trace at https://github.com/nodejs/node/issues

    at Function.fail (node:internal/assert:20:9)
    at handleMaxCallStackSize (node:internal/util/inspect:1557:10)
    at formatRaw (node:internal/util/inspect:1063:12)
    at formatValue (node:internal/util/inspect:841:10)
    at formatProperty (node:internal/util/inspect:1946:11)
    at Function.fail (node:internal/assert:20:9)
    at handleMaxCallStackSize (node:internal/util/inspect:1557:10)
    at formatRaw (node:internal/util/inspect:1063:12)
    at formatValue (node:internal/util/inspect:841:10)
    at formatProperty (node:internal/util/inspect:1946:11)
    at formatRaw (node:internal/util/inspect:1055:9)
    at formatValue (node:internal/util/inspect:841:10)
    at inspect (node:internal/util/inspect:365:10)
    at handleMaxCallStackSize (node:internal/util/inspect:1557:10)
    at formatRaw (node:internal/util/inspect:1063:12)
    at formatValue (node:internal/util/inspect:841:10)
    at formatProperty (node:internal/util/inspect:1946:11)
    at formatRaw (node:internal/util/inspect:1055:9)
    at formatValue (node:internal/util/inspect:841:10)
    at inspect (node:internal/util/inspect:365:10)
    at formatRaw (node:internal/util/inspect:1055:9)
    at formatValue (node:internal/util/inspect:841:10)
    at inspect (node:internal/util/inspect:365:10)
    at inspect (node:internal/util/inspect:365:10)
    at formatWithOptionsInternal (node:internal/util/inspect:2304:40)
    at formatWithOptions (node:internal/util/inspect:2166:10)
This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues

    at Function.fail (node:internal/assert:20:9)
    at handleMaxCallStackSize (node:internal/util/inspect:1557:10)
    at formatRaw (node:internal/util/inspect:1063:12)
    at formatValue (node:internal/util/inspect:841:10)
    at inspect (node:internal/util/inspect:365:10)
    at formatWithOptionsInternal (node:internal/util/inspect:2304:40)
    at formatWithOptions (node:internal/util/inspect:2166:10)
    at console.value (node:internal/console/constructor:348:14)
    at console.log (node:internal/console/constructor:385:61)
    at Bot.<anonymous> (file:///C:/Users/me/Desktop/bskychatbot/index.mjs:14:10) {
  code: 'ERR_INTERNAL_ASSERTION'
}

Node.js v20.18.0
```

### Additional information

_No response_","closed","ledlamp",103386533,"{confirmed-bug,util,console}","https://github.com/nodejs/node/issues/55539",6,"Refatoração",NULL,12,"erro circular estrutura json bot propriedade chatevent emitter bot  console log objeto biblioteca erro interno asserção tipo erro converter circular estrutura json  node js  uso incorreto node js interno  abrir issue github nodejs node issues  causa erro node js uso incorreto node js interno abrir issue github nodejs node issues  node js
","A issue descreve um erro interno de asserção ('ERR_INTERNAL_ASSERTION') decorrente de um `console.log()` que tenta serializar uma estrutura circular para JSON.  O problema parece ser um erro na estrutura do código que causa um loop infinito ao tentar converter o objeto para JSON.  Os comentários sugerem a necessidade de uma reprodução mínima do erro para melhor diagnóstico e depuração, mas o foco principal é resolver a causa raiz do erro de conversão JSON.  Isso aponta para a necessidade de refatoração do código para evitar a criação de estruturas circulares e corrigir a manipulação de objetos que possam gerar este tipo de erro. Não há menção explícita à execução de testes de regressão, embora a correção do erro certamente melhore a estabilidade do sistema e possa ser verificada por testes."
102,55446,"2024-10-18 17:23:35","2024-10-22 05:00:26","2024-10-22 05:00:26","util/types isBigIntObject not documented","### Affected URL(s)

https://nodejs.org/docs/latest/api/util.html

### Description of the problem

Hi!

Small issue: `isBigIntObject` seems to be present in nodejs (22.9.0) via `'node:util/types'`, but missing from the [documentation](https://nodejs.org/docs/latest/api/util.html) and it is also missing in [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/node/util.d.ts).
","closed","sparecycles",719818,"{confirmed-bug,util,doc,""good first issue""}","https://github.com/nodejs/node/issues/55446",3,"Refatoração",NULL,3,"isBigIntObject presente nodejs documentação DefinitelyTyped
","O título da issue ""util/types isBigIntObject not documented"" indica a necessidade de adicionar documentação à função `isBigIntObject`.  A ausência de documentação é um problema de manutenção e clareza do código, o que caracteriza uma tarefa de refatoração. Os comentários sugerem a criação de um Pull Request (PR), reforçando a natureza corretiva e de melhoria do código, sem menção a testes ou bugs específicos."
103,55410,"2024-10-16 18:44:45","2024-10-21 07:10:48","2024-10-21 07:10:48","`npm pack` crash in Node 23","### Version

v23.0.0

### Platform

```text
Darwin ....local 23.6.0 Darwin Kernel Version 23.6.0: Wed Jul 31 20:48:44 PDT 2024; root:xnu-10063.141.1.700.5~1/RELEASE_X86_64 x86_64
```

same in CI
```
Ubuntu
22.04.5
LTS
```

### Subsystem

_No response_

### What steps will reproduce the bug?

```sh
nvm install 23
corepack enable
npm pack
```

### How often does it reproduce? Is there a required condition?

it's only happening on Node 23.0.0.
No such issues in Node 18, Node 20 and Node 22.

### What is the expected behavior? Why is that the expected behavior?

it should pack

### What do you see instead?

```
(node:9110) ExperimentalWarning: Support for loading ES Module in require() is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
npm warn tarball tarball data for file:/.../ (null) seems to be corrupted. Trying again.
npm warn tarball tarball data for file:/.../ (null) seems to be corrupted. Trying again.
npm error code ENOENT
npm error syscall lstat
npm error path /Users/.../ist/index.cjs
npm error errno -2
npm error enoent ENOENT: no such file or directory, lstat '/.../ist/index.cjs'
npm error enoent This is related to npm not being able to find a file.
npm error enoent
npm error A complete log of this run can be found in: /Users/.../.npm/_logs/2024-10-16T18_41_11_606Z-debug-0.log
```

⚠️ what's interesting is that `ist` is actually `dist` — it's loosing the first letter of the directory name

### Additional information

from `package.json`:

```json lines
  ""files"": [
    ""dist"",
    ""migration"",
    ""*.md""
  ],
```

from `.log` file:

```
0 verbose cli /Users/.../.nvm/versions/node/v23.0.0/bin/node /Users/.../.nvm/versions/node/v23.0.0/bin/npm
1 info using npm@10.9.0
2 info using node@v23.0.0
3 silly config load:file:/Users/.../.nvm/versions/node/v23.0.0/lib/node_modules/npm/npmrc
4 silly config load:file:/Users/.../.npmrc
5 silly config load:file:/Users/.../.npmrc
6 silly config load:file:/Users/.../.nvm/versions/node/v23.0.0/etc/npmrc
7 verbose title npm pack
8 verbose argv ""pack""
9 verbose logfile logs-max:10 dir:/Users/.../.npm/_logs/2024-10-16T18_41_11_606Z-
10 verbose logfile /Users/.../.npm/_logs/2024-10-16T18_41_11_606Z-debug-0.log
11 silly logfile start cleaning logs, removing 1 files
12 silly logfile done cleaning log files
13 silly packumentCache heap:4345298944 maxSize:1086324736 maxEntrySize:543162368
14 warn tarball tarball data for file:/Users/.../ (null) seems to be corrupted. Trying again.
15 warn tarball tarball data for file:/Users/.../ (null) seems to be corrupted. Trying again.
16 verbose stack Error: ENOENT: no such file or directory, lstat '/Users/.../ist/index.cjs'
17 error code ENOENT
18 error syscall lstat
19 error path /Users/.../ist/index.cjs
20 error errno -2
21 error enoent ENOENT: no such file or directory, lstat '/Users/.../ist/index.cjs'
22 error enoent This is related to npm not being able to find a file.
22 error enoent
23 verbose cwd /Users/...
24 verbose os Darwin 23.6.0
25 verbose node v23.0.0
26 verbose npm  v10.9.0
27 verbose exit -2
28 verbose code -2
29 error A complete log of this run can be found in: /Users/.../.npm/_logs/2024-10-16T18_41_11_606Z-debug-0.log
```
","closed","RobinTail",13189514,"{confirmed-bug,npm,regression,v23.x}","https://github.com/nodejs/node/issues/55410",16,"Ambos",NULL,5,"problema npm pack falha node versão encontrar arquivo dist diretório nome incorreto primeira letra faltando  ocorrer node versão problema node versão  node versão node versão  esperado pacote criar  erro enoent lstat arquivo encontrar  interessante dist realmente dist  primeira letra diretório nome perder arquivo pacote json arquivo dist migration md  log arquivo informação adicional  verbose cli user nvm version node v bin node user nvm version node v bin npm info use npm info use node verbose title npm pack verbose argv pack verbose logfile logs max dir user npm logs z debug log verbose logfile user npm logs z debug log silly logfile start cleaning logs removing file silly logfile done cleaning log file silly packumentcache heap maxsize maxentrysize warn tarball tarball data user null seem corrupt try warn tarball tarball data user null seem corrupt try verbose stack error enoent no such file directory lstat user ist index cjs error code enoent error syscall lstat error path user ist index cjs error errno error enoent enoent no such file directory lstat user ist index cjs error enoent relat npm unable find file error enoent verbose cwd user verbose os darwin verbose node v verbose npm v verbose exit verbose code error complete log run found user npm logs z debug log
","A issue relata um erro no comando `npm pack` que falha ao encontrar um arquivo devido a um problema de caminho.  Os comentários indicam tentativas de reprodução do erro, investigação da causa raiz, e menção a um `git bisect` que localizou o problema em um commit que envolve correção de caminho ('path fix bug inconsistency').  Há também discussões sobre a estrutura de diretórios e versões do Node.js, o que sugere que a solução pode envolver tanto refatoração de código (correção do caminho) quanto testes de regressão (para garantir que o problema não ocorra novamente em outras versões ou cenários)."
109,55120,"2024-09-25 18:18:34","2024-10-18 00:21:30","2024-10-18 00:21:30","`structuredClone` Serializing a non-serializable platform object succeeds","In Node.js, the following snippet succeeds, whereas, in the browser, it throws a `DataCloneError`:

```js
structuredClone(new Response());
```

This is causing the following WPT to fail:
```js
structuredCloneBatteryOfTests.push({
  description: 'Serializing a non-serializable platform object fails',
  async f(runner, t) {
    const request = new Response();
    await promise_rejects_dom(
      t,
      ""DataCloneError"",
      runner.structuredClone(request)
    );
  }
});
```","closed","avivkeller",38299977,"{confirmed-bug,web-standards}","https://github.com/nodejs/node/issues/55120",8,"Ambos",NULL,22,"node js snippet sucesso navegador lancar datacloneerror serializar objeto plataforma serializar falha
","O título da issue indica um problema de compatibilidade entre navegadores e Node.js na serialização de objetos (`structuredClone`).  Comentários discutem a necessidade de testes de regressão (WPT - Web Platform Tests) para refletir o comportamento correto e a  possibilidade de modificação nos testes existentes, indicando a necessidade de testes de regressão.  Também há discussão sobre a necessidade de alterações no código do Undici para alinhar o comportamento com o esperado, sugerindo refatoração para resolver a incompatibilidade entre diferentes ambientes (browser e Node.js). A discussão abrange a compatibilidade, a necessidade de ajustes no código e nos testes, indicando que ambos os aspectos são relevantes para a solução do problema."
113,54931,"2024-09-13 18:56:36","2024-09-19 10:34:15","2024-11-08 11:19:24","detect-module: Typeless module syntax detection does not report unsettled top-level await","### Version

v22.8.0

### Platform

```text
N/A
```


### Subsystem

_No response_

### What steps will reproduce the bug?

Create a `repro.js` file:
```js
await new Promise(() => {});
```

Run `repro.js`

### How often does it reproduce? Is there a required condition?

Every time

### What is the expected behavior? Why is that the expected behavior?

It should output the same as if the file was named `repro.mjs`:
```
Warning: Detected unsettled top-level await at file:///repro.mjs:1
await new Promise(() => {});
^
```

### What do you see instead?

Silently exits.

### Additional information

Ref: #54930","closed","avivkeller",38299977,"{confirmed-bug,module,esm,loaders}","https://github.com/nodejs/node/issues/54931",2,"Refatoração",NULL,6,"repro js file await promise run repro js every time output file name repro mjs warning detect unsettled top level await await promise silent exit ref
","A issue descreve um problema na detecção de sintaxe de módulos sem tipo ('Typeless module syntax detection').  O corpo da issue menciona a necessidade de evitar penalidades de desempenho ('avoid performance penalty syntax detection') e sugere adicionar 'type module' ao package.json.  Os comentários também discutem melhorias na detecção de sintaxe.  Essas ações indicam uma necessidade de refatoração do código para melhorar a detecção de sintaxe de módulos, sem necessariamente envolver testes de regressão, apesar de melhorias como essa poderem necessitar de testes posteriormente."
115,54773,"2024-09-04 19:01:29","2024-09-11 21:48:04","2024-09-11 21:48:04","Error [ERR_INTERNAL_ASSERTION]: This is caused by either a bug in Node.js or incorrect usage of Node.js internals.","### Version

Node.js v22.7.0

### Platform

```text
at assert (node:internal/assert:14:11)
    at ModuleLoader.getModuleJobForRequire (node:internal/modules/esm/loader:329:5)     
    at new ModuleJobSync (node:internal/modules/esm/module_job:313:34)
    at ModuleLoader.importSyncForRequire (node:internal/modules/esm/loader:314:11)      
    at loadESMFromCJS (node:internal/modules/cjs/loader:1381:24)
    at Module._compile (node:internal/modules/cjs/loader:1503:5)
    at Module._extensions..js (node:internal/modules/cjs/loader:1691:10)
    at Module.load (node:internal/modules/cjs/loader:1317:32)
    at Module._load (node:internal/modules/cjs/loader:1127:12)
    at TracingChannel.traceSync (node:diagnostics_channel:315:14) {
  code: 'ERR_INTERNAL_ASSERTION'
}
```


### Subsystem

_No response_

### What steps will reproduce the bug?

at assert (node:internal/assert:14:11)
    at ModuleLoader.getModuleJobForRequire (node:internal/modules/esm/loader:329:5)     
    at new ModuleJobSync (node:internal/modules/esm/module_job:313:34)
    at ModuleLoader.importSyncForRequire (node:internal/modules/esm/loader:314:11)      
    at loadESMFromCJS (node:internal/modules/cjs/loader:1381:24)
    at Module._compile (node:internal/modules/cjs/loader:1503:5)
    at Module._extensions..js (node:internal/modules/cjs/loader:1691:10)
    at Module.load (node:internal/modules/cjs/loader:1317:32)
    at Module._load (node:internal/modules/cjs/loader:1127:12)
    at TracingChannel.traceSync (node:diagnostics_channel:315:14) {
  code: 'ERR_INTERNAL_ASSERTION'
}

### How often does it reproduce? Is there a required condition?

Fisrt time

### What is the expected behavior? Why is that the expected behavior?

![image](https://github.com/user-attachments/assets/df1eec43-8fbf-4026-a86c-e97dbf95d8cd)


### What do you see instead?

![image](https://github.com/user-attachments/assets/8ea3ca89-b03c-4f0d-bd23-26010a6124d5)


### Additional information

_No response_","closed","Mongsplaatjies",13884629,"{confirmed-bug,esm,strip-types}","https://github.com/nodejs/node/issues/54773",7,"Nenhum",NULL,7,"node v22 assertion error module load internal module reproduce time expect behavior see instead
","A issue descreve um erro de asserção em Node.js (ERR_INTERNAL_ASSERTION).  O corpo e os comentários focam na reprodução do erro e na necessidade de mais informações para debug. Não há menção a refatoração de código ou testes de regressão. A discussão gira em torno de encontrar a causa raiz do problema e fornecer um exemplo mínimo reprodutível, atividades não diretamente relacionadas a refatoração ou testes."
116,54756,"2024-09-04 05:23:58","2024-09-23 00:32:08","2024-09-23 00:32:08","Bad error message in `--experimental-test-coverage` output when a source maps source module is missing","### Version

v22.8.0

### Platform

```text
Darwin TRI-N93DLJDY6Y 23.6.0 Darwin Kernel Version 23.6.0: Mon Jul 29 21:14:30 PDT 2024; root:xnu-10063.141.2~1/RELEASE_ARM64_T6000 arm64
```


### Subsystem

_No response_

### What steps will reproduce the bug?

In `dist/a.mjs`:

```js
console.log(""Hi"");
export {};
//# sourceMappingURL=a.mjs.map
```

In `dist/a.mjs.map`:

```
{""version"":3,""file"":""a.mjs"",""sourceRoot"":"""",""sources"":[""../src/a.mts""],""names"":[],""mappings"":""AAAA,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC""}
```

In `test.mjs`:

```js
import ""./dist/a.mjs"";
```

Then, run:

```sh
node --experimental-test-coverage --test test.mjs
```

### How often does it reproduce? Is there a required condition?

Every time.

### What is the expected behavior? Why is that the expected behavior?

An error message reported after the tests output, explaining that a particular source module at a path is missing. If multiple are missing, then output the list of missing paths.

### What do you see instead?

```
Hi
✔ test.mjs (46.715834ms)
ℹ Warning: Could not report code coverage. TypeError: Cannot read properties of undefined (reading '0')
ℹ tests 1
ℹ suites 0
ℹ pass 1
ℹ fail 0
ℹ cancelled 0
ℹ skipped 0
ℹ todo 0
ℹ duration_ms 51.063542
```

### Additional information

This scenario comes up very frequently when working in a TypeScript project with source maps enabled, that has `src` and `dist` directories. Often you have a build script watching the `src` directory, and as you work you rename or delete a source module. The result is that old artifacts don't get cleaned in the `dist` directory, but the next time the tests run on the `dist` directory the coverage explodes with the error this issue reports.

Note that if multiple test modules run, then the coverage report for everything is obscured by the error message:

```
ℹ Warning: Could not report code coverage. TypeError: Cannot read properties of undefined (reading '0')
```","closed","jaydenseric",1754873,"{confirmed-bug,coverage,""source maps"",test_runner}","https://github.com/nodejs/node/issues/54756",5,"Ambos",NULL,19,"version v22 8 platform darwin kernel version root release arm subsystem response step reproduce bug dist a mjs console log hi export dist a mjs map version file a mjs sourceroot source name mapping aaaa oaa o caac gaag caac iaai caac caac test mjs import dist a mjs run node experimental test coverage test mjs reproduce often require condition every time expect behavior error message report test output explain particular source module path miss multiple miss output list miss path see instead hi warning could report code coverage typeerror read properti undefined read test suite pass fail cancel skip todo duration additional information scenario come frequentli work typescript project source map enable src dist directori often build script watch src directori work rename delete source module result old artifact get clean dist directori next time test run dist directori coverage explode error issu report note multiple test module run coverage report everyth obscur error message warning could report code coverage typeerror read properti undefined read
","O título da issue indica um problema na mensagem de erro de cobertura de testes (`--experimental-test-coverage`), sugerindo a necessidade de refatoração da mensagem de erro.  O corpo e os comentários descrevem o problema, como reproduzi-lo e sugerem soluções envolvendo testes e a adição de um teste de caso.  A discussão sobre a mensagem de erro e a adição de um teste indicam que tanto refatoração (da mensagem de erro) quanto testes de regressão (para evitar a recorrência do problema) são necessários."
117,54726,"2024-09-03 04:12:00","2024-09-13 02:51:36","2024-09-13 02:51:36","test_runner: `latest.js` file is included by default","### Version

v22.7.0

### Platform

_No response_

### Subsystem

_No response_

### What steps will reproduce the bug?

1. Create an empty `latest.js` file
2. Run the Node.js test runner

```shell
fnm use 20
# Using Node v20.17.0

node --test
# ℹ tests 0
# ℹ suites 0
# ℹ pass 0
# ℹ fail 0
# ℹ cancelled 0
# ℹ skipped 0
# ℹ todo 0
# ℹ duration_ms 4.365042
```

```shell
fnm use 22
# Using Node v22.7.0

node --test
# ✔ latest.js (43.960958ms)
# ℹ tests 1
# ℹ suites 0
# ℹ pass 1
# ℹ fail 0
# ℹ cancelled 0
# ℹ skipped 0
# ℹ todo 0
# ℹ duration_ms 53.687041
```

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

> By default, Node.js will run all files matching these patterns:

```
**/*.test.?(c|m)js
**/*-test.?(c|m)js
**/*_test.?(c|m)js
**/test-*.?(c|m)js
**/test.?(c|m)js
**/test/**/*.?(c|m)js
```

https://nodejs.org/api/test.html#running-tests-from-the-command-line

### What do you see instead?

`latest.js` filename does not match the above patterns, but is included in `node --test`

### Additional information

_No response_","closed","hyunbinseo",47051820,"{confirmed-bug,regression,test_runner,v22.x}","https://github.com/nodejs/node/issues/54726",1,"Ambos",NULL,10,"criar arquivo vazio latest.js executar node.js test runner node v20 teste nenhum teste node v22 teste latest.js executar comportamento esperado node.js executar arquivo padrão padrão teste comportamento observado latest.js arquivo corresponder padrão incluir node teste
","O título da issue sugere um problema relacionado a testes ('test_runner'), enquanto o corpo menciona a necessidade de criar um arquivo vazio ('latest.js') e ajustes no processo de execução de testes.  A menção a padrões de correspondência ('regex match pattern') e a solução proposta via pull request reforça a natureza de refatoração.  Portanto, a issue abrange tanto testes de regressão (ajuste no processo de execução de testes) quanto refatoração (criação de arquivo e ajustes no processo)."
122,54543,"2024-08-24 16:43:25","2024-08-29 10:07:08","2024-11-05 17:38:26","UTF+8 encodings are broken","### Version

22.7.0

### Platform

```text
Linux api-deployment-694785c9f5-8dd8j 5.10.223-211.872.amzn2.x86_64 #1 SMP Mon Jul 29 19:52:29 UTC 2024 x86_64 GNU/Linux
```


### Subsystem

_No response_

### What steps will reproduce the bug?

Hey everyone, I'm not sure how to reproduce but latest node can't parse UTF+8 anymore. It works for the first minute or two (or couple hours if I remove Datadog APM instrumentation) but then returns garbage on the same request. I'm just using postgres.js to fetch and nest.js for the HTTP server. No fancy buffer manipulation.

```
curl --location 'https://api.vapi.ai/assistant/205deb59-755c-489c-8879-7523b1318ed8' \
--header 'Accept: application/json' \
--header 'Authorization: Bearer XXXXXX'
{""id"":""205deb59-755c-489c-8879-7523b1318ed8"",""orgId"":""7616920b-4696-458b-a2aa-3453fd13ace4"",""name"":""éñüçßÆ"",""createdAt"":""2024-08-24T08:58:16.110Z"",""updatedAt"":""2024-08-24T08:58:16.110Z"",""isServerUrlSecretSet"":false}%
 
## 2 minutes later      
curl --location 'https://api.vapi.ai/assistant/205deb59-755c-489c-8879-7523b1318ed8' \
--header 'Accept: application/json' \
--header 'Authorization: Bearer XXXXXX'
{""id"":""205deb59-755c-489c-8879-7523b1318ed8"",""orgId"":""7616920b-4696-458b-a2aa-3453fd13ace4"",""name"":""������"",""createdAt"":""2024-08-24T08:58:16.110Z"",""updatedAt"":""2024-08-24T08:58:16.110Z"",""isServerUrlSecretSet"":false}%
```

Note how `éñüçßÆ` gets corrupted.

### How often does it reproduce? Is there a required condition?

Restart the process, it works for sometime and then corrupts itself.

### What is the expected behavior? Why is that the expected behavior?

It should keep returning the current text.

### What do you see instead?

Garbage text

### Additional information

_No response_","closed","nikhilro",22201788,"{confirmed-bug,buffer,regression,v22.x}","https://github.com/nodejs/node/issues/54543",18,"Ambos",NULL,5,"node parse utf problema postgres js nest js servidor http texto corromper reiniciar processo funcionar tempo corromper retornar texto atual lixo texto
","A issue relata problemas com codificação UTF-8, afetando tanto o funcionamento do código (Refatoração necessária para corrigir a manipulação de strings e codificação) quanto os testes de regressão (evidenciado por múltiplos comentários sobre testes, reprodução do erro, e menções à necessidade de cobertura de testes melhorada).  Comentários como ""encoding commit"", ""check fix"", e menções a testes em diferentes sistemas operacionais (Apple Silicon, Linux) e bancos de dados (PostgreSQL) indicam a necessidade de testes de regressão.  A busca pela causa raiz e a menção a patches e correções indicam necessidade de refatoração do código."
123,54521,"2024-08-23 10:59:23","2024-08-29 12:01:56","2024-08-29 12:02:09","Buffer.from() output breaks after optimizing in nodejs 22.7","### Version

v22.7.0

### Platform

```text
Darwin moe.fritz.box 23.5.0 Darwin Kernel Version 23.5.0: Wed May  1 20:13:18 PDT 2024; root:xnu-10063.121.3~5/RELEASE_ARM64_T6030 arm64
```


### Subsystem

Buffer

### What steps will reproduce the bug?

```
let i = 0;
for(; i < 1_000_000; i++) {
  const ashex = Buffer.from(""\x80"").toString(""hex"");
  if (ashex === '80')
    break;
 else if(ashex !== 'c280')
    console.log(""Unexpected return value"", ashex); //this never happened for me
}

if(i<1_000_000) {
  console.log(""FAILED after %d iterations"",i);
  process.exit(1);
} else
  console.log(""PASSED after %d iterations"",i);
```


### How often does it reproduce? Is there a required condition?

For me, it will consistently fail somewhere between 7000 to 1200 iterations.

### What is the expected behavior? Why is that the expected behavior?

In node 20 this code does not fail , even after 1_000_000 iterations. `Buffer.from(""\x80"").toString(""hex"")` always returns `c280` on node 20

### What do you see instead?

`Buffer.from(""\x80"").toString(""hex"")` incorrectly returns `80` after sufficient iterations

### Additional information

_No response_","closed","unilynx",2772353,"{confirmed-bug,buffer,regression,v22.x}","https://github.com/nodejs/node/issues/54521",20,"Ambos",NULL,6,"buffer node iteração retorno valor inesperado falha consistentemente  código comportamento esperado  diferente versão node
","O título da issue indica um problema de regressão após otimização em Node.js ('Buffer.from() output breaks after optimizing in nodejs 22.7'), sugerindo a necessidade de testes de regressão.  Os comentários discutem a correção de um bug relacionado à manipulação de strings UTF-8, envolvendo otimizações ('v8 fastwrite string buffer length', 'simdutf memcpy replace invalid utf8 routine', 'look slow implementation replace invalid utf8 flag'),  indicando que a solução provavelmente envolveu refatoração do código para corrigir o erro e melhorar a performance. A menção a 'PASSED' e 'FAILED' iterações nos comentários reforça a realização de testes."
126,54472,"2024-08-21 05:58:57","2024-09-02 01:42:45","2024-09-02 01:42:45","Assigning a value to Array.prototype[1] will result in an error ：node:internal/process/task_queues:77           callback();","### Version

v20.14.0

### Platform

```text
Microsoft Windows NT 10.0.22631.0
x64
```


### Subsystem

_No response_

### What steps will reproduce the bug?

**code:**
Array.prototype[1] = 2
console.log(Array.prototype);

**result:**
![image](https://github.com/user-attachments/assets/f3a9e0cb-ea9c-47cd-ad2e-1a8e6996e0de)


### How often does it reproduce? Is there a required condition?

When I knew that Array.prototype was an Array, I tried to assign a value to Array.prototype[x].
Assigning only Array.prototype[1] results in an error that will occur when reading Array.prototype.

### What is the expected behavior? Why is that the expected behavior?

**In Chrome, you will get the following results：**

Array.prototype[1] = 2
console.log(Array.prototype);

**result:** 
     [1: 2, at: ƒ, concat: ƒ, copyWithin: ƒ, fill: ƒ, find: ƒ, …]

![image](https://github.com/user-attachments/assets/c77be70b-7415-418c-9a37-7d1be28767bf)



### What do you see instead?

**code:** 
Array.prototype[1] = 2
console.log(Array.prototype);

**result:** 
Object(2) [ <1 empty item>, 2 ]
node:internal/process/task_queues:77
          callback();
          ^
TypeError: callback is not a function
    at process.processTicksAndRejections (node:internal/process/task_queues:77:11)

Node.js v20.14.0

![image](https://github.com/user-attachments/assets/bc6f3051-5d3a-4afe-b36a-fb8622e451f8)


### Additional information

_No response_","closed","LoongZP",49547352,"{confirmed-bug,process,async_hooks}","https://github.com/nodejs/node/issues/54472",27,"Ambos",NULL,12,"reproduzir erro atribuir valor array prototype x acessar array prototype chrome resultado array prototype elemento atribuir valor array prototype resultado objeto tipoerro callback função nodejs
","O título e o corpo da issue descrevem um erro relacionado à atribuição de valores a `Array.prototype`, indicando um problema de funcionamento do Node.js.  Os comentários discutem tentativas de reprodução do erro em diferentes versões do Node.js e diferentes sistemas operacionais, sugerindo a necessidade de testes de regressão para verificar a correção do problema em várias plataformas e versões. Além disso, há discussões sobre a possibilidade de refatoração do código do Node.js para evitar esse tipo de erro no futuro, prevenindo a poluição do protótipo e melhorando a mensagem de erro.  A combinação desses aspectos (debug, testes e discussão sobre refatoração) justifica a classificação como 'Ambos'."
129,54282,"2024-08-09 06:56:02","2024-08-09 14:32:17","2024-08-09 14:32:17","`private constructor` is not supported in nodejs 22.6.0","### Version

v22.6.0

### Platform

```text
Microsoft Windows NT 10.0.22631.0 x64
```


### Subsystem

_No response_

### What steps will reproduce the bug?

1. write code
```ts
// src/index.ts
class PrivateConstructor {
  private constructor() {}
  static create() {
    return new PrivateConstructor()
  }
}

const ins = PrivateConstructor.create()

console.log(ins)

```
2. run `node --experimental-strip-types src/index.ts` with node@22.6.0

### How often does it reproduce? Is there a required condition?

nodejs@22.6.0 and use the flag `--experimental-strip-types`

### What is the expected behavior? Why is that the expected behavior?

Run successfully and output the object

### What do you see instead?

![image](https://github.com/user-attachments/assets/243429d0-5821-4129-bd64-d1732f68e3d8)

### Additional information

_No response_","closed","mowtwo",41664636,"{confirmed-bug,strip-types}","https://github.com/nodejs/node/issues/54282",8,"Refatoração",NULL,0,"node experimental strip type classe construtor privado criar objeto sucesso imagem
","O título da issue indica um problema de compatibilidade com o Node.js 22.6.0 relacionado a construtores privados (`private constructor`).  O corpo da issue menciona a criação de objetos e o uso de TypeScript. Os comentários mencionam PRs (Pull Requests),  'swc' (provavelmente um compilador), e correções de código.  Isso sugere uma necessidade de adaptação do código para funcionar com a nova versão do Node.js, caracterizando uma tarefa de refatoração, sem foco principal em testes de regressão, embora os testes sejam provavelmente necessários após a refatoração."
130,54261,"2024-08-08 01:09:32","2024-08-12 14:48:40","2024-08-12 14:48:40","`pathToFileURL` function in url fails to handle `\\?\UNC\` Prefix properly","### Version

22.5.1

### Platform

```text
Microsoft Windows NT 10.0.22631.0 x64
```


### Subsystem

_No response_

### What steps will reproduce the bug?

```javascript
const { pathToFileURL } = require('url');

console.log(pathToFileURL('\\\\?\\UNC\\server\\share\\folder\\file.txt').href); 
// output: 'file:///UNC/server/share/folder/file.txt'
```

### How often does it reproduce? Is there a required condition?

Anytime

### What is the expected behavior? Why is that the expected behavior?

According to the [Microsoft documentation on maximum file path limitations](https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=registry), the \\?\UNC\ prefix are not used as part of the path itself. so it should be ignored when converting to a file URI. The current implementation does not adhere to this guideline, resulting in incorrect URL conversions. Its output should be `file://server/share/folder/file.txt.`

### What do you see instead?

`file:///UNC/server/share/folder/file.txt
`

### Additional information

_No response_","closed","injunchoi98",80089617,"{confirmed-bug,url,windows}","https://github.com/nodejs/node/issues/54261",3,"Refatoração",NULL,5,"versão 22.5.1 plataforma microsoft windows nt 10 x64 subsistema resposta passo reproduzir erro implementação atual aderir diretriz resultar conversão url incorreta saída arquivo servidor share folder file txt comportamento esperado documentação microsoft limitação caminho arquivo prefixo unc usar parte caminho ignorar converter uri arquivo conversão incorreta ver arquivo unc server share folder file txt informação adicional resposta
","O título da issue indica um problema na função `pathToFileURL` relacionada ao tratamento incorreto de prefixos \\?\UNC\.  O corpo da issue descreve um comportamento inesperado da função e sugere uma correção na conversão de URLs.  Não há menção explícita a testes de regressão, embora uma correção possa exigir testes subsequentes para garantir que a refatoração não introduza novos problemas. A ênfase está na correção de uma funcionalidade existente, o que caracteriza uma refatoração."
145,52825,"2024-05-03 16:05:43","2024-05-12 07:46:30","2024-05-12 07:46:30","cpu-prof doesn't propagate to workers when env is set ","### Version

20.8.1

### Platform

Linux ushanka-housing 6.5.0-1020-oem #21-Ubuntu SMP PREEMPT_DYNAMIC Wed Apr  3 14:54:32 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

cpu-prof

### What steps will reproduce the bug?

You can reproduce this by modifying one of the existent node tests. 

If you edit `tests/fixtures/workload/fibonacci-worker.js` in this repo with

```diff
-new Worker(path.join(__dirname, 'fibonacci.js'));
+new Worker(path.join(__dirname, 'fibonacci.js'), {env: process.env});
```

and then run 
```
node ./test/sequential/test-cpu-prof-dir-worker.js
```

the new test will fail

### How often does it reproduce? Is there a required condition?

This should reproduce 100% of the time -- you don't need to do anything special

### What is the expected behavior? Why is that the expected behavior?

According to https://nodejs.org/docs/latest-v20.x/api/worker_threads.html#new-workerfilename-options, the default value for a worker thread's env is process.env. Thus, not passing an environment and passing process.env as the environment should always produce the same behavior. 

### What do you see instead?

When running in its original form, the test produces two profile files, as intended. When passing `{env: process.env}` into the worker invocation, however, it only produces one profile file. 

### Additional information

If I print the environment in the worker thread, it appears to be identical in both cases. It doesn't seem like the problem is that part of the environment is getting lost, but rather there's some hidden variable that isn't getting propagated","closed","orinatic",1088443,"{confirmed-bug,""lib / src"",worker}","https://github.com/nodejs/node/issues/52825",5,"Ambos",NULL,9,"reproduzir modificar teste existente editar testsfixturesworkloadfibonacciworkerjs repo worker path join dirname fibonaccijs worker path join dirname fibonaccijs env processenv executar testsequentialtestcpuprofdirworkerjs teste falhar reproduzir tempo condicao especial reproduzir tempo especial comportamento esperado comportamento esperado nodejsorgdocslatestv20xapiworkerthreadshtml valor padrao worker thread env processenv passar ambiente passar processenv ambiente produzir comportamento passar env processenv worker invocacao produzir arquivo perfil imprimir ambiente worker thread parecer identico caso parecer problema parte ambiente perder variavel escondida propagar
","O título da issue sugere um problema de propagação de variáveis de ambiente para workers ('cpu-prof doesn't propagate to workers when env is set'), indicando a necessidade de refatoração no código para corrigir esse comportamento.  Os comentários e o corpo da issue mencionam testes ('reproduzir modificar teste existente', 'executar testsequentialtestcpuprofdirworkerjs teste falhar'), indicando que testes de regressão são necessários para verificar a correção do problema após a refatoração. A menção a testes existentes a serem modificados e novos testes a serem executados reforça a necessidade de ambos os tipos de trabalho."
132,54255,"2024-08-07 21:49:53","2025-01-24 16:22:56","2025-01-24 16:22:56","`dotenv::GetPathFromArgs` matches `--env-file*`","### Version

v22.5.1 (and `main`)

### Platform

```text
Linux ... 6.8.11-amd64 #1 SMP PREEMPT_DYNAMIC Kali 6.8.11-1kali2 (2024-05-30) x86_64 GNU/Linux
```


### Subsystem

dotenv

### What steps will reproduce the bug?

https://github.com/nodejs/node/blob/54119757a39a9f51cc58a936d74f001177b247d7/src/node_dotenv.cc#L18

The above linked code snippets incorrectly matches any argument beginning with `--env-file`.

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

```console
$ node --env-file-ABCD env.file                                         
node: bad option: --env-file-ABCD
```

### What do you see instead?

```console
$ node --env-file-ABCD env.file
node: env.file: not found
```

### Additional information

I have a patch for this, see https://github.com/nodejs/node/pull/54237#discussion_r1707937883. I figured I'd open this issue for tracking the bug.","closed","avivkeller",38299977,"{confirmed-bug,dotenv}","https://github.com/nodejs/node/issues/54255",0,"Refatoração",NULL,170,"código incorreto correspondência argumento iniciar env file sempre comportamento esperado erro opção comportamento observado arquivo não encontrado patch disponível rastrear erro
","O título da issue sugere uma correção em `dotenv::GetPathFromArgs` para que corresponda corretamente ao argumento `--env-file*`.  O corpo menciona 'código incorreto' e a disponibilidade de um 'patch', indicando a necessidade de ajustes no código existente, sem mencionar explicitamente testes ou novas funcionalidades. A ausência de comentários reforça a ideia de uma refatoração focada na correção de um bug."
135,54100,"2024-07-29 11:08:16","2024-08-03 16:46:58","2024-08-03 16:46:58","Experimental Permissions: Checks from fs functions that accept Buffers fail with TypeError","### Version

v22.5.1

### Platform

```text
Linux e0c5ff99f631 6.9.8-orbstack-00170-g7b4100b7ced4 #1 SMP Thu Jul 11 03:32:20 UTC 2024 aarch64 GNU/Linux
```


### Subsystem

File system

### What steps will reproduce the bug?

I saw this directly when when attempting a recursive delete. E.g.

`script.js`:
```js
const fs = require('fs');
const pathBuffer = Buffer.from('/tmp/.mydir');
await fs.promises.rm(pathBuffer, { recursive: true })
```

Execute this with something like `node --experimental-permission --allow-fs-write /tmp* script.js`


### How often does it reproduce? Is there a required condition?

This always happens provided the experimental-permission flag is set.

### What is the expected behavior? Why is that the expected behavior?

Expected behaviour is that the permissions checking code allows a Buffer to be provided containing the path.

### What do you see instead?

Error:

```console
TypeError: The ""reference"" argument must be of type string. Received an instance of Buffer
    at Object.has (node:internal/process/permission:25:7)
    at lstat (node:fs:1551:45)
    at _rimraf (node:internal/fs/rimraf:67:3)
    at rimraf (node:internal/fs/rimraf:46:3)
    at node:internal/fs/rimraf:145:7
    at Array.forEach (<anonymous>)
    at node:internal/fs/rimraf:142:5
    at FSReqCallback.oncomplete (node:fs:187:23) {
  code: 'ERR_INVALID_ARG_TYPE'
```

From the looks of it, the code in `.has` that calls `validateString` needs to permit buffers as well for the reference argument.

### Additional information

_No response_","closed","alistairjevans",19165743,"{confirmed-bug,permission}","https://github.com/nodejs/node/issues/54100",7,"Ambos",NULL,5,"erro tipo referencia argumento tipo string recebido instancia buffer codigo chama validateString precisa permitir buffers argumento referencia permissoes codigo permite buffer caminho
","O título da issue sugere um problema de regressão ('Experimental Permissions: Checks from fs functions... fail with TypeError'), indicando um comportamento inesperado após uma alteração.  O corpo e os comentários discutem a necessidade de ajustar a validação de argumentos para permitir buffers, o que aponta para uma necessidade de refatoração do código ('erro tipo referencia argumento tipo string recebido instancia buffer codigo chama validateString precisa permitir buffers argumento referencia permissoes codigo permite buffer caminho'). A combinação de um problema de regressão e a necessidade de modificação no código indica que a classificação é 'Ambos'."
137,53908,"2024-07-17 19:39:31","2024-07-22 18:25:31","2024-07-22 18:25:31","Incorrect slice() from fs.openAsBlob()","### Version

v22.5.0

### Platform

```text
Linux penguin 6.6.32-02873-ge0e03a627715 #1 SMP PREEMPT Mon, 1 Jul 2024 20:29:42 +0000 aarch64 GNU/Linux
```


### Subsystem

_No response_

### What steps will reproduce the bug?

```js
> await fs.promises.writeFile('a.txt', 'abcdefghij')
> blob = await fs.openAsBlob('a.txt')
Blob { size: 10, type: '' }
> await _.text()
'abcdefghij'
> blob.slice(3)
Blob { size: 7, type: '' }
> await _.text()
'defghij'
> blob.slice(3).slice()
Blob { size: 7, type: '' }
> await _.text()
'defg'
```

### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior? Why is that the expected behavior?

`slice()` with no arguments should be equivalent to `slice(0, length)` and return the entire blob; both of those are incorrectly returning something else.

### What do you see instead?

The returned `Blob` object purports to have the expected `size`, but when it is read it has the wrong length.

### Additional information

_No response_","closed","jleedev",23022,"{confirmed-bug,fs}","https://github.com/nodejs/node/issues/53908",6,"Refatoração",NULL,5,"slice argumento equivalente retornar inteiro blob incorretamente retornar algo diferente objeto blob pretender tamanho esperado ler comprimento errado
","O título ""Incorrect slice() from fs.openAsBlob()"" e o corpo da issue indicam um problema com a função `slice()` ao lidar com blobs, sugerindo a necessidade de corrigir ou melhorar o código existente.  Os comentários não fornecem evidências de testes de regressão, focando mais em detalhes da reprodução do problema e sugestões para a solução. A ênfase está em corrigir um comportamento incorreto da função, o que caracteriza refatoração."
197,49344,"2023-08-27 07:03:15","2024-01-08 14:39:32","2024-01-10 16:22:49","The env var `NODE_V8_COVERAGE` intermittently causes the process to hang","### Version

20.5.1

### Platform

Darwin [redacted] 22.5.0 Darwin Kernel Version 22.5.0: Mon Apr 24 20:52:24 PDT 2023; root:xnu-8796.121.2~5/RELEASE_ARM64_T6000 arm64

### Subsystem

_No response_

### What steps will reproduce the bug?

Using the environment variable [`NODE_V8_COVERAGE`](https://nodejs.org/api/cli.html#node_v8_coveragedir) when running a Node.js script with the Node.js CLI option `--test` can intermittently cause the process to never exit. On such occasions, (when using `--test-reporter=spec`) the final report of modules that were run as tests, but didn't contain any tests, as well as the final summary of the test/suite/etc. counts, never prints in the console. Running the same script without setting `NODE_V8_COVERAGE` always succeeds as expected.

I have tried for several months to figure out a minimal reproduction for a bug report, but was only encountering the issue in large private codebases at work. You can see discussion about it here:

https://node-js.slack.com/archives/C3910A78T/p1686119658586369

Finally I have encountered the issue in one of my public open source repos and can share it here. Clone this branch:

https://github.com/jaydenseric/graphql-upload/tree/jaydenseric/node-test-runner

Specifically this commit introduces the issue:

https://github.com/jaydenseric/graphql-upload/commit/3b7f034e1c2d084f314734377c4351c171b87a42

After cloning, run `npm install` and then run the script `npm run tests`. 



### How often does it reproduce? Is there a required condition?

It reproduces perhaps 80% of the time, but for reasons I can't determine this can vary wildly to as much as 100% of the time depending when you run it.

You can prevent the environment variable `NODE_V8_COVERAGE` being set by changing the `tests` script:

https://github.com/jaydenseric/graphql-upload/blob/3b7f034e1c2d084f314734377c4351c171b87a42/package.json#L89

```diff
-    ""tests"": ""coverage-node --test-reporter=spec --test"",
+    ""tests"": ""node --test-reporter=spec --test"",
```

After doing this the script should always succeed, although without a final code coverage report printing.

### What is the expected behavior? Why is that the expected behavior?

When the script intermittently succeeds, it is supposed to look like this:

<img width=""686"" alt=""Screenshot 2023-08-27 at 4 48 17 pm"" src=""https://github.com/nodejs/node/assets/1754873/391abf22-69c4-403e-a448-e63d2e89a367"">

### What do you see instead?

Notice that most of the time, the script permanently hangs at this point:

<img width=""629"" alt=""Screenshot 2023-08-27 at 4 45 09 pm"" src=""https://github.com/nodejs/node/assets/1754873/cfc0d44d-5715-46b2-89c8-799def1707b7"">

At this time the `node` processes in macOS Activity Monitor look like this:

<img width=""1135"" alt=""Screenshot 2023-08-27 at 4 49 38 pm"" src=""https://github.com/nodejs/node/assets/1754873/0fac0885-54d8-480d-bb68-9ee8882fb268"">

If you manually quit the `node` process with a higher ID and high CPU utilisation, the Node.js script exits like this:

<img width=""659"" alt=""Screenshot 2023-08-27 at 4 49 54 pm"" src=""https://github.com/nodejs/node/assets/1754873/c4df339f-cd54-4f0a-9da8-cc93fdb03085"">

### Additional information

Past discussion about this issue:

https://node-js.slack.com/archives/C3910A78T/p1686119658586369","closed","jaydenseric",1754873,"{confirmed-bug,""v8 engine""}","https://github.com/nodejs/node/issues/49344",25,"Ambos",NULL,134,"node script nodejs cli option test intermittently cause process never exit occasion test reporter spec final report module run test contain test final summary test suite count never print console run script setting node v8 coverage always succeed expect try month figure minimal reproduction bug report encounter issue large private codebase work see discussion clone branch npm install run script npm run test clone commit run npm install run script npm run test reproduce perhaps time reason determine vary wildly time depend run prevent environment variable node v8 coverage set change test script script always succeed although final code coverage report print script intermittently succeed suppose look script permanently hang time node process macos activity monitor look manually quit node process higher id high cpu utilisation nodejs script exit past discussion issue
","A issue descreve um problema de travamento intermitente do processo Node.js ao usar a variável de ambiente `NODE_V8_COVERAGE`.  Há menções a testes (especificamente, `npm run test`,  testes de regressão implícitos pela busca de uma solução que funcione com diferentes frameworks de testes e menções repetidas à cobertura de código) e a necessidade de refatoração (implicita na sugestão de melhorias no código relacionado à `finalizationRegistry` para evitar o travamento). A busca por soluções envolve testes de regressão em diferentes versões do Node.js e em diferentes cenários, além da investigação e correção de código relacionado à finalizationRegistry (refatoração). A presença de ambos os aspectos (teste e refatoração) justifica a classificação 'Ambos'."
140,53821,"2024-07-12 13:11:44","2024-07-17 13:56:28","2024-07-17 13:56:42","`fsPromises.glob` doesn't call `exclude` with dirent when called `withFileTypes: true`","### Version

22.4.0

### Platform

```text
Darwin Targos-MBP.local 23.5.0 Darwin Kernel Version 23.5.0: Wed May  1 20:14:38 PDT 2024; root:xnu-10063.121.3~5/RELEASE_ARM64_T6020 arm64
```


### Subsystem

fs

### What steps will reproduce the bug?

```js
mkdir -p a/b
node -e ""Array.fromAsync(require('fs/promises').glob('a/**', { withFileTypes: true, exclude: console.log }))""
```

### How often does it reproduce? Is there a required condition?

Always reproduces when `withFileTypes` is true.

### What is the expected behavior? Why is that the expected behavior?

It should log a Dirent for the `b` directory.

### What do you see instead?

It only prints ""b""

### Additional information

`fs.globSync` is not affected:

```
$ node -e ""require('fs').globSync('a/**', { withFileTypes: true, exclude: console.log })""       
Dirent {
  name: 'b',
  parentPath: '/tmp/a',
  path: '/tmp/a',
  [Symbol(type)]: 2
}
```","closed","targos",2352663,"{confirmed-bug,fs}","https://github.com/nodejs/node/issues/53821",3,"Refatoração",NULL,5,"version platform subsystem fs step reproduce bug mkdir node array fromasync require glob withfiletype exclude expected behavior log dire ent directory see print additional information fsglob sync affect dire ent name parentpath path symbol type
","O título da issue ""`fsPromises.glob` doesn't call `exclude` with dirent when called `withFileTypes: true`"" indica um problema na implementação da função `fsPromises.glob`, sugerindo a necessidade de ajustes no código para corrigir um comportamento inesperado.  O corpo da issue descreve o problema e como reproduzi-lo, mas não há menção explícita a testes de regressão. Os comentários sugerem uma correção ('fix') e a sua inclusão em um pull request ('fix pr land'), reforçando a ideia de que a solução se concentra em modificar o código existente, caracterizando uma refatoração."
147,52764,"2024-04-30 18:56:57","2024-05-04 22:55:51","2024-05-04 22:55:51","test runner runs beforeEach or test case before ""before hook"" finished  ","### Version

v22.0.0

### Platform

Darwin Kernel Version 23.4.0

### Subsystem

test_runner

### What steps will reproduce the bug?

run the following code with node 22.0.0.

```javascript
import assert from ""node:assert/strict"";
import test from ""node:test"";
import { setTimeout } from ""node:timers/promises"";

await test(""test suite"", async (t) => {
  t.before(async () => {
    console.log(""before start"");
    await setTimeout(100);
    console.log(""before end"");
  });

  t.beforeEach(async () => {
    console.log(""beforeEach start"");
    await setTimeout(100);
    console.log(""beforeEach end"");
  });

  t.afterEach(async () => {
    console.log(""afterEach start"");
    await setTimeout(100);
    console.log(""afterEach end"");
  });

  t.after(async () => {
    console.log(""after start"");
    await setTimeout(100);
    console.log(""after end"");
  });

  await t.test(""test case"", async () => {
    console.log(""test case start"");
    await setTimeout(100);
    assert.ok(true);
    console.log(""test case end"");
  });
});
```

the expected output is

```
before start
before end
beforeEach start
beforeEach end
test case start
test case end
afterEach start
afterEach end
after start
after end
```


instead of 

```
before start
beforeEach start << ""beforEach"" strarts before ""before end""
before end
beforeEach end
test case start
test case end
afterEach start
afterEach end
after start
after end
```

If the hooks are not async then the order is correct.

In earlier node version the `await` keyword helped before the hooks but in node 22.0.0 it doesn't work.


### How often does it reproduce? Is there a required condition?

always

### What is the expected behavior? Why is that the expected behavior?

the expected console log is

```
before start
before end
beforeEach start
beforeEach end
test case start
test case end
afterEach start
afterEach end
after start
after end
```


### What do you see instead?

```
before start
beforeEach start << ""beforEach"" strarts before ""before end""
before end
beforeEach end
test case start
test case end
afterEach start
afterEach end
after start
after end
```

### Additional information

if you need git repo https://github.com/ert78gb/node-22-test-runner-async-hooks","closed","ert78gb",496775,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/52764",2,"Testes de Regressão",NULL,4,"node version await keyword hook async order correct earlier node version work
","O título da issue ""test runner runs beforeEach or test case before ""before hook"" finished"" e o corpo da issue mencionam problemas com a ordem de execução de testes ('beforeEach', 'before hook'), indicando um problema de testes.  Os comentários sugerem uma correção, reforçando a natureza de testes de regressão."
149,52707,"2024-04-26 13:24:15","2024-04-28 13:39:36","2024-04-28 13:39:37","[22 regression] Breaks gulp with `Cannot assign to read only property 'atime' of object '#<Stats>'`","### Version

v22.0.0

### Platform

Linux

### Subsystem

fs

### What steps will reproduce the bug?

```js
""use strict"";
var fs = require(""fs"");
var stat = fs.statSync(""./package.json"")
stat.atime;
stat.atime = 2;
```

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

It should set `stat.atime` to `2`

### What do you see instead?

```
stat.atime = 2;
           ^

TypeError: Cannot assign to read only property 'atime' of object '#<Stats>'
    at Object.<anonymous> (/home/nic/Documents/dev/github.com/babel/babel/test.js:5:12)
    at Module._compile (node:internal/modules/cjs/loader:1455:14)
    at Module._extensions..js (node:internal/modules/cjs/loader:1534:10)
    at Module.load (node:internal/modules/cjs/loader:1265:32)
    at Module._load (node:internal/modules/cjs/loader:1081:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:187:14)
    at node:internal/main/run_main_module:28:49
```

### Additional information

Original bug report: https://github.com/gulpjs/vinyl-fs/issues/350

Caused by https://github.com/nodejs/node/pull/50908","closed","nicolo-ribaudo",7000710,"{confirmed-bug,fs,regression}","https://github.com/nodejs/node/issues/52707",3,"Ambos",NULL,2,"version linux fs passo reproduzir erro sempre esperado definir stat atime ver TypeError atribuir propriedade somente leitura objeto
","O título da issue contém ""regression"", indicando testes de regressão.  O corpo e os comentários discutem soluções e alternativas de código, incluindo a sugestão de reescrever partes do código ('rewrite gulpfile.js'), indicando refatoração. A combinação de ambos os aspectos justifica a classificação 'Ambos'."
150,52705,"2024-04-26 13:16:09","2024-04-28 13:39:37","2024-04-28 13:39:37","[22 regression] Infinite recursion when setting `stat.atime`","### Version

v22.0.0

### Platform

Linux

### Subsystem

fs

### What steps will reproduce the bug?

```js
var fs = requre(""fs"");
var stat = fs.statSync(""./package.json"")
stat.atime = 2
```

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

It should work

### What do you see instead?

It throws
```
Uncaught RangeError: Maximum call stack size exceeded
    at Stats.set [as atime] (node:internal/fs/utils:469:18)
    at Stats.set [as atime] (node:internal/fs/utils:469:18)
    at Stats.set [as atime] (node:internal/fs/utils:469:18)
    at Stats.set [as atime] (node:internal/fs/utils:469:18)
    at Stats.set [as atime] (node:internal/fs/utils:469:18)
    at Stats.set [as atime] (node:internal/fs/utils:469:18)
    at Stats.set [as atime] (node:internal/fs/utils:469:18)
    at Stats.set [as atime] (node:internal/fs/utils:469:18)
    at Stats.set [as atime] (node:internal/fs/utils:469:18)
```

### Additional information

- This is probably caused by https://github.com/nodejs/node/pull/50908 (cc @anonrig), since the setters defined in that PR just call themselves recursively
- I found this while investigating https://github.com/gulpjs/vinyl-fs/issues/350, which is probably another regression","closed","nicolo-ribaudo",7000710,"{confirmed-bug,fs,regression}","https://github.com/nodejs/node/issues/52705",4,"Ambos",NULL,2,"version v22 platform linux subsystem fs step reproduce bug var fs requre fs stat fss statsync package json stat atime how often reproduce required condition always expect behavior work see instead throw uncaught rangerror maximum call stack size exceed stat set atime stat set atime stat set atime stat set atime stat set atime stat set atime stat set atime stat set atime stat set atime stat set atime additional information probably cause setter define pr call recursively find investigate probably regression
","O título da issue ""[22 regression] Infinite recursion when setting `stat.atime`"" indica explicitamente uma regressão (Testes de Regressão). O corpo da issue descreve um problema de recursão infinita que necessita de refatoração no código para corrigir a causa raiz (Refatoração).  Os comentários também sugerem correções e investigação do problema, reforçando a necessidade de ambos os tipos de trabalho."
151,52682,"2024-04-25 06:40:43","2024-05-04 20:16:12","2024-08-23 08:48:07","npm on Windows fails with module not found for Node.js 22.0.0","### Version

22

### Platform

Windows

### Subsystem

_No response_

### What steps will reproduce the bug?

npm install command is enough to reproduce the issue.

Example workflow: https://github.com/CycloneDX/cdxgen/actions/runs/8823813113/job/24236408405#step:10:18

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

_No response_

### What do you see instead?

```console
node:internal/modules/cjs/loader:1205
  throw err;
  ^

Error: Cannot find module 'C:\npm\prefix\node_modules\npm\bin\npm-cli.js'
    at Module._resolveFilename (node:internal/modules/cjs/loader:1202:15)
    at Module._load (node:internal/modules/cjs/loader:1027:27)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:187:14)
    at node:internal/main/run_main_module:28:49 {
  code: 'MODULE_NOT_FOUND',
  requireStack: []
}
```

### Additional information

_No response_","closed","prabhu",7842,"{confirmed-bug,windows,npm}","https://github.com/nodejs/node/issues/52682",47,"Ambos",NULL,10,"npm install reproduzir problema sempre erro encontrar modulo
","A issue relata problemas com a instalação do npm no Windows, especificamente com o Node.js 22.0.0.  Muitos comentários descrevem problemas de encontrar o módulo npm, caminhos incorretos, e problemas com scripts npm e PowerShell.  Isso indica problemas tanto com a instalação e configuração (Refatoração, pois implica em ajustes na instalação e nos scripts) quanto com testes de regressão que falharam devido a esses problemas de instalação e configuração (Testes de Regressão, pois os testes falharam por conta dos erros encontrados).  A combinação de ambos os aspectos justifica a classificação 'Ambos'."
153,52386,"2024-04-06 07:40:47","2024-04-18 11:53:34","2024-04-19 06:37:49","After calling setupHistory, the program continues to run even after the REPL is closed.","### Version

v20.5.0

### Platform

macos

### Subsystem

_No response_

### What steps will reproduce the bug?

```js
const repl = require('repl');

var r = repl.start({});
r.setupHistory(__dirname + '/history', () => { }); // Different results will occur here
r.close();
```

### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior? Why is that the expected behavior?

_No response_

### What do you see instead?

After calling setupHistory, the program continues to run even after the REPL is closed.

### Additional information

_No response_","closed","LiST-GIT",523889,"{confirmed-bug,repl}","https://github.com/nodejs/node/issues/52386",6,"Ambos",NULL,12,"versão macos sistema resposta passo reproduzir erro programa continuar executar repl fechar comportamento esperado resposta ver invocar setuphistory programa continuar executar mesmo repl fechar informação adicional resposta
","A issue descreve um problema onde o programa continua a executar após o fechamento do REPL após a chamada de `setupHistory` (Testes de Regressão:  necessidade de testes para garantir o comportamento esperado ao fechar o REPL).  A solução envolve modificações no código para lidar corretamente com o fechamento do REPL e o gerenciamento de fluxos de entrada/saída (Refatoração:  melhorias no código para corrigir o comportamento incorreto). Os comentários discutem a implementação de testes, a necessidade de documentação e a refatoração do código para corrigir o problema. Portanto, a issue abrange tanto aspectos de refatoração quanto de testes de regressão."
156,52265,"2024-03-29 19:36:03","2024-05-29 05:05:37","2024-05-29 05:57:20","Process crashes when using `child_process.spawnSync(..., {stdio: ['pipe', 'overlapped', 'pipe']})`","### Version

v21.7.1

### Platform

Linux my-laptop 6.5.0-26-generic #26-Ubuntu SMP PREEMPT_DYNAMIC Tue Mar  5 21:19:28 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

child_process

### What steps will reproduce the bug?

```js
import {spawnSync} from 'node:child_process'

spawnSync('node', ['--version'], {stdio: ['pipe', 'overlapped', 'pipe']});
```

```
$ node example.js

  #  node[6410]: int node::SyncProcessRunner::ParseStdioOption(int, v8::Local<v8::Object>) at ../src/spawn_sync.cc:941
  #  Assertion failed: ""Unreachable code reached"" "": "" ""invalid child stdio type""

----- Native stack trace -----

 1: 0xe2fcb7 node::Assert(node::AssertionInfo const&) [node]
 2: 0xf4cc3f node::SyncProcessRunner::ParseStdioOption(int, v8::Local<v8::Object>) [node]
 3: 0xf4d8ba node::SyncProcessRunner::ParseStdioOptions(v8::Local<v8::Value>) [node]
 4: 0xf4df1b node::SyncProcessRunner::ParseOptions(v8::Local<v8::Value>) [node]
 5: 0xf4e16b node::SyncProcessRunner::TryInitializeAndRunLoop(v8::Local<v8::Value>) [node]
 6: 0xf4e538 node::SyncProcessRunner::Spawn(v8::FunctionCallbackInfo<v8::Value> const&) [node]
 7: 0x7b7167e0eadd 

----- JavaScript stack trace -----

1: spawnSync (node:internal/child_process:1110:29)
2: spawnSync (node:child_process:876:24)
3: file:///home/me/Desktop/a.js:3:1
4: run (node:internal/modules/esm/module_job:222:25)


Aborted (core dumped)
```

### How often does it reproduce? Is there a required condition?

I have only tried it on Linux. Since `overlapped` is intended for Windows, the behavior might differ there.

This only crashes with `spawnSync()`, not `spawn()`.

### What is the expected behavior? Why is that the expected behavior?

This should either behave like `pipe`, or throw an error. I am not sure which behavior would be the best there.

### What do you see instead?

The process crashes.

### Additional information

_No response_","closed","ehmicky",8136211,"{confirmed-bug,child_process}","https://github.com/nodejs/node/issues/52265",5,"Refatoração",NULL,60,"crash process spawnSync linux overlapped stdio option assertion fail unreachable code invalid child stdio type behavior differ windows crash spawn pipe error
","O título e o corpo da issue indicam um problema de crash do processo relacionado à utilização da função `child_process.spawnSync` com opções de `stdio` específicas.  Os comentários não oferecem evidências claras de testes de regressão, mas sim de tentativas de correção e resolução do problema.  A menção a 'fix dupe' sugere a resolução de uma duplicata de um bug, reforçando a ideia de refatoração para corrigir um comportamento incorreto. O foco principal é a correção de um problema de funcionamento, sem menção a novas funcionalidades ou testes sistemáticos."
161,51936,"2024-03-01 15:55:57","2024-04-04 11:16:46","2024-04-04 11:16:46","Stream memory leak in 20.11.1","### Version

v20.11.1

### Platform

Linux xxx SMP PREEMPT Tue Jan 9 09:56:30 CST 2024 aarch64 aarch64 aarch64 GNU/Linux (Debian-based distribution)

### Subsystem

_No response_

### What steps will reproduce the bug?

Using [`winston`](https://github.com/winstonjs/winston) with multiple custom transports and a lot of logger instances. Also requires a fairly large volume of logs being produced.

### How often does it reproduce? Is there a required condition?

Seems to happen every time we run our code.  
Doesn't happen on `v20.10.0`, this bug requires `node > v20.10.0`.  
We tested and changing the `UV_USE_IO_URING` value doesn't fix the bug (it seems to trade CPU usage vs RAM leak, but performance has regressed either way).  


### What is the expected behavior? Why is that the expected behavior?

Memory leak does not happen when logging huge volume of logs. It's expected because it used to be that way before upgrading from `v20.10.0` to `v20.11.1` (and IO_URING disabling doesn't seem to be at fault).

### What do you see instead?

Here's a RAM consumption graph from a staging environment where we reproduced the memory leak.  
The first three runs with memory leaks in this graph are when running on stock NodeJS `v20.11.1`.  
The last two runs are run with a custom NodeJS built from `v20.11.1` source by reverting commit [`dd52068`](https://github.com/nodejs/node/commit/dd52068).   
![Screenshot from 2024-03-01 17-47-49](https://github.com/nodejs/node/assets/13771292/d01d3b98-1614-4ced-9c7c-0d53c13c0b20)   
![Screenshot from 2024-03-01 17-51-25](https://github.com/nodejs/node/assets/13771292/5eeeb844-cd9f-457a-925e-aab47c7caf3f)   


### Additional information

_No response_","closed","kshaa",13771292,"{confirmed-bug,stream}","https://github.com/nodejs/node/issues/51936",9,"Ambos",NULL,34,"winston multiple custom transport logger instance large volume log happen every time run code happen v20100 bug require node v20100 test change uv_use_io_uring value fix bug seem trade cpu usage vs ram leak performance regress way memory leak happen log huge volume log expect way upgrade v20100 v20111 io_uring disable seem fault ram consumption graph staging environment reproduce memory leak three run memory leak graph run stock nodejs v20111 two run run custom nodejs build v20111 source revert commit dd52068
","A issue relata um vazamento de memória ('memory leak') em uma versão específica do Node.js (v20.11.1),  associado ao uso do logger Winston com alto volume de logs.  Os comentários mencionam testes de regressão (comparando comportamentos entre versões, buscando reproduzir o erro em ambientes controlados, e revertendo commits para investigar a causa). Além disso, há menção à necessidade de refatoração (simplificação do código, otimização do uso do Winston para evitar o vazamento de memória). Portanto, a issue envolve tanto atividades de testes de regressão quanto a necessidade de refatoração para solucionar o problema de vazamento de memória."
211,48640,"2023-07-03 03:58:31","2023-10-10 18:34:08","2024-02-08 08:46:31","`fs.readdir`'s new `recursive` option is not fully documented","### Affected URL(s)

https://nodejs.org/dist/latest-v20.x/docs/api/fs.html#fspromisesreaddirpath-options and callback/synchronous versions

### Description of the problem

~~From testing, the `recursive` option does not work with `withFileTypes: true`.~~
The behavior of the `recursive` option is not documented, and only `recursive`'s type and default value are present in the documentation. The callback-async `fs.readdir` and the synchronous `fs.readdirSync` yield erraneous results (entries missing or appear with missing fields) when both `recursive` and `withFileTypes` are supplied.

This issue tracks missing documentation. Incorrect behavior is tracked at #48858.","closed","That-Guy977",72870724,"{confirmed-bug,doc,fs}","https://github.com/nodejs/node/issues/48640",14,"Ambos",NULL,100,"problema documentação opção recursiva comportamento documentar tipo valor padrão callback assíncrono fs readdir sincronizar fs readdirsync resultado errôneo entrada faltar campo faltar issue rastrear documentação faltar comportamento incorreto rastrear
","A issue relata problemas de documentação ('problema documentação opção recursiva comportamento documentar', 'bug documentation issue', 'issue documentacao falta versao recursivo', 'missing documentation recursive option'), indicando a necessidade de Refatoração na documentação.  Ao mesmo tempo, há menção explícita a testes ('teste comportamento variar promessa callback versão sincrona', 'teste arquivo limit upload', 'callback sync teste falha investigar', 'testes de regressão'), indicando a necessidade de Testes de Regressão para verificar o comportamento da opção recursiva em diferentes cenários (promessa, callback, versão síncrona). A combinação de problemas de documentação e a necessidade de testes leva à classificação 'Ambos'."
165,51514,"2024-01-18 18:39:49","2024-02-04 17:13:01","2024-02-04 17:13:01","When constructing a `URL`, `256` is sometimes accepted as part of an IPv4 address.","### Version

v21.4.0

### Platform

Darwin chug.lan 22.6.0 Darwin Kernel Version 22.6.0: Tue Nov  7 21:42:27 PST 2023; root:xnu-8796.141.3.702.9~2/RELEASE_ARM64_T8103 arm64

### Subsystem

url

### What steps will reproduce the bug?

```bash
echo 'console.log(new URL(""http://1.1.1.256""))' | node -
```

### How often does it reproduce? Is there a required condition?

Always reproducible.

### What is the expected behavior? Why is that the expected behavior?

Expected to throw an error, e.g., if the `256` isn't the final component, it throws like this:

```
$ echo 'console.log(new URL(""http://1.1.256.1""))' | node -
node:internal/url:787
    this.#updateContext(bindingUrl.parse(input, base));
                                   ^

TypeError: Invalid URL
    at new URL (node:internal/url:787:36)
    [...]
    at Socket.emit (node:events:531:35) {
  code: 'ERR_INVALID_URL',
  input: 'http://1.1.256.1'
}
```

### What do you see instead?

```
$ echo 'console.log(new URL(""http://1.1.1.256""))' | node -
URL {
  href: 'http://1.1.1.256/',
  origin: 'http://1.1.1.256',
  protocol: 'http:',
  username: '',
  password: '',
  host: '1.1.1.256',
  hostname: '1.1.1.256',
  port: '',
  pathname: '/',
  search: '',
  searchParams: URLSearchParams {},
  hash: ''
}
```

### Additional information

Pretty sure this is considered a syntax error by RFC3986, which defines IPv4 address components like this:

```
IPv4address   = dec-octet ""."" dec-octet ""."" dec-octet ""."" dec-octet

dec-octet     = DIGIT                 ; 0-9
              / %x31-39 DIGIT         ; 10-99
              / ""1"" 2DIGIT            ; 100-199
              / ""2"" %x30-34 DIGIT     ; 200-249
              / ""25"" %x30-35          ; 250-255
```","closed","danfuzz",1090235,"{confirmed-bug,whatwg-url}","https://github.com/nodejs/node/issues/51514",3,"Ambos",NULL,17,"version v21 platform darwin kernel version arm64 subsystem url step reproduce bug echo node expected behavior throw error invalid url see instead url object additional information syntax error rfc define ipv4 address component dec octet
","O título indica um problema com a construção de URLs, sugerindo uma necessidade de refatoração para corrigir a validação de endereços IPv4.  Os comentários mencionam um 'bug' e uma correção ('fix'), indicando que testes de regressão são necessários para garantir que a correção não introduza novos problemas. A menção de 'backport' sugere que o problema precisa de correção em mais de uma versão, reforçando a necessidade de ambos os tipos de trabalho."
166,51508,"2024-01-18 08:33:32","2024-01-20 09:44:14","2024-01-20 09:44:14","`--env-file` parses commented out parts, when they contain quotation marks","### Version

v20.9.0

### Platform

Microsoft Windows NT 10.0.22621.0 x64

### Subsystem

_No response_

### What steps will reproduce the bug?

when using a .env file with entries like the one below, where there is a commented out part, nodeJS will parse the whole line as value, instead of just the expected ""VALUE1"" part.

`KEY=""VALUE1"" # or ""VALUE2"" or ""VALUE3""`

### How often does it reproduce? Is there a required condition?

Only happens, if the commented out part contains quotation marks as well.
Comments without quotation marks are correctly ignored, e.g.

`KEY=""VALUE1"" # or 'VALUE2' or 'VALUE3'` will correctly only parse the `VALUE1` part as value

### What is the expected behavior? Why is that the expected behavior?

process.env.KEY should have the value `VALUE1` only, the rest of the line is a comment that should not be parsed

### What do you see instead?

Currently it parsed the whole line instead, removing the first and last quotation mark:
`PROD"" # or ""TEST"" or ""DEV`

So it looks like the behaviour currently is to find the first and last quotation mark and treat everything in between as the value.

The same line, when parsed by `dotenv` does not give the same wrong result.

### Additional information

_No response_","closed","pano9000",102623907,"{confirmed-bug,dotenv}","https://github.com/nodejs/node/issues/51508",1,"Refatoração",NULL,2,"usar arquivo env entrada comentar parte nodejs analisar linha inteiro valor esperar valor1 key valor1 valor2 valor3 acontecer parte comentar conter aspas comentário aspas corretamente ignorar key valor1 valor2 valor3 corretamente analisar valor1 valor1 resto linha comentário analisar process env key valor valor1 linha comentário analisar atualmente analisar linha inteiro remover primeira última aspa prod test dev parecer comportamento atualmente encontrar primeira última aspa tratar tudo valor linha analisar dotenv dar resultado errado
","A issue descreve um problema de parsing de arquivos `.env` onde partes comentadas com aspas são interpretadas incorretamente.  A solução envolve refatorar a forma como o código analisa as linhas do arquivo `.env`, ignorando corretamente as partes comentadas que contêm aspas. Não há menção explícita a testes de regressão, embora uma refatoração dessa natureza provavelmente exigiria testes para garantir que a correção não introduza novos bugs."
169,51302,"2023-12-28 14:07:33","2024-08-20 12:42:18","2024-08-20 12:42:18","stream.eventNames() broken on 21.2.0+","### Version

v21.2.0

### Platform

Darwin COMP-JX471G9FQQ 23.2.0 Darwin Kernel Version 23.2.0: Wed Nov 15 21:53:18 PST 2023; root:xnu-10002.61.3~2/RELEASE_ARM64_T6000 arm64 arm Darwin

### Subsystem

streams

### What steps will reproduce the bug?

Use `stream.eventNames()` on a stream and you'll find it reports having event listeners for events which it does not actually have listeners for due to [this _events pre-allocation change](https://github.com/nodejs/node/pull/50428) which released in 21.2.0.

### How often does it reproduce? Is there a required condition?

Always.

### What is the expected behavior? Why is that the expected behavior?

`stream.eventNames()` should only return names of events for which there actually _are_ listeners.

### What do you see instead?

_All_ expected event types report having listeners because it's based on `Reflect.ownKeys(...)` which will see the explicit `undefined` keys as present and assume that means there are listeners for that event name.

### Additional information

_No response_","closed","Qard",205482,"{confirmed-bug,stream}","https://github.com/nodejs/node/issues/51302",6,"Refatoração",NULL,236,"stream eventNames report event listener event listener due change release


","O título da issue (""stream.eventNames() broken on 21.2.0+"") e o corpo sugerem um problema com a funcionalidade `stream.eventNames()`,  indicando a necessidade de correção de um comportamento existente. Os comentários discutem abordagens para resolver o problema, incluindo sugestões de otimizações (como pré-alocação) e mudanças em como o evento `eventName` é tratado.  Não há menção explícita a novos testes ou à adição de novos recursos; a ênfase é na melhoria do código existente.  Portanto, a classificação é Refatoração."
170,51245,"2023-12-21 08:02:51","2023-12-25 11:44:28","2023-12-25 11:44:28","ESM loader cannot detect module system properly in folder whose name ends with `node_modules`","### Version

v20.10.0

### Platform

Linux 4.4.0-19041-Microsoft #3636-Microsoft Thu Oct 19 17:41:00 PST 2023 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

`modules/esm`

### What steps will reproduce the bug?

The repo: <https://github.com/AnnAngela/node-issue>

The reproduce steps: <https://github.com/AnnAngela/node-issue/blob/08407276c119b18f12f0deb1193d4815dc8d6956/.github/workflows/test.yaml#L21-L22>

### How often does it reproduce? Is there a required condition?

Always reproduce, with the workding folder whose name ends with `node_modules`

### What is the expected behavior? Why is that the expected behavior?

Should not throw any error.

### What do you see instead?

The workflow log: <https://github.com/AnnAngela/node-issue/actions/runs/7285434922/job/19852334885#step:4:13>

### Additional information

I'm not sure if the working directory can only end with `node_modules`, or can start with `node_modules` or contain `node_modules` in the middle.","closed","AnnAngela",9762652,"{confirmed-bug,loaders}","https://github.com/nodejs/node/issues/51245",1,"Nenhum",NULL,4,"repo reproduzir passo trabalhar pasta nome terminar node_module reproduzir sempre comportamento esperado lancar erro ver workflow log certo trabalhar diretorio terminar node_module começar conter meio
","O título e o corpo da issue descrevem um problema com o carregador ESM (ECMAScript Module) que não detecta corretamente o sistema de módulos em pastas cujo nome termina com `node_modules`.  Não há menção explícita à refatoração de código ou à execução de testes de regressão. O comentário apenas menciona 'nodejs loader', que é relacionado ao problema, mas não indica a necessidade de refatoração ou testes de regressão."
172,51129,"2023-12-12 07:31:02","2023-12-25 12:12:55","2023-12-25 12:12:55","worker_threads: race and crash on worker exit","Reported with v20.9.0 but also present in ToT. Backtrace is from a debug build. 

<details>

```
  * frame #0: 0x000055b5ae1539a2 node-ci`v8::base::OS::Abort() at platform-posix.cc:691:5
    frame #1: 0x000055b5ae13f7dc node-ci`V8_Fatal(file="""", line=38, format="""") at logging.cc:167:22
    frame #2: 0x000055b5ae13f7fb node-ci`v8::base::(anonymous namespace)::DefaultDcheckHandler(file=<unavailable>, line=<unavailable>, message=<unavailable>) at logging.cc:57:11
    frame #3: 0x000055b5ac38785d node-ci`v8::Isolate::GetCurrent() at isolate-inl.h:38:3
    frame #4: 0x00007f0aec58f2e4
    frame #5: 0x000055b5ac725d5a node-ci`v8::internal::GlobalHandles::InvokeFirstPassWeakCallbacks() at global-handles.cc:865:11
    frame #6: 0x000055b5ac725d27 node-ci`v8::internal::GlobalHandles::InvokeFirstPassWeakCallbacks(this=<unavailable>) at global-handles.cc:839:23
    frame #7: 0x000055b5ac840e40 node-ci`v8::internal::Heap::PerformGarbageCollection(this=0x00007f05c42d2048, collector=MARK_COMPACTOR, gc_reason=<unavailable>, collector_reason=<unavailable>) at heap.cc:2312:59
    frame #8: 0x000055b5ac841cb7 node-ci`v8::internal::Heap::CollectGarbage(this=0x00007f05c42d2048, space=<unavailable>, gc_reason=kExternalFinalize, gc_callback_flags=kGCCallbackScheduleIdleGarbageCollection) at heap.cc:1781:33
    frame #9: 0x000055b5ac842fa4 node-ci`v8::internal::Heap::FinalizeIncrementalMarkingAtomically(v8::internal::GarbageCollectionReason) [inlined] v8::internal::Heap::CollectAllGarbage(gc_callback_flags=<unavailable>, gc_reason=kExternalFinalize, flags=<unavailable>, this=0x00007f05c42d2048) at heap.cc:1477:17
    frame #10: 0x000055b5ac842f8e node-ci`v8::internal::Heap::FinalizeIncrementalMarkingAtomically(this=0x00007f05c42d2048, gc_reason=kExternalFinalize) at heap.cc:3802:20
    frame #11: 0x000055b5ac7652f9 node-ci`v8::internal::CppHeap::DetachIsolate(this=0x00007f05c40fd7b0) at cpp-heap.cc:560:59
    frame #12: 0x000055b5ac81c162 node-ci`v8::internal::Heap::DetachCppHeap(this=0x00007f05c42d2048) at heap.cc:5769:42
    frame #13: 0x000055b5abf29d0a node-ci`node::IsolateData::~IsolateData(this=0x00007f05c40ea5c0) at env.cc:583:28
    frame #14: 0x000055b5abf29d84 node-ci`node::IsolateData::~IsolateData(this=0x00007f05c40ea5c0) at env.cc:586:1
    frame #15: 0x000055b5abe6d144 node-ci`node::FreeIsolateData(isolate_data=0x00007f05c40ea5c0) at environment.cc:408:10
    frame #16: 0x000055b5abe67e10 node-ci`node::FunctionDeleter<node::IsolateData, &node::FreeIsolateData(node::IsolateData*)>::operator()(this=0x00007f0ae5bf9c50, pointer=0x00007f05c40ea5c0) const at util.h:675:47
    frame #17: 0x000055b5abe685c6 node-ci`std::__uniq_ptr_impl<node::IsolateData, node::FunctionDeleter<node::IsolateData, &node::FreeIsolateData(node::IsolateData*)>>::reset(this=0x00007f0ae5bf9c50, __p=0x0000000000000000) at unique_ptr.h:182:16
    frame #18: 0x000055b5abe66fe7 node-ci`std::unique_ptr<node::IsolateData, node::FunctionDeleter<node::IsolateData, &node::FreeIsolateData(node::IsolateData*)>>::reset(this=nullptr, __p=0x0000000000000000) at unique_ptr.h:456:12
    frame #19: 0x000055b5ac1c0d04 node-ci`node::worker::WorkerThreadData::~WorkerThreadData(this=0x00007f0ae5bf98f0) at node_worker.cc:220:26
    frame #20: 0x000055b5ac1b99aa node-ci`node::worker::Worker::Run(this=0x000055b5b2a7b480) at node_worker.cc:406:1
    frame #21: 0x000055b5ac1bba0a node-ci`operator(__closure=0x0000000000000000, arg=0x000055b5b2a7b480) at node_worker.cc:683:11
    frame #22: 0x000055b5ac1bbaae node-ci`_FUN((null)=0x000055b5b2a7b480) at node_worker.cc:693:3
```

</details>

The race condition is difficult to trigger but the problem is obvious once you see it. The order of events in src/node_worker.cc is as follows:

1. `Worker::Run()` creates `WorkerThreadData data(this)` 

2. `WorkerThreadData` constructor creates the isolate and `IsolateData`

3. `Worker::Run()` enters and exits said isolate (constructs and destructs a `Locker` and `Isolate::Scope`)

4. `Worker::Run()` destructs the `WorkerThreadData` instance

5. `WorkerThreadData::~WorkerThreadData()` calls `IsolateData::~IsolateData()`

6. `IsolateData::~IsolateData()` calls `Isolate::DetachCppHeap()`

7. `Isolate::DetachCppHeap()` runs GC

8. `GlobalHandles::InvokeFirstPassWeakCallbacks()` calls `Isolate::GetCurrent()` but we've no longer entered the isolate (from step 3) and so it blows up violently

The solution IMO is to refactor so that the `Locker` stays around until the `WorkerThreadData` destructor finishes.

I believe the isolate can (and should) stay scoped to `Worker::Run()` and not leak out. Currently, `WorkerThreadData` ""loans"" the isolate to the `Worker` for no good reason I can see.

I can submit a patch but I'd like consensus on what approach to take before I start writing/refactoring/deleting code.","closed","bnoordhuis",275871,"{confirmed-bug,c++,worker}","https://github.com/nodejs/node/issues/51129",0,"Refatoração",NULL,13,"report version present debug build frame node ci v8 base os abort platform posix cc frame node v8 fatal file line format logging cc frame node v8 base anonymous namespace default dcheckhandler file line message logging cc frame node v8 isolate get current isolate inl h frame frame node v8 internal globalhandles invokefirstpassweakcallbacks global handles cc frame node v8 internal globalhandles invokefirstpassweakcallbacks global handles cc frame node v8 internal heap performgarbagecollection heap cc frame node v8 internal heap collectgarbage heap cc frame node v8 internal heap finalizeincrementalmarkingatomically heap cc frame node v8 internal heap finalizeincrementalmarkingatomatically heap cc frame node v8 internal cppheap detachisolate cpp heap cc frame node v8 internal heap detachcppheap heap cc frame node node isolatedata isolatedata env cc frame node node isolatedata isolatedata env cc frame node node freeisolatedata environment cc frame node node functiondeleter node isolatedata node freeisolatedata node isolatedata operator util h frame node std uniq ptr impl node isolatedata node functiondeleter node isolatedata node reset unique ptr h frame node std unique ptr node isolatedata node functiondeleter node isolatedata node reset unique ptr h frame node node worker workerthreaddata workerthreaddata node worker cc frame node node worker worker run node worker cc frame node operator node worker cc frame node fun node worker cc race condition difficult trigger problem obvious order event src node worker cc worker run create workerthreaddata workerthreaddata constructor create isolate isolatedata worker run enter exit isolate construct destruct locker isolate scope worker run destruct workerthreaddata instance workerthreaddata isolatedata call isolatedata call isolate detachcppheap isolate detachcppheap run gc globalhandles invokefirstpassweakcallbacks call isolate getcurrent longer enter isolate step blow violently solution imo refactor locker stay workerthreaddata destructor finish believe isolate stay scope worker run leak workerthreaddata loan isolate worker good reason submit patch like consensus approach take start writing refactoring deleting code
","O corpo da issue menciona explicitamente ""refactor"" e descreve a necessidade de refatorar o código para resolver um problema de concorrência.  A frase ""solution imo refactor locker stay workerthreaddata destructor finish believe isolate stay scope worker run"" indica uma proposta de solução via refatoração.  Apesar de mencionar problemas, a solução proposta foca na reestruturação do código, não em adicionar testes."
175,50878,"2023-11-23 15:10:14","2023-12-03 23:45:59","2023-12-03 23:45:59","[bug] `--abort-on-uncaught-exception` causes `containsModuleSyntax` to improperly throw `Uncaught SyntaxError: Cannot use import statement outside a module`","### Version

20.10.0

### Platform

Linux Alpine

### Subsystem

_No response_

### What steps will reproduce the bug?

This command works in 20.9.0, but not in 20.10.0, specifically when `--abort-on-uncaught-exception` opt is passed in:

```sh
$ NODE_OPTIONS=""--abort-on-uncaught-exception"" node_modules/.bin/knex migrate:make test

# outputs
Uncaught SyntaxError: Cannot use import statement outside a module
```

The version of knex:

```sh
node_modules/.bin/knex --version
Knex CLI version: 2.4.2
Knex Local version: 2.4.2
```

### How often does it reproduce? Is there a required condition?

Fails every time!

### What is the expected behavior? Why is that the expected behavior?

The migration was created by knex in 20.9.0

### What do you see instead?

Now it fails with this output:

```
Uncaught SyntaxError: Cannot use import statement outside a module

FROM
Module._extensions..js (node:internal/modules/cjs/loader:1407:23)
Module.load (node:internal/modules/cjs/loader:1207:32)
Module._load (node:internal/modules/cjs/loader:1023:12)
Module.require (node:internal/modules/cjs/loader:1235:19)
require (node:internal/modules/helpers:176:18)
Object.<anonymous> (/app/node_modules/.pnpm/debug@4.3.4_supports-color@9.2.2/node_modules/debug/src/node.js:32:24)
Module._compile (node:internal/modules/cjs/loader:1376:14)
Module._extensions..js (node:internal/modules/cjs/loader:1435:10)
Module.load (node:internal/modules/cjs/loader:1207:32)
Module._load (node:internal/modules/cjs/loader:1023:12)
Module.require (node:internal/modules/cjs/loader:1235:19)
require (node:internal/modules/helpers:176:18)
Object.<anonymous> (/app/node_modules/.pnpm/debug@4.3.4_supports-color@9.2.2/node_modules/debug/src/index.js:9:19)
Module._compile (node:internal/modules/cjs/loader:1376:14)
Module._extensions..js (node:internal/modules/cjs/loader:1435:10)
Module.load (node:internal/modules/cjs/loader:1207:32)
Module._load (node:internal/modules/cjs/loader:1023:12)
Module.require (node:internal/modules/cjs/loader:1235:19)
require (node:internal/modules/helpers:176:18)
Object.<anonymous> (/app/node_modules/.pnpm/knex@2.4.2_pg@8.11.0/node_modules/knex/lib/execution/transaction.js:4:15)
Module._compile (node:internal/modules/cjs/loader:1376:14)
Module._extensions..js (node:internal/modules/cjs/loader:1435:10)
Module.load (node:internal/modules/cjs/loader:1207:32)
Module._load (node:internal/modules/cjs/loader:1023:12)
Module.require (node:internal/modules/cjs/loader:1235:19)
require (node:internal/modules/helpers:176:18)
Object.<anonymous> (/app/node_modules/.pnpm/knex@2.4.2_pg@8.11.0/node_modules/knex/lib/client.js:10:21)
Module._compile (node:internal/modules/cjs/loader:1376:14)
Module._extensions..js (node:internal/modules/cjs/loader:1435:10)
Module.load (node:internal/modules/cjs/loader:1207:32)
Module._load (node:internal/modules/cjs/loader:1023:12)
Module.require (node:internal/modules/cjs/loader:1235:19)
require (node:internal/modules/helpers:176:18)
Object.<anonymous> (/app/node_modules/.pnpm/knex@2.4.2_pg@8.11.0/node_modules/knex/lib/knex-builder/Knex.js:1:16)
Module._compile (node:internal/modules/cjs/loader:1376:14)
Module._extensions..js (node:internal/modules/cjs/loader:1435:10)
Module.load (node:internal/modules/cjs/loader:1207:32)
Module._load (node:internal/modules/cjs/loader:1023:12)
Module.require (node:internal/modules/cjs/loader:1235:19)
require (node:internal/modules/helpers:176:18)
Object.<anonymous> (/app/node_modules/.pnpm/knex@2.4.2_pg@8.11.0/node_modules/knex/lib/index.js:1:14)
Module._compile (node:internal/modules/cjs/loader:1376:14)
Module._extensions..js (node:internal/modules/cjs/loader:1435:10)
Module.load (node:internal/modules/cjs/loader:1207:32)
Module._load (node:internal/modules/cjs/loader:1023:12)
Module.require (node:internal/modules/cjs/loader:1235:19)
require (node:internal/modules/helpers:176:18)
Object.<anonymous> (/app/node_modules/.pnpm/knex@2.4.2_pg@8.11.0/node_modules/knex/knex.js:8:14)
Module._compile (node:internal/modules/cjs/loader:1376:14)
Module._extensions..js (node:internal/modules/cjs/loader:1435:10)
Module.load (node:internal/modules/cjs/loader:1207:32)
Module._load (node:internal/modules/cjs/loader:1023:12)
Module.require (node:internal/modules/cjs/loader:1235:19)
require (node:internal/modules/helpers:176:18)
initKnex (/app/node_modules/.pnpm/knex@2.4.2_pg@8.11.0/node_modules/knex/bin/cli.js:83:16)
async Command.<anonymous> (/app/node_modules/.pnpm/knex@2.4.2_pg@8.11.0/node_modules/knex/bin/cli.js:221:26)Trace/breakpoint trap
```

### Additional information

_No response_","closed","KidkArolis",324440,"{confirmed-bug,module,esm}","https://github.com/nodejs/node/issues/50878",14,"Ambos",NULL,10,"comando funciona versão knex local versão migration criada knex versão falha tempo erro sintaxe importar declaração fora módulo
","O título da issue ([bug] `--abort-on-uncaught-exception` causes `containsModuleSyntax` to improperly throw `Uncaught SyntaxError: Cannot use import statement outside a module`) indica um bug (requerendo testes de regressão para garantir que a correção não introduza novos problemas).  O corpo e os comentários discutem a reprodução do erro, depuração e localização da causa raiz no módulo `containsModuleSyntax`, sugerindo a necessidade de refatoração para corrigir o problema subjacente no código."
179,50754,"2023-11-16 12:23:45","2023-12-02 18:32:32","2023-12-22 10:13:57","ERR_INTERNAL_ASSERTION","### Version

v21.1.0

### Platform

Microsoft Windows NT 10.0.22621.0 x64

### Subsystem

node:internal/assert:14

### What steps will reproduce the bug?

I don't know, it sometimes crashes after gathering data from the database. I'm using `nodemon` with `NX`.
The command that is running is `npm run dev`

### How often does it reproduce? Is there a required condition?

It happens every once in a while, this is the 5th time in an hour.

### What is the expected behavior? Why is that the expected behavior?

_No response_

### What do you see instead?

```cmd
node:internal/assert:14
    throw new ERR_INTERNAL_ASSERTION(message);
    ^
Error [ERR_INTERNAL_ASSERTION]: This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues
    at assert (node:internal/assert:14:11)
    at internalConnectMultiple (node:net:1118:3)
    at Timeout.internalConnectMultipleTimeout (node:net:1687:3)
    at listOnTimeout (node:internal/timers:575:11)
    at process.processTimers (node:internal/timers:514:7) {
  code: 'ERR_INTERNAL_ASSERTION'
}
```

### Additional information

_No response_","closed","SanderKok01",58295226,"{confirmed-bug,duplicate,net}","https://github.com/nodejs/node/issues/50754",9,"Nenhum",NULL,16,"node crash gather data database use nodemon nx command run npm dev happen occasionally time hour error err internal assertion cause bug nodejs incorrect usage nodejs internal open issue stack trace github nodejs node assert internal assert internal connect multiple timeout internal connect multiple timeout list on timeout process process timer code err internal assertion
","A issue descreve um erro interno ('ERR_INTERNAL_ASSERTION') no Node.js relacionado a conexões de banco de dados e timeouts.  Não há menção explícita a refatoração de código ou testes de regressão. Os comentários discutem a dificuldade de reproduzir o erro e possíveis soluções, mas não se referem a atividades de refatoração ou testes.  A menção a 'fix problem' nos comentários é vaga e não indica claramente se a solução envolveu refatoração ou testes de regressão."
183,50307,"2023-10-20 16:45:13","2023-10-25 10:41:13","2023-10-25 10:41:13","node test mock timer promisified setTimeout & setInterval don't always return the specified value","### Version

v20.5.1

### Platform

Microsoft Windows NT 10.0.22621.0 x64

### Subsystem

test

### What steps will reproduce the bug?

Mocked promisified `setTimeout` & `setInterval` don't return falsy values, and instead return numbers.

The reason for `setTimeout` is [here](https://github.com/nodejs/node/blob/a9756f3126a59d388fa9dbc13a951ce6b0151036/lib/internal/test_runner/mock/mock_timers.js#L181). It works correctly for truthy values, but returns an id for falsy values.

`setInterval` completely captures the value parameter for its own purposes so that it never resturns the value given to `setInterval` (see [here](https://github.com/nodejs/node/blob/a9756f3126a59d388fa9dbc13a951ce6b0151036/lib/internal/test_runner/mock/mock_timers.js#L125)).

```js
import assert from ""node:assert"";
import { test } from ""node:test"";
import timers from ""node:timers/promises"";

test(""original setTimeout"", async () => {
  for (const val of [true, false]) {
    const result = await timers.setTimeout(1, val);
    assert.equal(result, val);
  }
});

test(""mocked setTimeout"", async (context) => {
  context.mock.timers.enable();
  for (const val of [true, false]) {
    const promise = timers.setTimeout(1, val);
    context.mock.timers.tick();
    const result = await promise;
    assert.strictEqual(result, val);
  }
});

test(""original setInterval"", async () => {
  const iter = timers.setInterval(1, ""foo"");
  const result = await iter.next();
  iter.return();
  assert.deepStrictEqual(result, { done: false, value: ""foo"" });
});

test(""mocked setInterval"", async (context) => {
  context.mock.timers.enable();
  const iter = timers.setInterval(1, ""foo"");
  const promise = iter.next();
  context.mock.timers.tick();
  const result = await promise;
  iter.return();
  assert.deepStrictEqual(result, { done: false, value: ""foo"" });
});
```

fails with

```
❯ node .\index.mjs
✔ original setTimeout (6.8319ms)
✖ mocked setTimeout (2.0594ms)
  AssertionError [ERR_ASSERTION]: Expected values to be strictly equal:
  
  2 !== false
  
      at TestContext.<anonymous> (file:///C:/Users/mfischer/src/test/node-mock-timer-setTimeout/index.mjs:18:12)
      at async Test.run (node:internal/test_runner/test:581:9)
      at async Test.processPendingSubtests (node:internal/test_runner/test:325:7) {
    generatedMessage: true,
    code: 'ERR_ASSERTION',
    actual: 2,
    expected: false,
    operator: 'strictEqual'
  }

(node:38604) ExperimentalWarning: The MockTimers API is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
✔ original setInterval (2.2276ms)
✖ mocked setInterval (1.0964ms)
  AssertionError [ERR_ASSERTION]: Expected values to be strictly deep-equal:
  + actual - expected
  
    {
      done: false,
  +   value: 'foo1'
  -   value: 'foo'
    }
      at TestContext.<anonymous> (file:///C:/Users/mfischer/src/test/node-mock-timer-setTimeout/index.mjs:36:10)
      at async Test.run (node:internal/test_runner/test:581:9)
      at async Test.processPendingSubtests (node:internal/test_runner/test:325:7) {
    generatedMessage: true,
    code: 'ERR_ASSERTION',
    actual: [Object],
    expected: [Object],
    operator: 'deepStrictEqual'
  }
[...]
```

### How often does it reproduce? Is there a required condition?

Always

### What is the expected behavior? Why is that the expected behavior?

The mocked functions should return the value specified by the caller.

### What do you see instead?

The mocked functions (sometimes) return something else.

### Additional information

_No response_","closed","mika-fischer",426158,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/50307",8,"Ambos",NULL,5,"mock promisified settimeout setinterval return falsy value instead number reason settimeout work correctly truthy value return id falsy value setinterval completely capture value parameter purpose never resturn value given setinterval test original settimeout async val true false result await timer settimeout val assert equal result val test mock settimeout async context context mock timer enable val true false promise timer settimeout val context mock timer tick result await promise assert strict equal result val test original setinterval async iter timer setinterval foo result await iter next iter return assert deepstrict equal result done false value foo test mock setinterval async context context mock timer enable iter timer setinterval foo promise iter next context mock timer tick result await promise iter return assert deepstrict equal result done false value foo fail assertion error expect value strictly equal number false assertion error expect value strictly deep equal actual expect done false value foo value foo experimentalwarning mocktimer api experimental feature might change time
","O título da issue (""node test mock timer promisified setTimeout & setInterval don't always return the specified value"") e o corpo indicam um problema nos testes relacionados a mocks de timers (`setTimeout` e `setInterval`).  Os comentários discutem a correção do comportamento da função mockada, propondo mudanças no código para garantir que o valor especificado seja retornado, mesmo que seja falsy.  Isso envolve tanto a refatoração do código de teste (modificando a forma como os mocks funcionam) quanto a execução de testes de regressão para verificar se a correção não introduz novos bugs. A combinação de refatoração e testes de regressão justifica a classificação 'Ambos'."
184,50235,"2023-10-18 07:20:08","2023-10-19 01:00:56","2023-11-17 17:39:10","URL unexpectedly removes single digit ports","### Version

v18.18.2

### Platform

Darwin M12VHYH70W 23.0.0 Darwin Kernel Version 23.0.0: Fri Sep 15 14:41:43 PDT 2023; root:xnu-10002.1.13~1/RELEASE_ARM64_T6000 arm64

### Subsystem

url

### What steps will reproduce the bug?

```js
const { URL } = require(""url"");

let url;

url = new URL(""http://test.com:5"");
url.pathname = url.pathname.concat(""path"");
console.log(url.toString()); // works as expected without url params

url = new URL(""http://test.com:5/?param=1"");
url.pathname = url.pathname.concat(""path"");
console.log(url.toString()); // broken

url = new URL(""http://test.com:15/?param=1"");
url.pathname = url.pathname.concat(""path"");
console.log(url.toString()); // works as expected with double digit ports
```


### How often does it reproduce? Is there a required condition?

consistently wrong


### What is the expected behavior? Why is that the expected behavior?

```
http://test.com:5/path
http://test.com:5/path?param=1
http://test.com:15/path?param=1
```

### What do you see instead?

```
http://test.com:5/path
http://test.com/path?param=1
http://test.com:15/path?param=1
```

### Additional information

Having the url parameter set makes urllib forget a single digit port.","closed","rlindner81",9608015,"{confirmed-bug,whatwg-url}","https://github.com/nodejs/node/issues/50235",11,"Ambos",NULL,1,"problema url parametro dígito porta esquecer consistente errado
","O título da issue ""URL unexpectedly removes single digit ports"" indica um problema de bug que precisa de correção (Refatoração).  Os comentários mencionam ações como ""write fix"", ""fix include ada v2.7.3 merge node.js core"", e testes, como ""reproduce latest main"", ""bug ada url verification potential fix upstream report case"", indicando que testes de regressão são necessários após a correção do bug.  Portanto, a issue envolve ambos os aspectos."
259,44570,"2022-09-08 13:07:43","2022-09-10 22:21:16","2022-09-10 22:21:16","`crypto.pbkdf2Sync` results in an abort with some arguments","### Version

v18.8.0

### Platform

Linux zys-lab204l 5.15.0-46-generic #49~20.04.1-Ubuntu SMP Thu Aug 4 19:15:44 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

crypto

### What steps will reproduce the bug?

Setup a node instance,
```console
$ node
```
and run the following javascript code.
```js
crypto = require('crypto');crypto.pbkdf2Sync('str','str',2147485780,0,'str');
```
Then the node instance occurs an abort.

### How often does it reproduce? Is there a required condition?

This abort can always be triggered following the steps above.

### What is the expected behavior?

If any error occurs, an exception or other similar error-reporting stuff should be thrown. There is no reason to abort the whole node process.

### What do you see instead?

```console
 $ node                                            
Welcome to Node.js v18.8.0.
Type "".help"" for more information.
> crypto = require('crypto');crypto.pbkdf2Sync('str','str',2147485780,0,'str');
/home/zys/Toolchains/node/out/Release/node[1177351]: ../src/crypto/crypto_pbkdf2.cc:88:static Maybe<bool> node::crypto::PBKDF2Traits::AdditionalConfig(node::crypto::CryptoJobMode, const FunctionCallbackInfo<v8::Value> &, unsigned int, node::crypto::PBKDF2Config *): Assertion `args[offset + 2]->IsInt32()' failed.
 1: 0x3a4188f node::DumpBacktrace(_IO_FILE*) [/home/zys/Toolchains/node/out/Release/node]
 2: 0x3c22cf4 node::Abort() [/home/zys/Toolchains/node/out/Release/node]
 3: 0x3c22665 node::Assert(node::AssertionInfo const&) [/home/zys/Toolchains/node/out/Release/node]
 4: 0x40306f5 node::crypto::PBKDF2Traits::AdditionalConfig(node::crypto::CryptoJobMode, v8::FunctionCallbackInfo<v8::Value> const&, unsigned int, node::crypto::PBKDF2Config*) [/home/zys/Toolchains/node/out/Release/node]
 5: 0x4115ad2 node::crypto::DeriveBitsJob<node::crypto::PBKDF2Traits>::New(v8::FunctionCallbackInfo<v8::Value> const&) [/home/zys/Toolchains/node/out/Release/node]
 6: 0x4307694 v8::internal::FunctionCallbackArguments::Call(v8::internal::CallHandlerInfo) [/home/zys/Toolchains/node/out/Release/node]
 7: 0x4305840  [/home/zys/Toolchains/node/out/Release/node]
 8: 0x4304365 v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) [/home/zys/Toolchains/node/out/Release/node]
 9: 0x61a9139  [/home/zys/Toolchains/node/out/Release/node]
[1]    1177351 abort (core dumped)  /home/zys/Toolchains/node/out/Release/node
```

### Additional information

_No response_","closed","zyscoder",23655282,"{confirmed-bug,crypto}","https://github.com/nodejs/node/issues/44570",5,"Ambos",NULL,2,"node instance abort exception error report process pbkdf2sync argument integer assertion fail backtrace
","A issue relata um erro de aborto em `crypto.pbkdf2Sync` com certos argumentos.  Os comentários indicam que o problema não existe em versões anteriores, sugerindo uma regressão.  A menção a um commit semântico maior (semver major commit) e a sugestão de revisão de um changelog implicam a necessidade de refatoração para corrigir a raiz do problema, que é a forma como valores sem sinal são armazenados (como indicado pelo comentário sobre inteiros com sinal). Portanto, a issue requer tanto refatoração (para corrigir o armazenamento de valores) quanto testes de regressão (para garantir que a correção não introduza novos problemas)."
199,49056,"2023-08-07 17:15:50","2023-08-11 13:17:36","2023-08-11 13:17:36","test_runner: global after not run if handles are open","### Version

v20.5.0

### Platform

mac

### Subsystem

test_runner

### What steps will reproduce the bug?

Considder the following test:

```js
const { before, after, test } = require('node:test')
const { createServer } = require('http')

let server

before(async () => {
  console.log('before');
  server = createServer((req, res) => {
    res.end('hello')
  })

  await new Promise((resolve, reject) => {
    server.listen(0, (err) => {
      if (err) reject(err)
      else resolve()
    })
  })
})

after(() => {
  console.log('after');
  server.close()
})

test('something', () => {
  console.log('test');
})
```

We are trying to dispose of a server (or a connection to a DB) inside a global after but the global after is never run.

### How often does it reproduce? Is there a required condition?

all the times

### What is the expected behavior? Why is that the expected behavior?

for the test to pass / the after hook to be executed

### What do you see instead?

the after hook is not executed and therefore the test never terminates

### Additional information

_No response_","closed","mcollina",52195,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/49056",4,"Ambos",NULL,4,"test servidor global executar dispose conexão db passar gancho executar gancho executar teste terminar
","O título da issue ""test_runner: global after not run if handles are open"" indica um problema com testes (Testes de Regressão).  Os comentários discutem a necessidade de refatorar o mecanismo de detecção de execução de testes e a forma como os handles são gerenciados (Refatoração).  Portanto, a issue envolve tanto testes quanto refatoração de código."
189,49926,"2023-09-28 11:45:18","2023-10-03 18:19:53","2023-10-03 18:19:53","invalid location in tap reported when there is something that keep the tests from exiting and run global timeout reached","### Version

20.7.0

### Platform

Darwin Razs-MacBook-Pro.local 23.0.0 Darwin Kernel Version 23.0.0: Fri Sep 15 14:41:43 PDT 2023; root:xnu-10002.1.13~1/RELEASE_ARM64_T6000 arm64

### Subsystem

test_runner

### What steps will reproduce the bug?

1. clone https://github.com/rluvaton/tap-reporter-have-invalid-location-when-failed-on-before-hook-timeout
2. run `npm test`


### How often does it reproduce? Is there a required condition?

the test runner should stop the tests when there is something that keeps it running

### What is the expected behavior? Why is that the expected behavior?

to not see `undefined:undefined:undefined` in the `location`

### What do you see instead?

```
$ node ./run-tests.js

TAP version 13
# Subtest: should work
ok 1 - should work
  ---
  duration_ms: 1.079375
  ...
# Subtest: ./a.test.js
not ok 1 - ./a.test.js
  ---
  duration_ms: 5001.997458
  location: 'undefined:undefined:undefined' <--------------- invalid
  failureType: 'testTimeoutFailure'
  error: 'test timed out after 5000ms'
  code: 'ERR_TEST_FAILURE'
  stack: |-
    async Promise.allSettled (index 0)
  ...
1..2
# tests 2
# suites 0
# pass 1
# fail 0
# cancelled 1
# skipped 0
# todo 0
# duration_ms 5006.3885

Process finished with exit code 0
```

### Additional information

_No response_","closed","rluvaton",16746759,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/49926",3,"Ambos",NULL,5,"test runner stop test something keep run see undefined location invalid
","O título da issue indica um problema com testes ('tests'), sugerindo a necessidade de testes de regressão.  O corpo da issue menciona a necessidade de corrigir um caminho ('fix issue path'), e os comentários incluem menções a alterações de versão ('semver major change add') e a escrita de testes ('time write test day').  A combinação de correção de problemas e a necessidade de testes indica que tanto refatoração quanto testes de regressão são necessários."
191,49724,"2023-09-19 19:54:58","2023-09-29 08:46:34","2023-09-29 08:46:34","loader-returned sources always-cached when imported with `assert { type: 'json' }`","### Version

v20.6.1

### Platform

Linux duck 6.5.2-arch1-1 #1 SMP PREEMPT_DYNAMIC Wed, 06 Sep 2023 21:01:01 +0000 x86_64 GNU/Linux

### Subsystem

_No response_

### What steps will reproduce the bug?

 1. clone this reproduction repo https://github.com/iambumblehead/nodejs-import-attributes-repro
 2. cd into the cloned directory and use `npm test`

### How often does it reproduce? Is there a required condition?

the issue is reproduced every time

### What is the expected behavior? Why is that the expected behavior?

when json is imported with ""assert"" this way,
```javascript
import JSONobj from './example.json' assert { type: 'json' }
```
it should be possible for the loader to return dynamic, un-cached values to the importing file, following current behaviour around normally imported modules eg `import JSobj from './example.js'`

### What do you see instead?

Instead, when ""assert"" is used to import a json file, cached results are returned to the importing file, irregardless of what source value is returned by the loader. The example test attached below fails, but should pass.


---------------------------------
```javascript
import test from 'node:test'
import assert from 'node:assert'
import module from 'node:module'

module.register('./loader.js', {
  parentURL: import.meta.url
})

// _importing.js_
// ```
// import JSobj from './example.js'
// import JSONobj from './example.json' assert { type: 'json' }
// 
// export { JSobj, JSONobj }
// ```

// for ""module"" type modules, the loader can return different versions
// of that ""module"" source to multiple import contexts (desired behaviour),
test('loader can return fresh source, js', async () => {
  const importOne = await import('./importing.js?t=1')
  const importTwo = await import('./importing.js?t=2')

  assert.deepEqual(importOne.JSobj, { example: 'js-1' })
  assert.deepEqual(importTwo.JSobj, { example: 'js-2' })
})

// for ""json"" type modules, the loader cannot return different versions
// of that ""json"" source to different import contexts and, instead, the
// first version is seemingly cache-returned to any subsequently-importing 
// context (not-desired behaviour)
test('loader cannot return fresh source, json', async () => {
  const importThree = await import('./importing.js?t=3')
  const importFour = await import('./importing.js?t=4')

  assert.deepEqual(importThree.JSONobj, { example: 'json-3' })
  assert.deepEqual(importFour.JSONobj, { example: 'json-4' })
  // ^^ fails: importFour.JSONobj == `{ example: 'json-3' }`
})
```

### Additional information

related link about import attributes https://github.com/tc39/proposal-import-attributes#history

> 2023-03: The proposal is renamed to Import attributes and moves back to Stage 3 (TODO: notes, [slides](https://docs.google.com/presentation/d/1Abdr54Iflz_4sah2_yX2qS3K09qDJGV84qIZ6pHAqIk)). The restriction on the cache key is completely removed, and the keyword changes back from assert to with: import { x } from ""./mod"" with { type: ""json"" };. For compatibility with existing implementations, the assert keyword will still be supported until it's safe to remove it, if it will ever be.","closed","iambumblehead",2058705,"{confirmed-bug,loaders}","https://github.com/nodejs/node/issues/49724",11,"Ambos",NULL,10,"clone repositorio reproducao cd diretorio usar npm test issue reproduzir toda vez json importar assert forma possivel loader retornar valor dinamico nao cacheado arquivo importacao seguir comportamento normal modulo importado exemplo importar js usar assert importar arquivo json resultado cacheado retornado arquivo importacao independente valor fonte retornado loader exemplo teste anexado falha passar importar modulo tipo loader retornar versoes diferentes fonte modulo contexto importacao comportamento desejado importar tipo json loader retornar versoes diferentes fonte contexto importacao primeira versao aparentemente cache retornado contexto importacao subsequente comportamento nao desejado link relacionado atributo importacao proposta renomear atributo importacao voltar etapa restricao chave cache removida completamente palavra chave mudar assert compatibilidade implementacoes existentes palavra chave assert continuar suportado seguro remover caso seja
","A issue relata um problema com o cache do loader ao importar arquivos JSON usando `assert { type: 'json' }`.  Os comentários discutem a necessidade de mudanças no loader para produzir URLs diferentes a cada importação, evitando o cache indesejado. Isso indica um problema de refatoração no loader (para corrigir o comportamento de cache) e a necessidade de testes de regressão para garantir que a correção não introduza novos bugs.  A menção a testes unitários e testes em diferentes ambientes (browser e Node.js) reforça a necessidade de ambos os tipos de trabalho."
200,48995,"2023-08-02 09:51:32","2023-08-16 18:43:12","2023-08-16 19:10:00","[v20.5.0] Buffer.allocUnsafe and TextDecoder.decode doesn't play well.","### Version

v20.5.0

### Platform

Linux dell 6.4.0-1-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.4.4-1 (2023-07-23) x86_64 GNU/Linux

### Subsystem

_No response_

### What steps will reproduce the bug?

Here is some code to reproduce and explore the bug.
Both `Buffer.from([0x80])` and `Buffer.allocUnsafe(1)[0] = 0x80` will cause unstable behaviour in TextDecoder.decode
```js
let error1Count = 0
let error2Count = 0
for (let index = 0; index < 20000; index++) {
  try {
    const buffer = Buffer.from([0x80])   // this is unstable
    // const buffer = Buffer.allocUnsafe(1) // this is unstable
    // const buffer = Buffer.alloc(1)       // this is stable
    buffer[0] = 0x80
    const data = new TextDecoder('utf-8', {fatal: true}).decode(buffer)
    error1Count ++ // then data is the '\uFFFD' replacement character
  } catch {}
  try { // this is stable
    const data = new TextDecoder('utf-8', {fatal: true}).decode(new Uint8Array([0x80]))
    error2Count ++
  } catch {} 
}
console.log(error1Count, error2Count)
```

### How often does it reproduce? Is there a required condition?

Sometimes I have to run the code snippet a few times before the bug is seen.

### What is the expected behavior? Why is that the expected behavior?

Since I'm running the TextDecoder with `{fatal: true}` I expect the invalid input to ALWAYS throw an error.

### What do you see instead?

A few times (pretty much random) instead of throwing an error it outputs the `\uFFFD` replacement character. This should not be possible when `{fatal: true}` is used.

### Additional information

I have only tested on Linux Debian with Node v20.5.0.","closed","JoakimCh",5984627,"{confirmed-bug,buffer,encoding}","https://github.com/nodejs/node/issues/48995",10,"Ambos",NULL,14,"textdecoder utf error fatal true input always throw error instead sometimes output replacement character ufffd possible  run code snippet times bug  tested linux debian node
","O título da issue sugere um problema de compatibilidade entre `Buffer.allocUnsafe` e `TextDecoder.decode` ([v20.5.0] Buffer.allocUnsafe and TextDecoder.decode doesn't play well.), indicando uma necessidade de refatoração.  Os comentários, no entanto, discutem a adição de testes ('add test upstream', 'add test upstream research issue'), a validação de UTF ('fix issue validate utf'), e a investigação de falhas ('reproduce macOS Buffer use internal Buffer pool relate', 'expect data correct reproduction script call validate_utf8_with_errors time fail time machine sometimes fail validate_utf8 never fail'). A menção de testes de regressão e a necessidade de corrigir um comportamento incorreto apontam para a necessidade de ambos, refatoração e testes de regressão."
205,48916,"2023-07-25 10:25:38","2023-08-12 16:13:02","2023-08-12 16:13:02","Blob.stream().pipeTo() never resolves","### Version

20.5.0

### Platform

Darwin Kernel Version 21.3.0: Wed Jan  5 21:37:58 PST 2022; root:xnu-8019.80.24~20/RELEASE_ARM64_T6000 arm64

### Subsystem

_No response_

### What steps will reproduce the bug?

```js
async function main () {
  const blob = new Blob([
    new Uint8Array([
       58, 162, 101, 114, 111, 111, 116, 115, 129, 216,  42,
       88,  37,   0,   1,  85,  18,  32,  95, 102, 197,  19,
      218,  30, 103,  78, 133, 139,  57, 105,  28,  11,   0,
      246, 124, 167,  41, 140, 239, 220, 248, 168, 136,  35,
      196,  72, 236, 184, 232,  89, 103, 118, 101, 114, 115,
      105, 111, 110,   1
    ]),
    new Uint8Array([ 68 ]),
    new Uint8Array([
        1,  85,  18,  32,  95, 102, 197,  19,
      218,  30, 103,  78, 133, 139,  57, 105,
       28,  11,   0, 246, 124, 167,  41, 140,
      239, 220, 248, 168, 136,  35, 196,  72,
      236, 184, 232,  89
    ]),
    new Uint8Array([
       90, 189, 174, 145, 144, 134, 214,
      117,  47, 251, 231, 254,  29, 238,
        0,  29, 212, 201, 123, 107,  95,
      130,  24, 168, 207, 139, 134, 177,
      187,  88, 167,  36
    ])
  ])
  await blob.stream().pipeTo(new WritableStream({
    write (chunk) {
      console.log(chunk)
    }
  }))
}

main().then(() => console.log('done')).catch(console.error)
```

### How often does it reproduce? Is there a required condition?

Every run.

### What is the expected behavior? Why is that the expected behavior?

Expected to see all the chunks printed to console and then ""done"".

### What do you see instead?

```console
Uint8Array(59) [
   58, 162, 101, 114, 111, 111, 116, 115, 129, 216,  42,
   88,  37,   0,   1,  85,  18,  32,  95, 102, 197,  19,
  218,  30, 103,  78, 133, 139,  57, 105,  28,  11,   0,
  246, 124, 167,  41, 140, 239, 220, 248, 168, 136,  35,
  196,  72, 236, 184, 232,  89, 103, 118, 101, 114, 115,
  105, 111, 110,   1
]
Uint8Array(1) [ 68 ]
```

i.e. missing 2 chunks and no ""done""

### Additional information

_No response_","closed","alanshaw",152863,"{confirmed-bug}","https://github.com/nodejs/node/issues/48916",1,"Ambos",NULL,18,"versão plataforma darwin kernel versão resposta etapa reproduzir erro esperar ver chunk imprimir done ver ausente chunk done informação adicional
","A issue menciona problemas com o método `Blob.stream().pipeTo()` que não está resolvendo (título e body).  Os comentários demonstram testes realizados (`describe`, `it`, `assert`), incluindo testes em diferentes ambientes (node, Chrome, Firefox) e com frameworks de testes (como Jest ou Mocha, inferido pela sintaxe). A presença de testes e a necessidade de resolução de um problema de funcionamento (refatoração potencial para corrigir `Blob.stream().pipeTo()`) indicam que a issue envolve tanto refatoração quanto testes de regressão."
206,48884,"2023-07-22 10:12:59","2023-07-27 12:31:22","2023-08-10 15:26:22","`--experimental-permission` breaks REPL","### Version

20.5.0

### Platform

any

### Subsystem

permission model

### What steps will reproduce the bug?

Open a REPL and start typing:

```console
$ node --experimental-permission --allow-fs-read=/
> f
```

### How often does it reproduce? Is there a required condition?

Always.

### What is the expected behavior? Why is that the expected behavior?

No error.

### What do you see instead?

Fatal error:

```
node:internal/readline/emitKeypressEvents:74
            throw err;
            ^

Error: Access to this API has been restricted
    at Session.connect (node:inspector:68:7)
    at sendInspectorCommand (node:internal/util/inspector:52:11)
    at getGlobalLexicalScopeNames (node:repl:1262:10)
    at REPLServer.complete (node:repl:1493:26)
    at REPLServer.completer (node:repl:783:5)
    at showCompletionPreview (node:internal/repl/utils:230:10)
    at showPreview (node:internal/repl/utils:384:7)
    at REPLServer.self._ttyWrite (node:repl:1020:9)
    at ReadStream.onkeypress (node:internal/readline/interface:264:20)
    at ReadStream.emit (node:events:514:28) {
  code: 'ERR_ACCESS_DENIED',
  permission: 'Inspector',
  resource: 'Connect'
}

Node.js v20.5.0
```

### Additional information

Likely side effect of 34d92ed88c814e05b4b619705c67b3df3999c52d.","closed","tniessen",3109072,"{confirmed-bug,repl,permission}","https://github.com/nodejs/node/issues/48884",5,"Refatoração",NULL,5,"erro acesso api restringir sessão conectar inspector comando global lexical scope nome repl completar completer preview ttywrite readstream onkeypress emitir código err access denied permission inspector resource connect node versão
","O título da issue menciona a quebra do REPL (`--experimental-permission` breaks REPL), indicando um problema com a funcionalidade existente.  Os comentários discutem a criação de um novo isolamento V8 para contornar as permissões, sugerindo uma alteração na arquitetura ou na forma como o REPL interage com o inspector.  Não há menção explícita a testes de regressão, e a solução proposta parece focar na melhoria do código existente, características de uma refatoração."
212,48621,"2023-07-01 15:28:26","2023-07-21 03:46:19","2023-07-21 03:46:19","Signed integer overflow in latest node 18 LTS release","### Version

18.16.1

### Platform

_No response_

### Subsystem

deps/ada

### What steps will reproduce the bug?

As far as I can tell, any use of the URL constructor which now calls into native code from ada:

```
new URL('s://g');
```

This is reported when building with `ubsan`.

### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior? Why is that the expected behavior?

No undefined behavior caused by using the URL constructor.

### What do you see instead?

An integer overflow.

### Additional information

This was fixed upstream by using uint64 literals instead of signed ints: https://github.com/ada-url/ada/commit/38d6eae632d30155d3a5e23fea8175b5db36b697.","closed","jkrems",567540,"{confirmed-bug,whatwg-url}","https://github.com/nodejs/node/issues/48621",8,"Ambos",NULL,20,"version plataforma subsistema dep ada passo reproduzir erro uso construtor url chamar código nativo ada relatar construir ubsan frequência reproduzir condição esperado comportamento comportamento esperado comportamento indefinido causado usar construtor url ver inteiro transbordar informação adicional corrigir upstream usar literais uint64 inteiro assinado
","O título da issue indica um estouro de inteiro assinado, um problema de código que necessita de refatoração.  Os comentários discutem a necessidade de testes de regressão para garantir que a correção não introduza novos problemas, especialmente considerando a adição de uma nova dependência (Ada) e o impacto em lançamentos LTS. A discussão sobre a adição da dependência Ada, o seu impacto no desempenho e a necessidade de testes extensivos apontam para a necessidade de testes de regressão. A busca por uma solução para o estouro de inteiro indica a necessidade de refatoração. Portanto, tanto a refatoração quanto os testes de regressão são relevantes para resolver a issue."
213,48604,"2023-06-29 19:13:43","2023-07-24 20:55:20","2023-07-24 20:55:20","http: memory leak if a server is not closed","### Version

v18.16.1

### Platform

Mac

### Subsystem

http

### What steps will reproduce the bug?

Run

```js
const http = require('http')

async function main () {
  let i = 0
  while (true) {
    if (i % 100 === 0) {
      global.gc()
    }

    if (i % 100000 === 0) {
      console.log(process.memoryUsage())
    }

    http.createServer((req, res) => {})
    i++
  }
}

main()
```

### How often does it reproduce? Is there a required condition?

All the time

### What is the expected behavior? Why is that the expected behavior?

The memory should not grow uncontrolled

### What do you see instead?

Memory growing and after many iterations a crash

### Additional information

_No response_","closed","mcollina",52195,"{confirmed-bug,http}","https://github.com/nodejs/node/issues/48604",9,"Ambos",NULL,25,"versão plataforma mac subsistema passo reproduzir erro executar memória crescer descontrolado memória crescer iteração falha informação adicional
","O título da issue (""http: memory leak if a server is not closed"") indica um problema de vazamento de memória, que tipicamente requer refatoração para corrigir a causa raiz.  Porém, os comentários sugerem a necessidade de testes de regressão (""reproduce async loop"", ""fix issue"", ""confirm issue"") para verificar se a correção resolve o problema e não introduz novos bugs. A combinação de refatoração para resolver o vazamento de memória e testes para validar a correção justifica a classificação como 'Ambos'."
215,48230,"2023-05-28 12:51:20","2023-05-31 15:33:31","2023-05-31 15:33:31","test-runner: global `after` not working","### Version

20.2.0

### Platform

Linux 6.3.3-arch1-1 x86_64 GNU/Linux

### Subsystem

_No response_

### What steps will reproduce the bug?

`node --test test.js`

```js
const { before, after, test } = require('node:test')

before(() => console.log('before'))
after(() => console.log('after'))

test('test', () => console.log('test'))
```

### How often does it reproduce? Is there a required condition?

always

### What is the expected behavior? Why is that the expected behavior?

Expect printing `after` on stdout

### What do you see instead?

Only see `before` and `test` printing on stdout

### Additional information

_No response_","closed","darky",1832800,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/48230",0,"Testes de Regressão",NULL,3,"node test test js before after test print stdout expect print stdout
","O título da issue ""test-runner: global `after` not working"" e o corpo contendo termos como ""test"", ""before"", ""after"", ""expect"" e ""stdout"" indicam claramente um problema relacionado a testes.  A descrição sugere um problema com a execução de testes, especificamente com um gancho `after` global que não está funcionando corretamente. Não há menção a mudanças estruturais de código que caracterizariam refatoração."
217,47955,"2023-05-11 02:03:45","2023-05-15 14:27:48","2023-05-15 14:27:48","test module corrupts console.log output","### Version

v20.1.0

### Platform

Linux strapurp 5.15.0-56-generic #62-Ubuntu SMP Tue Nov 22 19:54:14 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

_No response_

### What steps will reproduce the bug?

`test/test-bug.mjs`:
```javascript
import test from ""node:test"";                                                   
                                                                                
test(""bug repro"", () => {                                                       
  console.log(new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]));                        
}); 
```

Run: `node --test test/test-bug.mjs`

### How often does it reproduce? Is there a required condition?

100% repro rate (not flaky).

Seems to happen when `[` is logged.

### What is the expected behavior? Why is that the expected behavior?

```
ℹ Uint8Array(8) [
ℹ   1, 2, 3, 4,
ℹ   5, 6, 7, 8
ℹ ]
✔ bug repro (1.678472ms)
ℹ tests 1
ℹ suites 0
ℹ pass 1
ℹ fail 0
ℹ cancelled 0
ℹ skipped 0
ℹ todo 0
ℹ duration_ms 35.77873
```

`console.log` in `--test` mode should show output similar to `console.log` in normal Node.js:

```
$ node -e 'console.log(new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]));'
Uint8Array(8) [
  1, 2, 3, 4,
  5, 6, 7, 8
]
```

### What do you see instead?

Logged elements of the Uint8Array are missing:
```
ℹ Uint8Array(8) [
ℹ 1
ℹ 5
ℹ ]
✔ bug repro (1.678472ms)
ℹ tests 1
ℹ suites 0
ℹ pass 1
ℹ fail 0
ℹ cancelled 0
ℹ skipped 0
ℹ todo 0
ℹ duration_ms 35.77873
```

### Additional information

I encountered this bug with Uint8Array.

I also encountered this bug with code like the following:
```javascript
console.log(`  [${i}] ...`);
```","closed","strager",48666,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/47955",6,"Testes de Regressão",NULL,5,"bug repro node test mode console log uint8array output missing element log element uint8array missing array element log bracket
","O título da issue (""test module corrupts console.log output"") e o corpo (""bug repro node test mode console log uint8array..."") indicam claramente um problema durante a execução de testes. Os comentários também se referem a problemas com o console.log durante testes ('console error', 'node test bug', 'tap parse').  Não há menção a alterações estruturais no código, apenas a correção de um bug em testes."
219,47918,"2023-05-08 13:10:22","2023-05-12 15:52:52","2023-05-12 15:53:02","`--use_strict` does not work with script and REPL, only work with stdin and eval","### Background
`--use_strict` is not my use case.

I'm just investigating `--use_strict`.

### Description

`--use_strict` works with stdin

```sh
$ cat actual.cjs | node --use_strict
{ isStrict: [ true, true ] }
```

`--use_strict` works with eval

```sh
$ node --use_strict -e ""$(cat actual.cjs)""
{ isStrict: [ true, true ] }
```

`--use_strict` not works file

```sh
$ node --use_strict actual.cjs
{ isStrict: [ false, false ] }
```

`--use_strict` not works REPL

```sh
$ node --use_strict
Welcome to Node.js v18.15.0.
Type "".help"" for more information.
> require('./actual.cjs')
{ isStrict: [ false, false ] }
{}
```


### Version

v18.15.0

### Platform

_No response_

### Subsystem

_No response_

### What steps will reproduce the bug?

==> actual.cjs <==

```js
#!/usr/bin/env -S node --use_strict


var isStrict = (function () {
  var a = !this;

  var b;
  try {
    eval(`with({}){}`);
    b = false;
  } catch {
    b = true;
  }

  return [a, b];
})();

console.log({ isStrict });
```

==> expected.cjs <==

```js
#!/usr/bin/env -S node
""use strict"";

var isStrict = (function () {
  var a = !this;

  var b;
  try {
    eval(`with({}){}`);
    b = false;
  } catch {
    b = true;
  }

  return [a, b];
})();

console.log({ isStrict });
```


### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior? Why is that the expected behavior?

```sh
$ node expected.cjs             
{ isStrict: [ true, true ] }
$ cat actual.cjs | node --use_strict
{ isStrict: [ true, true ] }
$ node --use_strict -e ""$(cat actual.cjs)""
{ isStrict: [ true, true ] }
```

should be

- or fix cli flag `--use_strict`

- or remove cli flag `--use_strict` https://github.com/nodejs/node/issues/6429

- or show message

```txt
$ node --use_strict actual.cjs
node:internal/modules/cjs/loader:xxx
  throw err;
  ^

Error:  The --use_strict flag does not work with script and REPL, only work with stdin and eval
    at xxx (node:internal/modules/cjs/loader:xxx:xxx) {
  code: 'INVALID_FLAG',
  requireStack: []
}

Node.js v18.15.0
```


### What do you see instead?
`--use_strict` not works file

```sh
$ node --use_strict actual.cjs
{ isStrict: [ false, false ] }
```

`--use_strict` not works REPL

```sh
$ node --use_strict
Welcome to Node.js v18.15.0.
Type "".help"" for more information.
> require('./actual.cjs')
{ isStrict: [ false, false ] }
{}
```

### Additional information

Seems related

https://github.com/nodejs/node/issues/4196

https://github.com/nodejs/node/issues/6429","closed","loynoir",78727408,"{confirmed-bug,duplicate,""v8 engine""}","https://github.com/nodejs/node/issues/47918",3,"Refatoração",NULL,4,"use_strict use case investigate use_strict work stdin cat actual cjs node use_strict isStrict true true use_strict work eval node use_strict cat actual cjs isStrict true true use_strict work file node use_strict actual cjs isStrict false false use_strict work repl node use_strict welcome node js v18.15.0 type help information require actual cjs isStrict false false version v18.15.0 step reproduce bug actual cjs env node use_strict var isStrict function var a this var b try eval with catch b return a b console log isStrict expected cjs env node use strict var isStrict function var a this var b try eval with catch b return a b console log isStrict often reproduce require condition expect behavior node expected cjs isStrict true true cat actual cjs node use_strict isStrict true true node use_strict cat actual cjs isStrict true true fix cli flag use_strict remove cli flag use_strict show message node use_strict actual cjs node internal modules cjs loader throw err error use_strict flag work script repl work stdin eval node js v18.15.0 see instead use_strict work file node use_strict actual cjs isStrict false false use_strict work repl node use_strict welcome node js v18.15.0 type help information require actual cjs isStrict false false additional information seem relate
","A issue descreve um problema com o funcionamento do `--use_strict` em diferentes contextos (stdin, eval, script, REPL).  A solução proposta envolve a remoção da flag `use_strict` e a exibição de uma mensagem. Isso indica uma mudança na implementação do interpretador, sem adicionar novos testes ou funcionalidades, caracterizando uma refatoração do código existente para corrigir um comportamento inesperado."
224,47726,"2023-04-26 13:55:20","2023-04-28 18:48:39","2023-04-28 18:48:39","test-dns-ipv6.js is broken","Both in GitHub actions and locally, for the last three weeks as far as I can tell:

```
=== release test-dns-ipv6 ===
Path: internet/test-dns-ipv6
test_resolve6
test_reverse_ipv6
node:internal/errors:490
    ErrorCaptureStackTrace(err);
    ^

Error: getHostByAddr EINVAL 2001:4860:4860::8888
    at node:internal/dns/promises:280:14
    at new Promise (<anonymous>)
    at createResolverPromise (node:internal/dns/promises:267:10)
    at ResolverBase.getHostByAddr (node:internal/dns/promises:299:12)
    at test_reverse_ipv6 (/home/runner/work/node/node/test/internet/test-dns-ipv6.js:72:36)
    at next (/home/runner/work/node/node/test/internet/test-dns-ipv6.js:22:7)
    at process.processTicksAndRejections (node:internal/process/task_queues:77:11) {
  errno: -22,
  code: 'EINVAL',
  syscall: 'getHostByAddr',
  hostname: '2001:4860:4860::8888'
}

Node.js v21.0.0-pre
Command: out/Release/node /home/runner/work/node/node/test/internet/test-dns-ipv6.js
```","closed","tniessen",3109072,"{confirmed-bug,dns,url,test,whatwg-url}","https://github.com/nodejs/node/issues/47726",9,"Ambos",NULL,2,"test dns ipv6 error gethostbyaddr einval nodejs
","O título da issue (""test-dns-ipv6.js is broken"") indica um problema de teste, sugerindo a necessidade de testes de regressão.  Porém, os comentários discutem um 'flaw' (falha) no código ('idna flaw', 'previous code flaw'),  a necessidade de adicionar uma nova função C++ ('add new c++ function'),  correções ('diff fix issue', 'revert change'), e revisão de código ('blame ead407915e510014e5294dd4446e29d8f3f04bdc').  Estas ações apontam para refatoração do código para corrigir o problema identificado nos testes. Portanto, a issue envolve tanto testes de regressão quanto refatoração."
225,47696,"2023-04-24 08:34:42","2023-04-24 22:32:11","2023-04-24 22:32:11","nested test counting is wrong","### Version

v18.16.0, v21.0.0-pre

### Platform

Darwin Moshes-MacBook-Pro.local 22.4.0 Darwin Kernel Version 22.4.0: Mon Mar  6 20:59:28 PST 2023; root:xnu-8796.101.5~3/RELEASE_ARM64_T6000 arm64

### Subsystem

test_runner

### What steps will reproduce the bug?

```shell
echo ""require('node:test')('1');require('node:test')('2');"" > a.js 
echo ""require('node:test')('3');"" > b.js 
./node --test-reporter=tap --test a.js b.js
```

### How often does it reproduce? Is there a required condition?

allways

### What is the expected behavior? Why is that the expected behavior?

```TAP
TAP version 13
# Subtest: 1
ok 1 - 1
  ---
  duration_ms: 0.454042
  ...
# Subtest: 2
ok 2 - 2
  ---
  duration_ms: 0.048792
  ...
# Subtest: 3
ok 3 - 3
  ---
  duration_ms: 0.4455
  ...
1..3
# tests 3
# suites 0
# pass 3
# fail 0
# cancelled 0
# skipped 0
# todo 0
```
each test should have its index

### What do you see instead?

```TAP
TAP version 13
# Subtest: 1
ok 1 - 1
  ---
  duration_ms: 0.454042
  ...
# Subtest: 2
ok 2 - 2
  ---
  duration_ms: 0.048792
  ...
# Subtest: 3
ok 2 - 3
  ---
  duration_ms: 0.4455
  ...
1..3
# tests 3
# suites 0
# pass 3
# fail 0
# cancelled 0
# skipped 0
# todo 0
```
tests are `ok 1` `ok 2` `ok 3`

### Additional information

_No response_","closed","MoLow",8221854,"{confirmed-bug,test_runner}","https://github.com/nodejs/node/issues/47696",0,"Testes de Regressão",NULL,1,"test runner index test ok
","O título da issue ""nested test counting is wrong"" indica um problema com a contagem de testes aninhados.  O corpo da issue (""test runner index test ok"") sugere uma investigação de um teste específico ou parte do processo de testes.  Não há menção a refatoração de código, apenas a um problema na execução ou contagem dos testes."
227,47644,"2023-04-20 15:56:14","2023-06-27 09:17:18","2024-04-04 10:40:41","SIGNAL USERS READ THIS FIRST: code: 'ERR_INTERNAL_ASSERTION' in internalConnectMultiple","### Version

20.0.0

### Platform

Darwin MacBookPro.local 22.3.0 Darwin Kernel Version 22.3.0: Mon Jan 30 20:42:11 PST 2023; root:xnu-8792.81.3~2/RELEASE_X86_64 x86_64

### Subsystem

_No response_

### What steps will reproduce the bug?

I ran the Storybook installation on Next.js 13.3.0 and this is what I see.

### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior? Why is that the expected behavior?

_No response_

### What do you see instead?

```
$ npx sb init

 storybook init - the simplest way to add a Storybook to your project. 

 • Detecting project type. ✓
 • Adding Storybook support to your ""Next"" app
node:internal/assert:14
    throw new ERR_INTERNAL_ASSERTION(message);
    ^

Error [ERR_INTERNAL_ASSERTION]: This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues

    at new NodeError (node:internal/errors:399:5)
    at assert (node:internal/assert:14:11)
    at internalConnectMultiple (node:net:1106:3)
    at Timeout.internalConnectMultipleTimeout (node:net:1637:3)
    at listOnTimeout (node:internal/timers:575:11)
    at process.processTimers (node:internal/timers:514:7) {
  code: 'ERR_INTERNAL_ASSERTION'
}

Node.js v20.0.0
```

### Additional information

_No response_","closed","yuki12321",21023147,"{confirmed-bug,net}","https://github.com/nodejs/node/issues/47644",54,"Ambos",NULL,68,"npx sb init storybook init simplest way add storybook project detect project type add storybook support next app error err internal assertion caus bug node js incorrect usag node js internal pleas open issu stack trac github nodejs node issu node error assert internalconnectmultiple timeout internalconnectmultipletimeout process timers cod err internal assertion node js v20
","O título e o corpo da issue indicam um erro interno ('ERR_INTERNAL_ASSERTION') no Node.js, sugerindo a necessidade de refatoração do código para corrigir a causa raiz do problema.  Os comentários, por sua vez, mostram diversos relatos do erro em produção e em diferentes ambientes, exigindo testes de regressão para garantir que a solução implementada não introduza novos problemas. A combinação de ambos os aspectos justifica a classificação 'Ambos'."
228,47614,"2023-04-19 06:36:26","2023-05-14 07:44:57","2023-05-14 07:44:57","Error when: node v20, `--test --loader`, await import","### Version

v20.0.0

### Platform

Darwin Bumbles-MBP.home 21.6.0 Darwin Kernel Version 21.6.0: Thu Mar  9 20:08:59 PST 2023; root:xnu-8020.240.18.700.8~1/RELEASE_X86_64 x86_64


### What steps will reproduce the bug?

 * clone [this repo](https://github.com/iambumblehead/nodejs-v20-loader-test-import-promise-error) or download [this package](https://github.com/nodejs/node/files/11269454/testnode.zip)
 * run `npm test` from the cloned or unpacked package
 * see the error

Essentially, using --loader and `await import('./path/to/module.js')` from inside any imported module causes the test to fail for no reason related to the test or any of the files used. 

<details>
  <summary>A copy of the error seen in the test process is attached here</summary>
  
```console
testnode$ npm test    

> test
> node --experimental-loader=./anyloader.js --test

ℹ (node:55506) ExperimentalWarning: Custom ESM Loaders is an experimental feature and might change at any time
ℹ (Use `node --trace-warnings ...` to show where the warning was created)
✖ should not show promise resolution error (3.975453ms)
  Error: Promise resolution is still pending but the event loop has already resolved
      at process.emit (node:events:523:35)

ℹ tests 1
ℹ suites 0
ℹ pass 0
ℹ fail 0
ℹ cancelled 1
ℹ skipped 0
ℹ todo 0
ℹ duration_ms 8.432653
ℹ THIS CONSOLE LOG IS PREINTED
ℹ tests 1
ℹ suites 0
ℹ pass 0
ℹ fail 0
ℹ cancelled 1
ℹ skipped 0
ℹ todo 0
ℹ duration_ms 150.112342

✖ failing tests:

✖ should not show promise resolution error (3.975453ms)
  Error: Promise resolution is still pending but the event loop has already resolved
      at process.emit (node:events:523:35)
```
</details>

### How often does it reproduce? Is there a required condition?

The issue is reproduced every time on this machine, using the package attached above

### What is the expected behavior? Why is that the expected behavior?

The test in the attached package should pass without any error, following the behaviour of previous versions of node from v12 onward.

### What do you see instead?

```console
Error: Promise resolution is still pending but the event loop has already resolved
```
In the example failing test, the test process reaches the passing condition but the test fails regardless","closed","iambumblehead",2058705,"{confirmed-bug,loaders,test_runner,v20.x}","https://github.com/nodejs/node/issues/47614",11,"Ambos",NULL,25,"test fail promise resolution pending event loop resolve nodejs v20 loader await import module test pass error previous version node behavior test process pass condition test fail regardless  experimental custom esm loaders experimental feature
","O título menciona um erro ('Error when...'), indicando um problema que precisa de correção.  O corpo e os comentários discutem testes ('test fail', 'test pass', 'test runner', 'test mjs import', 'test node test import', etc.), indicando a necessidade de testes de regressão para verificar a correção do erro.  A combinação de correção de erro e necessidade de testes de regressão leva à classificação 'Ambos'."
231,47520,"2023-04-12 04:09:01","2023-04-13 13:40:50","2023-07-03 06:43:02","diagnostics_channel: fix ref counting bug when reaching zero subscribers","I discovered a bug in some of the changes I landed with TracingChannel. Technically the bug existed before, but we've been discouraging use of `channel.subscribe(...)` and `channel.unsubscribe(...)`. With the TracingChannel changes I included a fix for the GC issue that allows `channel.subscribe(...)` and `channel.unsubscribe(...)` to work as they were originally intended, and some simplifications were made to make the top-level functions delegate to those. Unfortunately, there was an unnoticed issue where if the subscriber count ever dropped to zero the weakref would be deleted from the channels map but channel objects could still be held and therefore could still have subscribers added which would attempt an incRef on a weakref that's not there anymore. To handle that safely the delete actually has to happen only when there are no more strong refs, meaning when GC happens, so I've changed it to use `FinalizationRegistry` instead.","closed","Qard",205482,"{confirmed-bug,fast-track,needs-ci,diagnostics_channel,backport-requested-v18.x}","https://github.com/nodejs/node/pull/47520",15,"Refatoração","https://api.github.com/repos/nodejs/node/pulls/47520",1,"descobrir erro mudança aterrissar TracingChannel tecnicamente erro existir antes desencorajar uso channel subscribe channel unsubscribe mudança TracingChannel incluir correção problema GC permitir channel subscribe channel unsubscribe funcionar originalmente pretender simplificação fazer função nível superior delegar infelizmente problema ignorado contagem assinante cair zero weakref apagar mapa canal objeto manter ainda assinante adicionar tentar incRef weakref existir mais tratar seguramente apagar acontecer mais referência forte significar GC acontecer mudar usar FinalizationRegistry
","O título da issue ""diagnostics_channel: fix ref counting bug when reaching zero subscribers"" e o corpo da issue indicam uma correção de um bug relacionado à contagem de referências.  A descrição foca em mudanças na implementação do `TracingChannel` para resolver um problema de gerenciamento de memória (GC) e melhorar a forma como os assinantes são tratados.  Não há menção explícita a testes de regressão, apesar dos comentários 'CI' sugerirem integração contínua. A ênfase está na alteração do código para corrigir um bug sem introduzir novos recursos ou funcionalidades, o que caracteriza uma refatoração."
234,47090,"2023-03-14 17:29:41","2023-03-19 12:58:30","2023-08-10 15:26:33","Permission logic in fs.open(), fs.openSync(), and fsPromises.open() can easily be bypassed","The permission logic in these functions seems flawed. Using `fs.open()` or `fs.openSync()`, both read and write restrictions can easily be bypassed simply by passing extra flags. Some examples:

* `O_RDWR | 0x10000000` gives both read and write access - regardless of any restrictions.
* `O_RDONLY | O_NOCTTY` gives read access - even if all file system access has been blocked.
* `O_RDONLY | O_TEMPORARY` allows *deleting* files on Windows - even without write access.

`fsPromises.open()` contains similarly obvious flaws, but it also contains a mostly redundant (and likely also incorrect) check that always requires read permission, even if opening in a write-only mode. Still, as long as read permission is granted, code can open the file for writing using, for example, `O_RDWR | O_NOFOLLOW`.

Overall, this combination of multiple logical flaws trivially allows arbitrary read and write access to any file, even when access should be restricted.

---

I'm opening this as a public issue because the feature hasn't been released yet due to the previous vulnerability that was found by @cjihrig (see https://github.com/nodejs/node/pull/46975#issuecomment-1458496152).

---

The flawed validation logic is implemented here:

https://github.com/nodejs/node/blob/334bb179dfef5ad51e3dc1a7925a00b07bedada6/src/node_file.cc#L1968-L1982

The incorrect and/or redundant additional check in `fsPromises.open()` is implemented here:

https://github.com/nodejs/node/blob/334bb179dfef5ad51e3dc1a7925a00b07bedada6/src/node_file.cc#L2014-L2015

Followed by the same validation logic as above:

https://github.com/nodejs/node/blob/334bb179dfef5ad51e3dc1a7925a00b07bedada6/src/node_file.cc#L2023-L2037","closed","tniessen",3109072,"{confirmed-bug,fs,security,permission}","https://github.com/nodejs/node/issues/47090",0,"Refatoração",NULL,5,"permission logic function flawed use fs open fssync read write restriction easily bypass pass extra flag example read write access regardless restriction read access even file system access block allow delete file windows even write access fspromises open contain similarly obvious flaw also contain mostly redundant likely also incorrect check always require read permission even open write only mode long read permission grant code open file write example combination multiple logical flaw trivially allow arbitrary read write access file even access restrict open public issue feature release yet due previous vulnerability find see flawed validation logic implement incorrect redundant additional check fspromises open implement follow same validation logic above
","A issue descreve falhas na lógica de permissão das funções `fs.open()`, `fs.openSync()` e `fsPromises.open()`,  sugerindo que o código precisa ser revisado e refatorado para corrigir vulnerabilidades e melhorar a segurança.  Não há menção explícita a testes de regressão, embora a correção das falhas provavelmente exigiria esses testes para garantir que a refatoração não introduza novos problemas."
236,46850,"2023-02-26 16:04:18","2023-02-28 20:44:58","2023-02-28 20:44:58","Quotes in the URL are not percent encoded","### Version

19.7.0

### Platform

all

### Subsystem

_No response_

### What steps will reproduce the bug?

When parsing a url containing double quotes with `new URL()`, the quotes are not percent encoded.

Test code:
```javascript
const { href } = new URL('https://example.com/""quoted""');
console.log(href);
```


### How often does it reproduce? Is there a required condition?

Always


### What is the expected behavior?

Expected:
```javascript
const { href } = new URL('https://example.com/""quoted""');
console.log(href);
// => https://example.com/%22quoted%22
```


### What do you see instead?

Actual:
```javascript
const { href } = new URL('https://example.com/""quoted""');
console.log(href);
// => https://example.com/""quoted""
```


### Additional information

Last good: Node.js v19.6.1
First bad: Node.js v19.7.0

Seem to be regressed by #46410
","closed","asamuzaK",6790339,"{confirmed-bug,whatwg-url}","https://github.com/nodejs/node/issues/46850",5,"Ambos",NULL,2,"parse url conter dupla aspas new url aspas percent codificar teste codigo href new url example com quoted href esperar href new url example com quoted href example com quoted adicionar informacao regressar
","O título ""Quotes in the URL are not percent encoded"" indica um problema que precisa ser corrigido (refatoração).  O corpo menciona testes (""teste codigo"", ""web platform test cover edge case"") e a necessidade de um patch release (""patch release ada node fix issue""), indicando a necessidade de testes de regressão após a correção do código. A menção a 'código' e 'href' também sugere a necessidade de modificação no código (refatoração)."
242,46669,"2023-02-15 15:46:37","2023-02-23 09:47:15","2024-06-29 14:43:48","Error [ERR_INTERNAL_ASSERTION] with autoSelectFamily enabled","### Version

Node.js v19.6.0

### Platform

Darwin MacBook-Pro-de-Marco.local 22.3.0 Darwin Kernel Version 22.3.0: Thu Jan  5 20:48:54 PST 2023; root:xnu-8792.81.2~2/RELEASE_ARM64_T6000 arm64

### Subsystem

_No response_

### What steps will reproduce the bug?

Just connect to the mongod using mongosh, and after a while the console shows the Error maessage and stop the process.

### How often does it reproduce? Is there a required condition?

Every time

### What is the expected behavior?

Normal using

### What do you see instead?

```
node:internal/assert:14
    throw new ERR_INTERNAL_ASSERTION(message);
    ^

Error [ERR_INTERNAL_ASSERTION]: This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues

    at new NodeError (node:internal/errors:399:5)
    at assert (node:internal/assert:14:11)
    at internalConnectMultiple (node:net:1070:3)
    at Timeout.internalConnectMultipleTimeout (node:net:1565:3)
    at listOnTimeout (node:internal/timers:570:11)
    at process.processTimers (node:internal/timers:511:7) {
  code: 'ERR_INTERNAL_ASSERTION'
}
```

Node.js v19.6.0

### Additional information

_No response_","closed","marcopdonoso",83668664,"{confirmed-bug,net}","https://github.com/nodejs/node/issues/46669",11,"Ambos",NULL,8,"connect mongod mongosh tempo console mostrar erro parar processo ocorrer sempre usar normal erro interno causar erro nodejs uso incorreto interno nodejs abrir issue stack trace nodejs node
","O título menciona um erro interno ('Error [ERR_INTERNAL_ASSERTION]'), sugerindo um problema que precisa de refatoração no código.  Os comentários, no entanto, discutem a reprodução do erro, testes com diferentes versões do Node.js e do Mongosh, e a busca por duplicatas de issues, indicando a necessidade de testes de regressão para garantir que a correção não introduza novos problemas.  A combinação de ambos os aspectos justifica a classificação como 'Ambos'."
248,45874,"2022-12-15 16:57:08","2023-01-14 14:16:30","2023-01-14 14:16:30","chacha20-poly1305 decryption works without setting authTag on decypher in v16","### Version

v16.19.0 / v18.12.1

### Platform

Linux andi-vm 5.15.0-56-generic #62-Ubuntu SMP Tue Nov 22 19:54:14 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux

### Subsystem

_No response_

### What steps will reproduce the bug?

```js
    import { createCipheriv, createDecipheriv, randomBytes } from 'crypto';

    const nonce = 12;
    const algorithm = 'chacha20-poly1305';
    const encryptionKey = 'qwertyuiopasdfghjklzxcvbnm123456';
    const file = Buffer.from('Some file', 'utf-8');

    const iv1 = randomBytes(nonce);
    const cipher = createCipheriv(algorithm, encryptionKey, iv1, { authTagLength: 16 });
    const encrypted = Buffer.concat([iv1, cipher.update(file), cipher.final()]);
    const authTag = cipher.getAuthTag();

    const iv2 = encrypted.slice(0, nonce);
    const toDecrypt = encrypted.slice(nonce);
    const decipher = createDecipheriv(algorithm, encryptionKey, iv2, { authTagLength: 16 });
    //decipher.setAuthTag(authTag);
    const result = Buffer.concat([decipher.update(toDecrypt), decipher.final()]);
    console.log(result.toString());
```

### How often does it reproduce? Is there a required condition?

If running the code using the node v16.19.0, the code runs without throwing an error. If I change to node v18.12.1, an error is thrown, as per the docs.

### What is the expected behavior?

According to the docs: 

>[...] the decipher.setAuthTag() method is used to pass in the received authentication tag. If no tag is provided, or if the cipher text has been tampered with, [decipher.final()](https://nodejs.org/docs/latest-v18.x/api/crypto.html#decipherfinaloutputencoding) will throw, indicating that the cipher text should be discarded due to failed authentication.[...]

I would expect the code snipped above to fail, since the authTag is not set on the decypher. 


### What do you see instead?

The code snippet above runs without throwing any error. It successfully prints ""Some file"".

### Additional information

As soon as I switch from node v16 to v18, the code snipped throws an error, as expected. Uncommenting the `setAuthTag` line  makes the code work. If this is expected behavior in v16 (vs v18), I'd be happy to be guided to a doc/changelog that explains this change.","closed","anst270125",20873765,"{confirmed-bug,crypto}","https://github.com/nodejs/node/issues/45874",8,"Ambos",NULL,30,"node v16 v18 error authtag decipher final method  code run error doc changelog  expect code fail authtag set  code run error print file  switch node v16 v18 code throw error expect uncomment set authtag line code work expect behavior v16 v18 doc changelog explain change
","A issue descreve um problema de compatibilidade entre as versões v16 e v18 do Node.js relacionado à criptografia chacha20-poly1305.  O corpo da issue menciona erros de `authtag` e a necessidade de ajustes no código para funcionar corretamente em ambas as versões. Os comentários incluem discussões sobre testes e a reprodução do erro,  e uma sugestão de pull request para corrigir o problema.  Portanto, a issue envolve tanto refatoração (ajuste de código para compatibilidade) quanto testes de regressão (verificação da compatibilidade entre versões)."
250,45757,"2022-12-06 12:36:16","2022-12-09 11:24:53","2022-12-09 11:24:53","crypto: cipher update process crash with input of max int32 length","### Version

v18.12.0

### Platform

_No response_

### Subsystem

crypto

### What steps will reproduce the bug?

```js
try {
    require('crypto')
    .createCipheriv('aes-128-gcm', Buffer.alloc(16), Buffer.alloc(12))
    .update(Buffer.allocUnsafeSlow(2**31-1));
}
catch (error) {
    console.error(error);
}
```

### How often does it reproduce? Is there a required condition?

Every time.

### What is the expected behavior?

Throw a normal catchable error like `size>=2**31` do, or work right like `size<=2**31`.

### What do you see instead?

Only `size===2**31-1` will cause an uncatchable process crash.

### Additional information

_No response_","closed","LongTengDao",26104024,"{confirmed-bug,crypto}","https://github.com/nodejs/node/issues/45757",6,"Ambos",NULL,3,"version v18 plataforma sem resposta subsistema crypto passo reproduzir erro criar cifra aes gcm tamanho buffer causar processo falha comportamento esperado lançar erro tratável tamanho igual superior trabalhar tamanho inferior ver tamanho causar processo falha informação adicional sem resposta
","O título da issue (""crypto: cipher update process crash with input of max int32 length"") indica um problema de funcionamento (crash) no processo de atualização de cifra.  O corpo da issue descreve um problema de falha de processo relacionado ao tamanho do buffer. Os comentários apontam para um possível estouro de inteiro assinado (signed integer overflow) no OpenSSL, sugerindo um problema tanto de funcionalidade quanto na implementação do código. A solução proposta nos comentários (""fix len block size convert size_t"") sugere uma alteração na manipulação do tamanho do bloco (refatoração), mas também precisa de testes de regressão para garantir que a correção não introduza novos problemas. Portanto, a issue engloba tanto refatoração (correção do código) quanto necessidade de testes de regressão para validar a solução."
253,45404,"2022-11-10 10:04:42","2022-11-18 03:59:47","2022-11-18 03:59:47","fs.rm cannot delete a symlink which is part of a loop","### Version

18.12.1

### Platform

Darwin Nathanaels-MBP.fritz.box 22.1.0 Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:30 PDT 2022; root:xnu-8792.41.9~2/RELEASE_ARM64_T8103 arm64

### Subsystem

fs

### What steps will reproduce the bug?

```sh
mkdir repro
cd repro
ln -s a b && ln -s b a
node -e 'fs.rmSync(""a"")'
cd ..
rm -r repro
```

### How often does it reproduce? Is there a required condition?

Always. No.

### What is the expected behavior?

Can delete symlinks that form a loop.

### What do you see instead?

This error
```
Uncaught Error: ELOOP: too many symbolic links encountered, stat 'a'
    at Object.statSync (node:fs:1596:3)
    at __node_internal_ (node:internal/fs/utils:804:8)
    at Object.rmSync (node:fs:1272:13) {
  errno: -62,
  syscall: 'stat',
  code: 'ELOOP',
  path: 'a'
}
```

### Additional information

This `stat` call should probably be a `lstat`call.
https://github.com/nodejs/node/blob/1b971883e0c86f37468e421ffe5f39b585782ad6/lib/internal/fs/utils.js#L772","closed","nathanael-ruf",104262550,"{confirmed-bug,fs}","https://github.com/nodejs/node/issues/45404",2,"Refatoração",NULL,8,"erro stat symbolic link loop deletar  fs  rmSync  node  eliminar
","O título da issue ""fs.rm cannot delete a symlink which is part of a loop"" indica um problema com a funcionalidade de exclusão de links simbólicos em loop do módulo `fs`.  O corpo da issue menciona erros relacionados a `fs.rmSync` e `node`, sugerindo a necessidade de ajustes no código para lidar corretamente com essa situação. Os comentários sugerem uma solução alternativa (workaround) e um convite para envio de Pull Request para corrigir o problema.  Isso indica uma necessidade de refatoração do código para resolver o bug, sem menção explícita à necessidade de novos testes de regressão além dos que provavelmente já existem para testar a funcionalidade `fs.rm`."
254,45336,"2022-11-06 11:39:39","2022-11-17 18:17:50","2022-11-17 18:17:50","`Object.freeze(NODEJS_BUILTIN_GLOBAL_AND_ITS_PROTOTYPE)` may lead to crash","### Version

v18.12.0

### Platform

_No response_

### Subsystem

_No response_

### What steps will reproduce the bug?
Protect from prototype pollution inspired by https://github.com/snyk-labs/nopp/blob/main/index.js

reproduce.mjs
```js
import globals from ""globals"";

for (const k of [...new Set(Object.values(globals).map(x => Object.keys(x)).flat())]) {
  if (k in globalThis) {
    const v = globalThis[k]
    try { Object.freeze(v) } catch { }
    try { Object.freeze(v.prototype) } catch { }
  }
}
```

### How often does it reproduce? Is there a required condition?

_No response_

### What is the expected behavior?

No error.

### What do you see instead?

```
$ node
Welcome to Node.js v18.12.0.
> void await import('./reproduce.mjs')
Uncaught TypeError: Cannot delete property 'crypto' of #<Object>
> crypto
Uncaught TypeError: Cannot delete property 'crypto' of #<Object>
    at get (node:internal/modules/cjs/helpers:181:23)
> globalThis.crypto
Uncaught TypeError: Cannot delete property 'crypto' of #<Object>
    at get (node:internal/modules/cjs/helpers:181:23)
```

### Additional information

_No response_","closed","loynoir",78727408,"{confirmed-bug}","https://github.com/nodejs/node/issues/45336",3,"Refatoração",NULL,11,"node TypeError delete property crypto object freeze prototype
","O título e os comentários sugerem um problema com o congelamento de objetos embutidos no Node.js (`Object.freeze`).  A descrição indica um erro (`TypeError`) relacionado à deleção de propriedades em um objeto congelado.  A solução provavelmente envolveria refatoração do código para evitar o congelamento de objetos que precisam ser modificados, sem necessariamente envolver a criação ou execução de novos testes de regressão. A ênfase está em corrigir o código existente para evitar o erro, não em verificar o comportamento de código existente."
